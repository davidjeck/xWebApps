<!DOCTYPE html>
<!--
    Web page written by David Eck (https://math.hws.edu/eck/index.html)
    You can do anything you like with this web page and with the code, but
    if you use a substantial portion of it, you should include attribution.
    
    This web app is a simulation of a simple model computer
    
    The original xComputer program was written in about 1993 in Macintosh Object
    Pascal and was translated into a Java applet in about 1997.  This JavaScript
    version is a translation of the Java applet, and its heritage is
    responsible for some of the code not following the usual JavaScript conventions.
    
    The ability to save and load local files was added in November, 2023.  At the
    same time, the handling of the popup menu of examples was changed to allow
    the list of the programs to be set by a search component in the URL that is
    used to access the web app -- see the long comment at the beginning of the
    script, below.
-->

<head>
<title>xComputer</title>

<style>
    .heading {
       font-size: 125%;
       color: #CC0000;
       padding: 0;
       margin: 5pt;
    }
    table.prog  {
       background-color: #EEEEFF;
    }
    table {
       background-color: #EEEEEE;
    }
    .wire {
       font-size: 65%;
       padding: 1pt;
       margin: 1pt;
       white-space: pre;
    }
    table.wiretable td, table.wiretable tr {
       padding: 0;
       margin: 0;
    }
    input {
       background-color:white;
       padding: 2pt;
       color: black;
    }
    .label {
       color: #0000CC;
    }
    span.label {
        margin-left: 15pt;
    }
    #graphics {
       display: block;
       background-color: white;
    }
    #graphicsholder {
       border: solid 1pt red;
       margin: 10pt 5pt;
       padding: 0;
    }
    textarea {
       background-color: white;
       color:black;
    }
    html, body {
       background-color: #EEEEFF;
    }
    h2 {
       padding: 0;
       margin: 0;
    }
    p.mem {
       font-family: monospace;
       font-size: 90%;
       padding: 1pt 2pt;
       margin: 0pt;
       white-space: pre;
       color: black;
       background-color: white;
    }
    span.loc {
       color: #0000CC;
    }
    #memholder {
       height: 380px;
       background-color: white;
       overflow-y: scroll;
       overflow-x: hidden;
       border: solid 1pt black;
       padding: 4pt;
    }
    #mem {
       padding: 0;
       margin: 0;
    }
    #error {
       margin-left: 20pt;
       color: #CC0000;
       width: 800pt;
    }
    input[readonly] {
       border: none;
    }
   #memexportbg {
       position: fixed;
       z-index: 10;
       opacity: 0.7;
       background-color: black;
       left: 0;
       top: 0;
       width: 100%;
       height: 100%;
       display: none;
   }
   #memexport {
       position: fixed;
       left: 100px;
       top: 50px;
       z-index:20;
       padding: 10px;
       background-color: #D8D8FF;
       border: 2px solid #000099;
       border-radius: 16px;
       box-shadow: 5px 5px 8px black;
       display: none;
   }</style>

<script>
   
/* programsToLoad contains a list of sample programs that are available on the web site.
 * If this web app is loaded thruogh a URL with no search component, the programs will appear in
 * a popup menu above the textarea that serves as a program editor in the app, and the first program
 * will be loaded into the textarea.  If the search component in the URL is "?files=none", this
 * behavior is surpressed.  Otherwise, in a search component has the form "?files=..." then ... must 
 * be a relative URL to a text file containing a list of files for the popup menu. The content
 * of the file should be a JSON object with the same form as programsToLoad.  That string
 * will replace programsToLoad and will be treated in the same way.  If the file can't be
 * loaded, or if its content does not have the correct form, no files will appear in the menu.
 * The value of an array of objects.  Each object has a "name" property, which will appear
 * in the popup menu, and a "url" property, which is a relative URL to the the file.
 */
   
var programsToLoad = [  
   { "name": "The Basics", "url": "programs/TheBasics.txt"},
   { "name": "Multiplication Using Labels", "url": "programs/Labels.txt"},
   { "name": "Graphical View of Memory", "url": "programs/Graphics.txt"},
   { "name": "Three-N-plus-one Sequence", "url": "programs/Three_N_Plus_One.txt"},
   { "name": "Using a Subroutine", "url": "programs/ListSumSubroutine.txt"},
   { "name": "Multiplication by Subroutine", "url": "programs/MultiplicationWithSubroutine.txt"},
   { "name": "Testing for Prime Numbers", "url": "programs/PrimeTest.txt"},
   { "name": "Powers of Three", "url": "programs/PowersOfThree.txt"}
];




var buttons;
var speed;
var registerDisplay;
var memDisplay;
var graphicsCanvas;
var g;
var globalConverter;
var untitledCount;
var wires;
var wireset; // currently selected wires
var memory;
var autoscroll;
var running = false;
var executionState = "idle";
var frameRequest = null;
var frameCountdown;
var dimmed = false; // if true, minimal UI update while running
var programs;
var programInEditor;

function ParseError(message, pos) {
   this.message = message;
   this.pos = pos;
}

function parse(str, parseOneInstructionOnly){
      var buffer = "";
      var input = str;
      var length = str.length;
      var pos = 0;
      if (parseOneInstructionOnly)
         return parseOneInstruction();
      var data = new Uint16Array(1024);
      var dataCt = 0;
      var labelNames = [];
      var unfinishedLabelData = new Int32Array(1024);
      for (let i = 0; i < 1024; i++)
         unfinishedLabelData[i] = -1;
      skip();
      if (length == pos)
         doError("The program does not contain any assembly language instructions.");
      while (pos < length) {
          let ch = input.charAt(pos);
          if ((isLetter(ch) || ch == '_') && readLabelDefinition()) {
             skip();
             continue;
          }
          if (ch == 'B' || ch == 'b')
             addData(readLabelOrBinary(false));
          else if (isLetter(ch) || ch == '_')
             addData(readInstruction(true));
          else if (isDigit(ch)) { // number or rep count
             let n = 0;
             while (pos < length && n < 100000 && isDigit(input.charAt(pos))) {
                ch = input.charAt(pos);
                n = 10*n + ((ch == '0')? 0 : ch.charCodeAt(0)-48);
                pos++;
             }
             skipSpaces();
             if (pos < length && input.charAt(pos) == '#') {
                pos++;
                readRepeatedValue(n);
             }
             else if (n > 65535)
                doError("Integer larger than maximum permitted value of 65535.");
             else
                addData(n);
          }
          else if (ch == '+' || ch == '-')
             addData(readInt(false));
          else if (ch == '$')
             addData(readHex(false));
          else if (ch == "'")
             addData(readAscii(false));
          else if (ch == '\"')
             readString();
          else if (ch == '@') {
             readDataCt();
             skip();
             continue;
          }
          else
             doError("Unexpected Character ('" + ch + "') found in program.");
          skipSpaces();
          if (pos < length && input.charAt(pos) != ';' && input.charAt(pos) != '\r' &&
                     input.charAt(pos) != '\n')
             doError("Extra stuff found on line after data item. Only one item is allowed per line.");
          skip();
      }
      for (let i = 0; i < labelNames.length; i++) {
         let info = labelNames[i];
         if (info.numericalValue < 0)
            doError("The label \"" + info.name + "\", which was used in the program, is undefined.");
      }
      for (let i = 0; i < 1024; i++)
         if (unfinishedLabelData[i] >= 0)
            data[i] |= labelNames[unfinishedLabelData[i]].numericalValue;
      return data;
   
   
   function parseOneInstruction() {
      skip();
      if (pos == length)
         doError("No Data.");
      var n = 0;
      if (input.charAt(pos) == 'b' || input.charAt(pos) == 'B')
         n = readBinary(false);
      else if (input.charAt(pos) == '$')
         n = readHex(false);
      else if (isDigit(input.charAt(pos)) || input.charAt(pos) == '-' || input.charAt(pos) == '+')
         n = readInt(false);
      else if (input.charAt(pos) == "'")
         n = readAscii(false);
      else if (isLetter(input.charAt(pos)))
         n = readInstruction(false);
      else
         doError("Can't recognize data format.");
      skip();
      if (pos != length)
         doError("Extra input after legal data value.");
      return n;
   }
   
   function doError(message){
      throw new ParseError(message,pos);
   }
   
   function skipSpaces() {
      while (pos < length && (input.charAt(pos) == ' ' || input.charAt(pos) == '\t'))
         pos++;
   }

   function skip() {
      while (pos < length && (input.charAt(pos) == ' ' ||
              input.charAt(pos) == '\r' || input.charAt(pos) == '\n' ||
              input.charAt(pos) == '\t' || input.charAt(pos) == ';')) {
         if (input.charAt(pos) == ';') 
            do {
               pos++;
            } while (pos < length && input.charAt(pos) != '\r' && input.charAt(pos) != '\n');
         else
            pos++;
      }
   }
   
   function readWord() {  // assumes next char is a letter or underscore
      buffer = "";
      while (pos < length && (isLetter(input.charAt(pos)) || isDigit(input.charAt(pos)) || input.charAt(pos) == '_')) {
         buffer += input.charAt(pos);
         pos++;
      }
      return buffer.toUpperCase();
   }
   
   function readHex(TenBit) {   // assumes next char is a $
      pos++;
      let n = 0;
      let found = false;
      while (pos < length && n < 100000 &&
                (isDigit(input.charAt(pos)) ||
                    (input.charAt(pos) >= 'a' && input.charAt(pos) <= 'f') ||
                         (input.charAt(pos) >= 'A' && input.charAt(pos) <= 'F'))) {
         let ch = input.charAt(pos);
         if (isDigit(ch))
            n = 16*n + ((ch == '0')? 0 : ch.charCodeAt(0)-48);
         else if (ch >= 'a' && ch <= 'f')
            n = 16*n + ch.charCodeAt(0)-87;
         else
            n = 16*n + ch.charCodeAt(0)-55;
         pos++;
         found = true;
      }
      if (!found)
         doError("Illegal hexadecimal number; no digits found after '$'.");
      if (TenBit) {
         if (n > 1023)
            doError("Hexadecimal number larger than maximum legal value of $3FF used as instruction data.");
      }
      else {
         if (n > 0xFFFF)
            doError("Hexadecimal number larger than maximum permitted value of $FFFF.");
      }
      return n;
   }
   
   function readInt(TenBit) {   // assumes next char is a digit or '-' or '+'
      let neg = false;
      if (input.charAt(pos) == '+' || input.charAt(pos) == '-') {
         neg = (input.charAt(pos) == '-');
         if (neg && TenBit)
            doError("Negative numbers not allowed as data for instructions; value must be between 0 ans 1023.");
         pos++;
         if (pos == length || !isDigit(input.charAt(pos)))
            doError("Illegal number; no digits found after '" + input.charAt(pos-1) + "'.");
      }
      let n = 0;
      while (pos < length && n < 100000 && isDigit(input.charAt(pos))) {
         n = 10*n + ((input.charAt(pos) == '0')? 0 : input.charAt(pos).charCodeAt(0)-48);
         pos++;
      }
      if (neg)
         n = -n;
      if (TenBit) {
         if (n >1023)
            doError("Integer larger than maximum legal value of 1023 used as instruction data.");
      }
      else {
         if (n > 65535)
            doError("Integer larger than maximum permitted value of 65535.");
         if (n < -32768)
            doError("Integer less than the mimimum permitted value of -32768.");
      }
      return n;
   }
   
   function readBinary(TenBit) {  // assumes next char is a 'b' or 'B'
      pos++;
      let n = 0;
      let found = false;
      while (pos < length && (input.charAt(pos) == '0' || input.charAt(pos) == '1')) {
         n = 2*n + ((input.charAt(pos) == '0')? 0 : 1);
         pos++;
         found = true;
      }
      if (!found)
         doError("No digits provided in binary number.");
      if (TenBit) {
         if (n >1023)
            doError("Binary number with value larger than 1023 used as instruction data.");
      }
      else {
         if (n > 65535)
            doError("Binary number with value larger than maximum permitted value of 65535.");
      }
      return n;
   }
   
   function readAscii(TenBit) { // assumes next char is a '
      pos++;
      if (pos == length || input.charAt(pos) == '\n' || input.charAt(pos) == '\r')
         doError("Illegal ASCII value; no characters found on line after the \"'\".");
      let n = input.charAt(pos++).charCodeAt(0);
      if (n < 32 || n > 127)
         doError("Illegal ASCII value; only printable ASCII characters are allowed.");
      if (TenBit)
         return n;
      if (pos < length && input.charAt(pos) != '\n' && input.charAt(pos) != '\r') {
         let m = input.charAt(pos++).charCodeAt(0);
         if (m < 32 || m > 127)
            doError("Illegal ASCII value; only printable ASCII characters are allowed.");
         n = 256*n + m;
      }
      return n;
   }
   
   function readLabelOrBinary(TenBit) {  // assumes next char is a letter or underscore
     let data = 0;
     let savePos = pos;
     let label = readWord();
     let binary = true;
     if (label.charAt(0) != 'b' && label.charAt(0) != 'B')
        binary = false;
     else if (label.length == 1)
        binary = false;
     else {
        for (let j = 1; j < label.length; j++)
           if (label.charAt(j) != '0' && label.charAt(j) != '1') {
              binary = false;
              break;
           }
     }
     if (binary) {
        pos = savePos;
        data = readBinary(TenBit);
     }
     else if (label == "DATA") {
        if (TenBit)
           doError("The word \"DATA\" has a special meaning.  It cannot be used as a label.");
        else 
           return getValueForData();
     }
     else {
        let infoLoc = findLabel(label);
        if (infoLoc == -1) {
           let info = {};
           info.name = label;
           info.numericalValue = -1;
           labelNames.push(info);
           if (dataCt <= 1023)
              unfinishedLabelData[dataCt] = labelNames.length - 1;
        }
        else {
           if (labelNames[infoLoc].numericalValue >= 0)
              data = labelNames[infoLoc].numericalValue;
           else if (dataCt < 1024)
              unfinishedLabelData[dataCt] = infoLoc;
        }
     }
     return data;  // this is zero if it's an undefined label
   }
   
   function readInstruction(doingProgram) {  // assumes next char is a letter
      let ins = readWord();
      let insNum = -1;
      if (ins.length == 3) {
         for (let i = 0; i < 16; i++)
            if (ins == Globals.InstructionName[i]) {
               insNum = i;
               break;
            }
      }
      else if (ins == "OR")
         insNum = Globals._or;
      if (insNum == -1) {        
         if (!doingProgram)
            doError("Unknown Instruction, \"" + ins + "\".");
         else {
            if (ins == "DATA")
               return getValueForData();
            skipSpaces();
            if (pos < length && input.charAt(pos) != ';' &&
                        input.charAt(pos) != '\n' && input.charAt(pos) != '\r')
                doError("Extra stuff found on line.  (Possibly due to an unrecognized instruction name or a missing ':' after a label name.)");
            let loc = findLabel(ins);
            if (loc == -1) {
               let info = {};
               info.name = ins;
               info.numericalValue = -1;
               labelNames.push(info);
               if (dataCt < 1024)
                   unfinishedLabelData[dataCt] = labelNames.length - 1;
               return 0;
            }
            else {
               if (labelNames[loc].numericalValue == -1) {
                  if (dataCt < 1024)
                     unfinishedLabelData[dataCt] = loc;
                  return 0;
               }
               else
                  return labelNames[loc].numericalValue;
            }
         }
      }
      let requiresData = Globals.hasData.get(insNum);
      let n = insNum << 10;
      if (pos < length && input.charAt(pos) == '-') {
         pos++;
         if (pos == length)
            doError("Missing mode specification for \"" + ins + "-\".");
         let mode = input.charAt(pos);
         if (mode == '?') {
            if (!doingProgram)
               doError("Illegal Mode.");
            n |= 0xC000;
         }
         else if (mode == 'c' || mode == 'C') {
            if (!doingProgram && !Globals.hasConstantMode.get(insNum))
               doError("Illegal Mode.");
            n |= 0x4000;
         }
         else if (mode == 'i' || mode == 'I') {
            if (!doingProgram && !Globals.hasIndirectMode.get(insNum))
               doError("Illegal Mode.");
            n |= 0x8000;
         }
         else
            doError("Illegal mode specification for \"" + ins + "-\".  The mode must be C, I, or ?.");
         pos++;
      }
      skipSpaces();
      let data = 0;
      if (pos == length && requiresData)
         doError("Missing data for instruction (\"" + ins + "\") that requires data.");
      if (pos == length)
         data = 0;
      else if (doingProgram && (isLetter(input.charAt(pos)) || input.charAt(pos) == '_'))
         data = readLabelOrBinary(true);
      else if (input.charAt(pos) == '$')
         data = readHex(true);
      else if (input.charAt(pos) == "'")
         data = readAscii(true);
      else if (input.charAt(pos) == 'b' || input.charAt(pos) == 'B')
         data = readBinary(true);
      else if (input.charAt(pos) == '+' || isDigit(input.charAt(pos)))
         data = readInt(true);
      else if (requiresData)
         doError("Missing data for instruction (\"" + ins + "\") that requires data.");
      skipSpaces();
      if (pos < length && input.charAt(pos) != ';' &&
                input.charAt(pos) != '\r' && input.charAt(pos) != '\n')
          doError("Extra stuff found on line after a legal instruction.");
      return (n | data);
   }
   
   function findLabel(name) {
      for (let i = 0; i < labelNames.length; i++)
         if ( labelNames[i].name == name )
            return i;
      return -1;
   }
   
   function getValueForData() {
      skipSpaces();
      if (pos == length)
         return 0;
      else if ((isDigit(input.charAt(pos)) ||
                         input.charAt(pos) == '-' || input.charAt(pos) == '+'))
          return readInt(false);
      else if (input.charAt(pos) == '$')
          return readHex(false);
      else if (input.charAt(pos) == "'")
          return readAscii(false);
      else if (input.charAt(pos) == 'b' || input.charAt(pos) == 'B')
          return readBinary(false);
      else
          return 0;
   }

   function readLabelDefinition() {
     let savePos = pos;
     let name = readWord();
     skipSpaces();
     if (pos < length && input.charAt(pos) == ':') {
        if (name == "DATA")
           doError("The word \"DATA\" has a special meaning and cannot be redefined as a label.");
        pos++;
        let i = findLabel(name);
        if (i >= 0) {
           if (labelNames[i].numericalValue < 0)
              labelNames[i].numericalValue = dataCt;
           else
             doError("A second definition was found for a label, \"" + name + "\", which was already defined earlier in the program");
        }
        else {
           let binary = true;
           if (name.charAt(0) != 'B' && name.charAt(0) != 'b')
              binary = false;
           else if (name.length == 1)
              binary = false;
           else {
              for (let j = 1; j < name.length; j++)
                 if (name.charAt(j) != '0' && name.charAt(j) != '1') {
                    binary = false;
                    break;
                 }
           }
           if (binary)
              doError("The binary number \"" + name + "\" cannot be used as a label.");
           let info = {};
           info.name = name;
           info.numericalValue = dataCt;
           labelNames.push(info);
        }
        return true;
     }
     else {
        pos = savePos;
        return false;
     }
   }
   
   function readString() {
      pos++;
      while (true) {
        if (pos < length && input.charAt(pos) == '"') {
           pos++;
           if (pos < length && input.charAt(pos) == '"') {
              addData('"'.charCodeAt(0));
              pos++;
           }
           else
              return;
        }
        if (pos == length || input.charAt(pos) == '\n' || input.charAt(pos) == '\r')
           doError("Line ended inside a string.  (Strings cannot extend past and end-of-line.)");
        let n = input.charAt(pos).charCodeAt(0);
        if (n < 32 || n > 127)
           doError("Only printable ASCII characters are allowed in strings.");
        addData(n);
        pos++;
     }
   }
   
   function readDataCt() {
     pos++;
     skipSpaces();
     if (pos == length || !isDigit(input.charAt(pos)))
        doError("Missing location number for '@' directive.");
     let n = 0;
     while (pos < length && n < 10000 && isDigit(input.charAt(pos))) {
        n = 10*n + ((input.charAt(pos) == '0')? 0 : input.charAt(pos).charCodeAt(0)-48);
        pos++;
     }
     if (n > 1023)
        doError("Illegal value in '@' directive; value must be between 0 and 1023.");
     dataCt = n;
   }
   
   function readRepeatedValue(repCount) {
      if (repCount > 1024 || repCount <= 0)
         doError("Illegal repetition count, " + repCount + ".");
      let saveDataCt = dataCt;
      let data  = 0;
      skip();
      let ch = input.charAt(pos);
      if (ch == 'B' || ch == 'b') {
         data = readLabelOrBinary(false);
         skipSpaces();
         if (pos < length && input.charAt(pos) == ':')
            doError("It is not legal to have a labeled value after a repetition count.");
      }
      else if (isLetter(ch) || ch == '_')
         data = readInstruction(true);
      else if (isDigit(ch) || ch == '+' || ch == '-') {
         data = readInt(false);
         skipSpaces();
         if (pos < length && input.charAt(pos) == '#')
            doError("It is not legal to have two repetition directives in a row, without a value between them.");
      }
      else if (ch == '$')
         data = readHex(false);
      else if (ch == "'")
         data = readAscii(false);
      else
         doError("Unexpected character ('" + ch + "') found after '#' while looking for the value for a repitition directive.");
      for (let i = 0; i < repCount; i++)
         addData(data);
      if (unfinishedLabelData[saveDataCt] != 0xFFFF)
         for (let i = 1; i < repCount; i++)
            unfinishedLabelData[saveDataCt+i] = unfinishedLabelData[saveDataCt];
   }
   
   function isDigit(ch) {
      return ch >= '0' && ch <= '9';
   }
   
   function isLetter(ch) { 
       return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
   }
   
   function addData(val) {
      if (dataCt >= 1024)
         doError("Attempt to store into non-existant memory location (location no. " + dataCt + ")");
      data[dataCt] = val;
      dataCt++;
   }
      
}  // end Parse()


function Converter(d) {
   this.data = new Uint16Array(1); // one 16-bit integer
   if (d)
      this.data[0] = d;
}
Converter.prototype.set = function(d) {
      this.data[0] = d;
};
Converter.prototype.getSigned = function() {
   if ((this.data[0] & 0x8000) == 0)
      return this.data[0];
   else
      return this.data[0] - 0x10000;
};
Converter.prototype.getUnsigned = function() {
   return this.data[0];
};
Converter.prototype.getAscii = function() {
   var ch1 = (this.data[0] >> 8) & 0xFF;
   var ch2 = (this.data[0] & 0xFF);
   var s1,s2;
   if (ch1 <= 32 || ch1 > 127)
      s1 = "<#" + ch1 + ">";
   else
      s1 = String.fromCharCode(ch1);
   if (ch2 <= 32 || ch2 > 127)
      s2 = "<#" + ch2 + ">";
   else
      s2 = String.fromCharCode(ch2);
   return s1 + s2;
};
Converter.prototype.getMode = function() {
   return (this.data[0] >> 14) & 0x3;
};
Converter.prototype.getData = function() {
   return this.data[0] & 0x3FF;
};
Converter.prototype.getInstruction = function() {
   return (this.data[0] >> 10) & 15;
};
Converter.prototype.getAssembly = function() {
   var i = this.getInstruction();
   var d;
   switch (this.getMode()) {
      case Globals.direct:
         d = this.getData();
         if (d != 0 || Globals.hasData.get(i))
            return Globals.InstructionName[i] + " " + d;
         else
            return Globals.InstructionName[i];
      case Globals.indirect:
         return Globals.InstructionName[i] + "-I " + this.getData();
      case Globals.constant:
         return Globals.InstructionName[i] + "-C " + this.getData();
      case Globals.illegal:
         return Globals.InstructionName[i] + "-? " + this.getData();
      default:
         return null;
   }
};


function BitSet() {
   this.data = new Uint32Array(1);
}
BitSet.prototype.get = function(index) {
   return (this.data[0] >> index) & 0x1;
};
BitSet.prototype.set = function(index) {
   this.data[0] = this.data[0] | 0x1 << index;
};
BitSet.prototype.unset = function(index) {
   this.data[0] = this.data[0] & ~(0x1 << index);
};
BitSet.none = new BitSet();
BitSet.setCountToZero = new BitSet();
BitSet.setCountToZero.set(24);


const Globals = {

   _x : 0, _y : 1, _flag : 2, _ac : 3,          // registers
   _count : 4, _ir : 5, _pc : 6, _addr : 7,

   _add : 0, _sub : 1, _and : 2, _or : 3,      // instructions
   _not : 4, _shl : 5, _shr : 6, _inc : 7,
   _dec : 8, _lod : 9, _sto : 10, _hlt : 11,
   _jmp : 12, _jmz : 13, _jmn : 14, _jmf : 15,
                 
   select_add : 0, select_subtract : 1, select_and : 2,    // control wires
   select_or : 3, select_not : 4, select_shift_left : 5, select_shift_right : 6,
   load_data_into_memory : 7, load_x_from_ac : 8, load_y_from_memory : 9, load_y_from_ir : 10,
   load_ac_from_alu : 11, load_ac_from_memory : 12, load_ac_from_ir : 13, increment_ac : 14,
   decrement_ac : 15, load_flag_from_alu : 16, load_pc_from_memory : 17, load_pc_from_ir : 18,
   increment_pc : 19, load_ir_from_memory : 20, load_addr_from_ir : 21, load_addr_from_y : 22,
   load_addr_from_pc : 23, set_count_to_zero : 24, stop_clock : 25,

   direct : 0, constant : 1, indirect : 2, illegal : 3,   // address modes
   

   InstructionName : [  "ADD", "SUB", "AND", "OR",
                        "NOT", "SHL", "SHR", "INC",
                        "DEC", "LOD", "STO", "HLT",
                        "JMP", "JMZ", "JMN", "JMF" ],



   WireName : [
      "Select-Add", "Select-Subtract", "Select-AND",
      "Select-OR", "Select-NOT", "Select-Shift-Left", "Select-Shift-Right",
      "Load-Data-Into-Memory", "Load-X-From-AC", "Load-Y-From-Memory", "Load-Y-From-IR",
      "Load-AC-From-ALU", "Load-AC-From-Memory", "Load-AC-From-IR", "Increment-AC",
      "Decrement-AC", "Load-Flag-From-ALU", "Load-PC-From-Memory", "Load-PC-From-IR",
      "Increment-PC", "Load-IR-From-Memory", "Load-ADDR-From-IR", "Load-ADDR-From-Y",
      "Load-ADDR-From-PC", "Set-COUNT-To-Zero", "Stop-Clock" ],
      
   hasConstantMode: null, hasIndirectMode: null, hasData: null, step: null
};
     
{ // initialize Globals
   Globals.hasConstantMode = new BitSet();
   Globals.hasConstantMode.set(Globals._add);
   Globals.hasConstantMode.set(Globals._sub);
   Globals.hasConstantMode.set(Globals._and);
   Globals.hasConstantMode.set(Globals._or);
   Globals.hasConstantMode.set(Globals._lod);
   
   Globals.hasIndirectMode = new BitSet();
   Globals.hasIndirectMode.set(Globals._add);
   Globals.hasIndirectMode.set(Globals._sub);
   Globals.hasIndirectMode.set(Globals._and);
   Globals.hasIndirectMode.set(Globals._or);
   Globals.hasIndirectMode.set(Globals._lod);
   Globals.hasIndirectMode.set(Globals._sto);
   Globals.hasIndirectMode.set(Globals._jmp);
   Globals.hasIndirectMode.set(Globals._jmz);
   Globals.hasIndirectMode.set(Globals._jmn);
   Globals.hasIndirectMode.set(Globals._jmf);
   
   Globals.hasData = Globals.hasIndirectMode;
   
   Globals.step = new Array(16);
   for (let i = 0; i < 16; i++) {
      Globals.step[i] = new Array(4);
      for (let j = 0; j < 4; j++) {
         Globals.step[i][j] = new Array(11);
      }
   }
   let b0 = new BitSet();
   let b1 = new BitSet();
   b1.set(Globals.load_addr_from_pc);
   let b2 = new BitSet();
   b2.set(Globals.load_ir_from_memory);
   let b3 = new BitSet();
   b3.set(Globals.increment_pc);
   for (let i = Globals._add; i <= Globals._jmp; i++)
     for (let j = 0; j < 4; j++) {
        Globals.step[i][j][0] = b0;
        Globals.step[i][j][1] = b1;
        Globals.step[i][j][2] = b2;
        Globals.step[i][j][3] = b3; 
     }
   for (let i = Globals._add; i <= Globals._jmp; i++)
     for (let j = 0; j < 4; j++)
       for (let k = 4; k < 11; k++)
           Globals.step[i][j][k] = new BitSet();
  Globals.step[Globals._add][Globals.direct][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._add][Globals.direct][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._add][Globals.direct][5].set(Globals.load_x_from_ac);
  Globals.step[Globals._add][Globals.direct][6].set(Globals.select_add);
  Globals.step[Globals._add][Globals.direct][6].set(Globals.load_ac_from_alu);
  Globals.step[Globals._add][Globals.direct][6].set(Globals.load_flag_from_alu);
  Globals.step[Globals._add][Globals.direct][7].set(Globals.select_add);
  Globals.step[Globals._add][Globals.constant][4].set(Globals.load_y_from_ir);
  Globals.step[Globals._add][Globals.constant][4].set(Globals.load_x_from_ac);
  Globals.step[Globals._add][Globals.constant][5].set(Globals.select_add);
  Globals.step[Globals._add][Globals.constant][5].set(Globals.load_ac_from_alu);
  Globals.step[Globals._add][Globals.constant][5].set(Globals.load_flag_from_alu);
  Globals.step[Globals._add][Globals.constant][6].set(Globals.select_add);
  Globals.step[Globals._add][Globals.indirect][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._add][Globals.indirect][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._add][Globals.indirect][6].set(Globals.load_addr_from_y);
  Globals.step[Globals._add][Globals.indirect][7].set(Globals.load_y_from_memory);
  Globals.step[Globals._add][Globals.indirect][7].set(Globals.load_x_from_ac);
  Globals.step[Globals._add][Globals.indirect][8].set(Globals.select_add);
  Globals.step[Globals._add][Globals.indirect][8].set(Globals.load_ac_from_alu);
  Globals.step[Globals._add][Globals.indirect][8].set(Globals.load_flag_from_alu);
  Globals.step[Globals._add][Globals.indirect][9].set(Globals.select_add);

  Globals.step[Globals._sub][Globals.direct][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._sub][Globals.direct][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._sub][Globals.direct][5].set(Globals.load_x_from_ac);
  Globals.step[Globals._sub][Globals.direct][6].set(Globals.select_subtract);
  Globals.step[Globals._sub][Globals.direct][6].set(Globals.load_ac_from_alu);
  Globals.step[Globals._sub][Globals.direct][6].set(Globals.load_flag_from_alu);
  Globals.step[Globals._sub][Globals.direct][7].set(Globals.select_subtract);
  Globals.step[Globals._sub][Globals.constant][4].set(Globals.load_y_from_ir);
  Globals.step[Globals._sub][Globals.constant][4].set(Globals.load_x_from_ac);
  Globals.step[Globals._sub][Globals.constant][5].set(Globals.select_subtract);
  Globals.step[Globals._sub][Globals.constant][5].set(Globals.load_ac_from_alu);
  Globals.step[Globals._sub][Globals.constant][5].set(Globals.load_flag_from_alu);
  Globals.step[Globals._sub][Globals.constant][6].set(Globals.select_subtract);
  Globals.step[Globals._sub][Globals.indirect][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._sub][Globals.indirect][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._sub][Globals.indirect][6].set(Globals.load_addr_from_y);
  Globals.step[Globals._sub][Globals.indirect][7].set(Globals.load_y_from_memory);
  Globals.step[Globals._sub][Globals.indirect][7].set(Globals.load_x_from_ac);
  Globals.step[Globals._sub][Globals.indirect][8].set(Globals.select_subtract);
  Globals.step[Globals._sub][Globals.indirect][8].set(Globals.load_ac_from_alu);
  Globals.step[Globals._sub][Globals.indirect][8].set(Globals.load_flag_from_alu);
  Globals.step[Globals._sub][Globals.indirect][9].set(Globals.select_subtract);

  Globals.step[Globals._and][Globals.direct][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._and][Globals.direct][5].set(Globals.load_x_from_ac);
  Globals.step[Globals._and][Globals.direct][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._and][Globals.direct][6].set(Globals.select_and);
  Globals.step[Globals._and][Globals.direct][6].set(Globals.load_ac_from_alu);
  Globals.step[Globals._and][Globals.direct][7].set(Globals.select_and);
  Globals.step[Globals._and][Globals.constant][4].set(Globals.load_y_from_ir);
  Globals.step[Globals._and][Globals.constant][4].set(Globals.load_x_from_ac);
  Globals.step[Globals._and][Globals.constant][5].set(Globals.load_ac_from_alu);
  Globals.step[Globals._and][Globals.constant][5].set(Globals.select_and);
  Globals.step[Globals._and][Globals.constant][6].set(Globals.select_and);
  Globals.step[Globals._and][Globals.indirect][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._and][Globals.indirect][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._and][Globals.indirect][6].set(Globals.load_addr_from_y);
  Globals.step[Globals._and][Globals.indirect][7].set(Globals.load_x_from_ac);
  Globals.step[Globals._and][Globals.indirect][7].set(Globals.load_y_from_memory);
  Globals.step[Globals._and][Globals.indirect][8].set(Globals.load_ac_from_alu);
  Globals.step[Globals._and][Globals.indirect][8].set(Globals.select_and);
  Globals.step[Globals._and][Globals.indirect][9].set(Globals.select_and);

  Globals.step[Globals._or][Globals.direct][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._or][Globals.direct][5].set(Globals.load_x_from_ac);
  Globals.step[Globals._or][Globals.direct][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._or][Globals.direct][6].set(Globals.load_ac_from_alu);
  Globals.step[Globals._or][Globals.direct][6].set(Globals.select_or);
  Globals.step[Globals._or][Globals.direct][7].set(Globals.select_or);
  Globals.step[Globals._or][Globals.constant][4].set(Globals.load_x_from_ac);
  Globals.step[Globals._or][Globals.constant][4].set(Globals.load_y_from_ir);
  Globals.step[Globals._or][Globals.constant][5].set(Globals.select_or);
  Globals.step[Globals._or][Globals.constant][5].set(Globals.load_ac_from_alu);
  Globals.step[Globals._or][Globals.constant][6].set(Globals.select_or);
  Globals.step[Globals._or][Globals.indirect][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._or][Globals.indirect][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._or][Globals.indirect][6].set(Globals.load_addr_from_y);
  Globals.step[Globals._or][Globals.indirect][7].set(Globals.load_y_from_memory);
  Globals.step[Globals._or][Globals.indirect][7].set(Globals.load_x_from_ac);
  Globals.step[Globals._or][Globals.indirect][8].set(Globals.load_ac_from_alu);
  Globals.step[Globals._or][Globals.indirect][8].set(Globals.select_or);
  Globals.step[Globals._or][Globals.indirect][9].set(Globals.select_or);

  Globals.step[Globals._shl][Globals.direct][4].set(Globals.load_x_from_ac);
  Globals.step[Globals._shl][Globals.direct][5].set(Globals.select_shift_left);
  Globals.step[Globals._shl][Globals.direct][5].set(Globals.load_ac_from_alu);
  Globals.step[Globals._shl][Globals.direct][5].set(Globals.load_flag_from_alu);
  Globals.step[Globals._shl][Globals.direct][6].set(Globals.select_shift_left);

  Globals.step[Globals._shr][Globals.direct][4].set(Globals.load_x_from_ac);
  Globals.step[Globals._shr][Globals.direct][5].set(Globals.select_shift_right);
  Globals.step[Globals._shr][Globals.direct][5].set(Globals.load_ac_from_alu);
  Globals.step[Globals._shr][Globals.direct][5].set(Globals.load_flag_from_alu);
  Globals.step[Globals._shr][Globals.direct][6].set(Globals.select_shift_right);

  Globals.step[Globals._not][Globals.direct][4].set(Globals.load_x_from_ac);
  Globals.step[Globals._not][Globals.direct][5].set(Globals.load_ac_from_alu);
  Globals.step[Globals._not][Globals.direct][5].set(Globals.load_ac_from_alu);
  Globals.step[Globals._not][Globals.direct][6].set(Globals.select_not);

  Globals.step[Globals._inc][Globals.direct][4].set(Globals.increment_ac);

  Globals.step[Globals._dec][Globals.direct][4].set(Globals.decrement_ac);

  Globals.step[Globals._lod][Globals.direct][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._lod][Globals.direct][5].set(Globals.load_ac_from_memory);
  Globals.step[Globals._lod][Globals.constant][4].set(Globals.load_ac_from_ir);
  Globals.step[Globals._lod][Globals.indirect][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._lod][Globals.indirect][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._lod][Globals.indirect][6].set(Globals.load_addr_from_y);
  Globals.step[Globals._lod][Globals.indirect][7].set(Globals.load_ac_from_memory);

  Globals.step[Globals._sto][Globals.direct][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._sto][Globals.direct][5].set(Globals.load_data_into_memory);
  Globals.step[Globals._sto][Globals.indirect][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._sto][Globals.indirect][5].set(Globals.load_y_from_memory);
  Globals.step[Globals._sto][Globals.indirect][6].set(Globals.load_addr_from_y);
  Globals.step[Globals._sto][Globals.indirect][7].set(Globals.load_data_into_memory);

  Globals.step[Globals._hlt][Globals.direct][4].set(Globals.stop_clock);

  Globals.step[Globals._jmp][Globals.direct][4].set(Globals.load_pc_from_ir);
  Globals.step[Globals._jmp][Globals.indirect][4].set(Globals.load_addr_from_ir);
  Globals.step[Globals._jmp][Globals.indirect][5].set(Globals.load_pc_from_memory);
  
   for (let i = Globals._add; i <= Globals._jmp; i++)
     for (let j = 0; j < 4; j++)
       for (let k = 4; k < 11; k++)
           if (Globals.step[i][j][k].data == 0)
               Globals.step[i][j][k].set(Globals.set_count_to_zero);


  Globals.step[Globals._jmz] = Globals.step[Globals._jmp];
  Globals.step[Globals._jmn] = Globals.step[Globals._jmp];
  Globals.step[Globals._jmf] = Globals.step[Globals._jmp];

}  // end initialize Globals


function Register(name, bits, defaultDisplayStyle) {
   this.convert = new Converter();
   this.textfield = document.getElementById(name + "_input");
   this.label = document.getElementById(name + "_label");
   this.name = name + ": ";
   this.bits = bits;
   this.displayStyle = this.defaultDisplayStyle = defaultDisplayStyle;
   this.set(0);
   if (bits == 16)
      this.mask = 0xFFFF;
   else {
      let m = 0;
      for (let i = 0; i < bits; i++)
         m = (m << 1) | 1;
      this.mask = m;
   }
}
Register.defaultView = 1;
Register.integerView = 2;
Register.unsignedView = 3;
Register.binaryView = 4;
Register.assemblyView = 5;
Register.makeRegisters = function() {
   let registers = new Array(8);
   registers[Globals._x] = new Register("X",16,Register.integerView);
   registers[Globals._y] = new Register("Y",16,Register.integerView);
   registers[Globals._flag] = new Register("FLAG",1,Register.integerView);
   registers[Globals._ac] = new Register("AC",16,Register.integerView);
   registers[Globals._count] = new Register("COUNT",4,Register.integerView);
   registers[Globals._ir] = new Register("IR",16,Register.assemblyView);
   registers[Globals._pc] = new Register("PC",10,Register.integerView);
   registers[Globals._addr] = new Register("ADDR",10,Register.integerView);
   return registers;
};
Register.sync = function(wiresToHilite) {
   if (!wiresToHilite) {
      let step = registers[Globals._count].value;
      globalConverter.set(registers[Globals._ir].value);
      let mode = globalConverter.getMode();
      let ins = globalConverter.getInstruction();
      wiresToHilite = Globals.step[ins][mode][step];
   }
   wireset = wiresToHilite;
   if (!dimmed) {
      memory.select( registers[Globals._addr].value );
      hiliteWires(wireset);
   }
};
Register.clearHilite = function() {
   for (let i = 0; i < registers.length; i++)
      registers[i].textfield.style.backgroundColor = "white";
}
Register.prototype.get = function() {
   return this.value;
};
Register.prototype.set = function(val) {
   this.value = val & this.mask;
   this.valString = this.makeValString();
   if (!dimmed) {
      this.textfield.value = this.valString;
      if (this.bits != 4) // not the count register
         this.textfield.style.backgroundColor = "#FFFF99";
   }
};
Register.prototype.setDisplayStyle = function(style) {
   if (style == Register.defaultView)
      style = this.defaultDisplayStyle;
   if (style == this.displayStyle)
      return;
   this.displayStyle = style;
   this.valString = this.makeValString();
   if (!dimmed) {
      this.textfield.value = this.valString;
   }
};
Register.prototype.makeValString = function() {
   switch (this.displayStyle) {
      case Register.integerView:
         return "" + this.get();
      case Register.unsignedView:
         this.convert.set(this.get());
         return "" + this.convert.getUnsigned();
      case Register.binaryView:
         let val = this.get();
         let binary = "";
         for (let i = 1 << (this.bits-1); i > 0; i >>>= 1) {
            binary += ((val & i) == 0)? '0' : '1';
         }
         return binary;
      case Register.assemblyView:
         this.convert.set(this.get());
         return this.convert.getAssembly();
      default:
         return null;
   }
};


function Memory(container) {
   this.values = new Uint16Array(1024);
   this.display = new Array(1024);
   this.converter = new Converter();
   this.selected = -1;
   for (let i = 0; i < 1024; i++) {
       let s = i + ": ";
       while (s.length < 6)
          s = " " + s;
       s = "<span class='loc'>" + s + "</span>";
       let par = document.createElement("p");
       par.className = "mem";
       par.innerHTML = s;
       container.appendChild(par);
       this.display[i] = document.createElement("span");
       this.display[i].innerHTML = "<span id='m" + i + "'>0               </span>";
       par.appendChild(this.display[i]);
   }
}
Memory.prototype.clear = function() {
   let val = this.makeValueString(0);
   for (let i = 0; i < 1024; i++) {
      this.display[i].innerHTML = val;
      this.values[i] = 0;
   }
   g.fillStyle = "white";
   g.fillRect(0,0,graphicsCanvas.width,graphicsCanvas.height);
};
Memory.prototype.get = function(index) {
   return this.values[index];
};
Memory.prototype.set = function(index,value) {
   this.values[index] = value;
   this.display[index].innerHTML = this.makeValueString(value);
   this.setGraphics(index,value);
};
Memory.prototype.setGraphics = function(index) {
   let row = 2*Math.floor(index/4);
   let col = 32*(index % 4);
   g.fillStyle = "white";
   g.fillRect(col,row,32,2);
   g.fillStyle = "black";
   for (let i = 1 << 15; i > 0; i >>>= 1) {
      if (this.values[index] & i)
         g.fillRect(col,row,2,2);
      col += 2;
   }
};
Memory.prototype.makeValueString = function(value) {
   this.converter.set(value);
   let s;
   switch(memDisplay) {
   case 1: //assembly
      s = this.converter.getAssembly();
      break;
   case 2: //integer
      s = "" + this.converter.getSigned();
      break;
   case 3: //unsigned
      s = "" + this.converter.getUnsigned();
      break;
   case 4: //binary
      let binary = "";
      for (let i = 1 << 15; i > 0; i >>>= 1) {
         binary += ((value & i) == 0)? '0' : '1';
      }
      return binary;
   case 5: //ascii
      s = this.converter.getAscii();
   }
   if (s.length < 16) {
      s += '                '.substring(0,16-s.length);
   }
   return s;
};
Memory.prototype.newDisplay = function() {
   let zero = this.makeValueString(0);
   for (let i = 0; i < 1024; i++) {
      if (this.get(i) === 0)
         this.display[i].innerHTML = zero;
      else
         this.display[i].innerHTML = this.makeValueString(this.get(i));
   }
};
Memory.prototype.select = function(location) {
   if (location === null)
      location = -1;
   if (location === this.selected)
      return;
   if (this.selected >= 0)
      this.display[this.selected].style.backgroundColor = "white";
   this.selected = location;
   if (this.selected >= 0) {
      this.display[this.selected].style.backgroundColor = "#FFFF99";
      if (autoscroll) {
         this.scrollToSelection();
      }
   }
};
Memory.prototype.scrollToSelection = function() {
   if (this.selected >= 0) {
      let size = document.getElementById("mem").scrollHeight;
      let offset = (size/1024)*this.selected;
      document.getElementById("memholder").scrollTop = 1+Math.round(offset);
   }
};
Memory.prototype.installProgram = function(mem) {
   let zero = this.makeValueString(0);
   for (let i = 0; i < 1024; i++) {
      if (mem[i] != this.values[i]) {
          this.values[i] = mem[i];
          if (this.values[i] == 0)
             this.display[i].innerHTML = zero;
          else
             this.display[i].innerHTML = this.makeValueString(this.values[i]);
          this.setGraphics(i);
      }
   }
};


function hiliteWires(wireSet) {
    for (let i = 0; i < 26; i++) {
       wires[i].style.backgroundColor = wireSet.get(i)? "#FFFF99" : "white";
    }
}

function doWire (wr, hilite) {
  var a, b, ans, flag;
  var loadFlag;
  switch (wr) {
    case Globals.load_data_into_memory: 
       memory.set(registers[Globals._addr].get(), registers[Globals._ac].get());
       break;
    case Globals.load_x_from_ac: 
       registerToRegister(Globals._ac, Globals._x);
       break;
    case Globals.load_y_from_memory: 
       setRegister(Globals._y, memory.get(registers[Globals._addr].get()));
       break;
    case Globals.load_y_from_ir: 
       registerToRegister(Globals._ir, Globals._y);
       break;
    case Globals.select_add:
    case Globals.select_subtract:
    case Globals.select_and:
    case Globals.select_or:
    case Globals.select_not:
    case Globals.select_shift_right:
    case Globals.select_shift_left:
	     a = registers[Globals._x].get();
	     b = registers[Globals._y].get();
	     loadFlag = false;
	     flag = 0;
	     if (Globals.select_add == wr) {
	       ans = a + b;
	       loadFlag = true;
	     }
	     else if (Globals.select_subtract == wr) {
	       ans = a - b;
	       loadFlag = true;
	     }
	     else if (Globals.select_and == wr)
	       ans = a & b;
	     else if (Globals.select_or == wr)
 	       ans = a | b;
	     else if (Globals.select_not == wr)
	       ans = ~a;
	     else if (Globals.select_shift_right == wr) {
	       flag = (a & 1);
	       ans = ((a >>> 1) & 0x7FFF);
	       loadFlag = true;
	     }
	     else if (Globals.select_shift_left == wr) {
	       loadFlag = true;
	       ans = a << 1;
	     }
	     else
	       ans = 0;
	     setRegister(Globals._ac, ans);
	     if (loadFlag)
	        if (((ans & 0x10000) != 0) || (flag != 0))
	            setRegister(Globals._flag, 1);
	        else
	            setRegister(Globals._flag, 0);
         break;
    case Globals.load_ac_from_memory: 
       setRegister(Globals._ac, memory.get(registers[Globals._addr].get()));
       break;
    case Globals.load_ac_from_ir: 
       registerToRegister(Globals._ir, Globals._ac);
       break;
    case Globals.increment_ac: 
       setRegister(Globals._ac, (registers[Globals._ac].get() + 1));
       break;
    case Globals.decrement_ac: 
       setRegister(Globals._ac, (registers[Globals._ac].get() - 1));
       break;
    case Globals.load_flag_from_alu: 
       break;
    case Globals.load_pc_from_memory: 
       setRegister(Globals._pc, memory.get(registers[Globals._addr].get()));
       break;
    case Globals.load_pc_from_ir: 
       registerToRegister(Globals._ir, Globals._pc);
       break;
    case Globals.increment_pc: 
       setRegister(Globals._pc, (registers[Globals._pc].get() + 1) );
       break;
    case Globals.load_ir_from_memory: 
       setRegister(Globals._ir, memory.get(registers[Globals._addr].get()));
       break;
    case Globals.load_addr_from_ir: 
       registerToRegister(Globals._ir, Globals._addr);
       break;
    case Globals.load_addr_from_pc: 
       registerToRegister(Globals._pc, Globals._addr);
       break;
    case Globals.load_addr_from_y: 
       registerToRegister(Globals._y, Globals._addr);
       break;
    case Globals.set_count_to_zero: 
       setRegister(Globals._count,0);
       break;
    case Globals.stop_clock: 
       computerHalted = true;
       break;
   }
   function registerToRegister(r1, r2) {
      var val;
      if (r1 == Globals._ir)
         val = (registers[Globals._ir].get() & 0x3FF);
      else
         val = registers[r1].get();
      setRegister(r2,val);
   }
   function setRegister(reg,val) {
      registers[reg].set(val);
      if (hilite) {
          registers[reg].hilite();
      }
   }
}


function setDimmed(dim) {
   if (dim == dimmed)
      return;
   dimmed = dim;
   if (dimmed) {
      memory.select(-1);
      hiliteWires(BitSet.none);
   }
   else
      Register.sync();
   for (let i = 0; i < registers.length; i++) {
      if (dimmed) {
         registers[i].label.style.color = "#6666CC";
         registers[i].textfield.value = "";
      }
      else {
         registers[i].label.style.color = "#0000CC";
         registers[i].textfield.value = registers[i].valString;
      }
   }
   for (let i = 0; i < wires.length; i++) {
      wires[i].style.color = dimmed? "#CCCCCC" : "black";
   }
}

function doRun() {
    setError(null);
    if (running) {
       stopRunning();
    }
    else {
      disableButtons();
      running = true;
      if (speed == 1)
         setDimmed(true);
      else if (speed == 2) {
         hiliteWires(BitSet.none);
         for (let i = 0; i < wires.length; i++)
            wires[i].style.color = "#CCCCCC";
         memory.select(-1);
      }
      frameRequest = requestAnimationFrame(frame);
      executionState = "animating";
      buttons[0].innerHTML = "Stop";
      buttons[0].disabled = false;
    }
}

function frame() {
   if (frameCountdown > 0) {
       frameCountdown--;
       frameRequest = requestAnimationFrame(frame);
       return;
   }
   frameRequest = null;
   let wires;
   switch (executionState) {
      case "oneStepFlashCount":
         enableButtons();
         executionState = "idle";
         registers[Globals._count].set(0);
         Register.sync();
         return;
      case "animating":
         Register.clearHilite();
         switch (speed) {
            case 1:
               for (let i = 0; i < 10; i++) {
                  doOneCycle();
                  if (wires.get(Globals.stop_clock))
                     break;
               }
               break;
            case 2:
               doOneCycle();
               Register.clearHilite();
               break;
            default:
               Register.clearHilite();
               wires = doOneStep();
               Register.sync();
               break;
         }
         if ( wires.get(Globals.set_count_to_zero) ) {
             registers[Globals._count].set(0);
         }
         if (wires.get(Globals.stop_clock)) {
            stopRunning();
            Register.sync();
            return;
         }
         switch (speed) {
            case 1:
            case 2:
               frameCountdown = 0;
               break;
            case 3:
               frameCountdown = 2;
               break;
            case 4:
               frameCountdown = 10;
               break;
            case 5:
               frameCountdown = 40;
               break;
         }
         frameRequest = requestAnimationFrame(frame);
         break;
   }
   function doOneCycle() {
      do {
         wires = doOneStep();
      } while ( !wires.get(Globals.set_count_to_zero) && !wires.get(Globals.stop_clock) );
      if (wires.get(Globals.set_count_to_zero))
         registers[Globals._count].set(0);
   }
}

function doStep() {
   setError(null);
   if (executionState != "idle")
      return;
   Register.clearHilite();
   let wires = doOneStep();
   if (wires.get(Globals.set_count_to_zero)) {
       disableButtons();
       Register.sync();
       executionState = "oneStepFlashCount";
       frameCountdown = 15;
       frameRequest = requestAnimationFrame(frame);
   }
   else 
      Register.sync(wires);
}

function doCycle() {
   setError(null);
   if (executionState != "idle")
      return;
   let wires;
   do {
       wires = doOneStep();
   }
   while ( !wires.get(Globals.set_count_to_zero) && !wires.get(Globals.stop_clock));
   if (wires.get(Globals.set_count_to_zero))
      registers[Globals._count].set(0);
   else {
      hiliteWires(wires);
      disableButtons();
      setTimeout(function() {
         if (executionState == "idle")
            enableButtons();
      }, 400);
   }
   Register.clearHilite();
   Register.sync();
}

function doSpeedChange() {
   var newSpeed = Number(document.getElementById("speed").value);
   if (newSpeed == speed)
      return;
   if (running) {
      if (speed == 1) {
         setDimmed(false);
         frameCountdown = 0;
      }
      else if (newSpeed == 1)
         setDimmed(true);
      if (speed == 2 && newSpeed > 2) {
         for (let i = 0; i < wires.length; i++)
            wires[i].style.color = "black";
         Register.sync();
      }
      else if (newSpeed == 2) {
         hiliteWires(BitSet.none);
         for (let i = 0; i < wires.length; i++)
            wires[i].style.color = "#CCCCCC";
         memory.select(-1);
      }
   }
   speed = newSpeed;
}

function doClearMem() {
    stopRunning();
    memory.clear();
}

function doZeroPC() {
   stopRunning();
   registers[Globals._pc].set(0);
   registers[Globals._count].set(0);
   Register.sync(BitSet.none);
   Register.clearHilite();
}

function doAddrToPC() {
   stopRunning();
   let addr = document.getElementById("Addr").value.trim();
   if (addr == "") {
      alert("The address input is empty!");
      return;
   }
   addr = Number(addr);
   if (isNaN(addr)) {
      alert("The address input does not contain a legal number");
      return;
   }
   if (addr < 0 || addr > 1023) {
      alert("Address input must be between 0 and 1023");
      return;
   }
   registers[Globals._pc].set(addr);
   registers[Globals._count].set(0);
   Register.sync(BitSet.none);
   Register.clearHilite();
}

function doDataToMem() {
   stopRunning();
   let data = document.getElementById("Data").value.trim();
   if (data == "") {
      alert("The data input is empty!");
      return;
   }
   try {
       data = parse(data,true);
   }
   catch (e) {
       alert("Error in data: " + e.message);
       return;
   }
   let addr = document.getElementById("Addr").value.trim();
   if (addr == "") {
      alert("The address input is empty!");
      return;
   }
   addr = Number(addr);
   if (isNaN(addr)) {
      alert("The address input does not contain a legal number");
      return;
   }
   if (addr < 0 || addr > 1023) {
      alert("Address input must be between 0 and 1023");
      return;
   }
   memory.set(addr,data);
   memory.select(addr);
}

function doLoadProgram() {
   stopRunning();
   let program = document.getElementById("program").value;
   try {
      let mem = parse(program);
      stopRunning();
      memory.installProgram(mem);
      registers[Globals._pc].set(0);
      registers[Globals._count].set(0);
      Register.sync(BitSet.none);
      Register.clearHilite();
      window.scrollTo(0,window.pageYOffset+document.getElementById("comp").getBoundingClientRect().top);
   }
   catch (e) {
      setError("Program error: " + e.message);
      document.getElementById("program").setSelectionRange(e.pos,e.pos);
      document.getElementById("program").focus();
   }
}

function doAutoscroll() {
   autoscroll = document.getElementById("autoscroll").checked;
   if (autoscroll)
      memory.scrollToSelection();
}

function doRegisterDisplayChange() {
   let d = Number(document.getElementById("regdisplay").value);
   if (d == registerDisplay)
      return;
   registerDisplay = d;
   for (let i = 0; i < registers.length; i++) {
      registers[i].setDisplayStyle(d);
   }
}

function doMemDisplayChange() {
   let d = Number(document.getElementById("memdisplay").value);
   if (d == memDisplay)
      return;
   memDisplay = d;
   memory.newDisplay();
}

function doProgramChange() {
   stopRunning();
   let currentProg = programs[programInEditor];
   currentProg.text = document.getElementById("program").value;
   document.getElementById("error").innerHTML = "&nbsp;";
   let p = document.getElementById("selectprogram").value;
   if (p == "new") {
       untitledCount++;
       let pos = programs.length;
       let prog = { name: "User Program " + untitledCount, text: "",
                    position: pos, status: "user" };
        programs.push(prog);
        document.getElementById("program").value = "";
        let option = document.createElement("option");
        option.value = "" + (pos+1);
        option.innerHTML = prog.name;
        document.getElementById("selectprogram").appendChild(option);
        document.getElementById("selectprogram").value = "" + (pos+1);
        document.getElementById("program").disabled = false;
        programInEditor = pos;
   }
   else {
       p = Number(p) - 1;
       let prog = programs[p];
       programInEditor = prog.position;
       if (prog.status == "not started") {
          startProgramLoad(prog);
       }
       else {
           document.getElementById("program").value = prog.text;
           document.getElementById("program").disabled = (prog.status == "loading");
       }
   }
}

function setError(message) {
    if (!message)
       message="&nbsp;";
    document.getElementById("error").innerHTML = message;
}


function disableButtons() {
   for (let i = 0; i < buttons.length; i++)
       buttons[i].disabled = true;
}

function enableButtons() {
   for (let i = 0; i < buttons.length; i++)
       buttons[i].disabled = false;
}

function stopRunning() { // make sure everything is in correct state
   setError(null);
   if (frameRequest !== null) {
      cancelAnimationFrame(frameRequest);
      frameRequest = null;
   }
   if (running) {
       running = false;
       document.getElementById("run").innerHTML = "Run&nbsp;";
       executionState = "idle";
       enableButtons();
       buttons[0].innerHTML = "Run";
       setDimmed(false);
   }
   setDimmed(false);
   for (let i = 0; i < wires.length; i++)
      wires[i].style.color = "black";
   Register.sync();   
}

function doOneStep() {  // returns true if cycle ends because count register needs to be set to zero
    let instruction = registers[Globals._ir].get();
    let count = registers[Globals._count].get();
    count++;
    registers[Globals._count].set(count);
    globalConverter.set(instruction);
    let cmd = globalConverter.getInstruction();
    let mode = globalConverter.getMode();
    if (cmd == Globals._jmn || cmd == Globals._jmz || cmd == Globals._jmf) {
        if (count == 4) { // conditional jump -- if no jump, set clock to zero
            let jump = false;
            if (cmd == Globals._jmf)
               jump = registers[Globals._flag].get() == 1;
            else if (cmd == Globals._jmz)
               jump = registers[Globals._ac].get() == 0;
            else
               jump = (registers[Globals._ac].get() & 0x8000) != 0;
            if (!jump) {
               return BitSet.setCountToZero;
            }
        }
    }
    let wireSet = Globals.step[cmd][mode][count];
    if (wireSet.get(Globals.set_count_to_zero))
       return BitSet.setCountToZero;
    for (let i = 0; i < 26; i++) {
        if (wireSet.get(i))
           doWire(i);
    }
    return wireSet;
}

function startProgramLoad(program) {  
   if (program.status != "not started")
      return;
   program.status = "loading";
   program.text = "Waiting for program '" + program.name + "' to load from url " + program.url;
   if (program.position == programInEditor) {
       document.getElementById("program").value = program.text;
       document.getElementById("program").disabled = true;
   }
   var ajaxTimeout;
   var ajax = new XMLHttpRequest();
   ajax.open("GET",program.url);
   ajax.overrideMimeType("text/plain");
   ajax.addEventListener("error",function() {
       clearTimeout(ajaxTimeout);
       program.text = "Error: Program could not be loaded from " + program.url;
       program.status = "error";
       doneLoad();
   });
   ajax.addEventListener("load",function() {
       clearTimeout(ajaxTimeout);
       program.text = ajax.responseText;
       program.status = "loaded";
       doneLoad();
   });
   ajaxTimeout = setTimeout(function() {
       ajax.abort();
       program.text = "Error: Request timed out while trying to load from " + program.url;
       program.status = "error";
       doneLoad();
   }, 30000);
   try {
      ajax.send();
   } catch(e) {
       clearTimeout(ajaxTimeout);
       program.status = "error";
       program.text = "Error while trying to send request for example: " + program.url;
       doneLoad();
   }
function doneLoad() {
      if (program.position == programInEditor) {
          document.getElementById("program").value = program.text;
          document.getElementById("program").disabled = false;
      }
   }
}


function showMemExport() { 
    document.getElementById("memexportbg").style.display = "block";
    document.getElementById("memexport").style.display = "block";
    document.addEventListener("keydown", memhexEscape, false);
    stopRunning();
    let str = "v2.0 raw\n";
    let i = 0;
    let zeroCt = 0;
    for (let i = 0; i < 1024; i++) {
       let val = memory.get(i);
       if (val == 0)
          zeroCt++;
       else {
          if (zeroCt > 3) {
             str += zeroCt + "*0\n";
             zeroCt = 0;
          }
          else if (zeroCt > 0) {
             for (let j = 0; j < zeroCt; j++) {
                str += "0\n";
             }
             zeroCt = 0;
          }
          let num = val.toString(16);
          str +=  num + "\n";
       }
    }
    if (zeroCt == 1024)
       document.getElementById("memhex").value = "v2.0 raw\n1024*0\n";
    else
       document.getElementById("memhex").value = str;
}

function hideMemExport() {
    document.getElementById("memexportbg").style.display = "none";
    document.getElementById("memexport").style.display = "none";
    document.removeEventListener("keydown", memhexEscape, false);
}

function memhexEscape(evt) {
    if (evt.keyCode == 27) {
        hideMemExport();
    }
}



function setUpFileHandling() {  // File handling for saving and loading files; added November 2023.
   var saveBtn = document.getElementById("saveBtn");
   var loadBtn = document.getElementById("loadBtn");
   var loading = false;
   if (window.showOpenFilePicker && FileSystemFileHandle && FileSystemFileHandle.prototype.getFile) {
        loadBtn.addEventListener("click",doLoad,false);
    }
    else {
        let chooser = document.createElement("input");
        chooser.type = "file";
        chooser.id = "chooseloadfile";
        chooser.style.display = "none";
        document.getElementById("comp").appendChild(chooser);
        loadBtn.addEventListener("click",doBasicLoad,false);
        loadBtn.title += "  This will look like uploading a file, but it will only be loaded locally.";
    }
    if (window.showSaveFilePicker && FileSystemFileHandle && FileSystemFileHandle.prototype.createWritable) {
        saveBtn.addEventListener("click",doSave,false);  
    }
    else {
        saveBtn.addEventListener("click",doBasicSave,false);
        saveBtn.title += "  This will look like downloading a file.";
    }
    function doBasicSave() {
        if (loading)
           return;
        stopRunning();
        let content = document.getElementById("program").value;
        let name = programs[programInEditor].name.replace(/&lt;/g,"<").replace(/&amp;/g,"&");
        let blob = new Blob([content], {type: 'text/plain'});
        let link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = name + ".txt";
        link.click();
        URL.revokeObjectURL(link.href);
    }
    async function doSave() {
        if (loading)
           return;
        stopRunning();
        let content = document.getElementById("program").value;
        let name = programs[programInEditor].name.replace(/&lt;/g,"<").replace(/&amp;/g,"&");
        let blob = new Blob([content], {type: 'text/plain'});
        let options = { suggestedName: name + ".txt" };
        try {
            let fileHandle = await window.showSaveFilePicker(options);
            let stream = await fileHandle.createWritable();
            await stream.write(blob);
            await stream.close();
            setMessage("File has been saved.");
        }
        catch (e) {
            if (e.name !== "AbortError") {
                setMessage("Error while attempting to save file!");
                alert("Error while saving file:\n" + e);
            }
        }
    }
    function doBasicLoad() {
        stopRunning();
        let chooser = document.getElementById("chooseloadfile");
        chooser.value = "";
        document.getElementById("chooseloadfile").addEventListener("change",handleBasicFileLoad,false);
        chooser.click();
    }
    async function handleBasicFileLoad() {
       stopRunning();
       loadBtn.disabled = true;
       loading = true;
       try {
            let chooser = document.getElementById("chooseloadfile");
            chooser.removeEventListener("change",handleBasicFileLoad,false);
            if (chooser.files.length === 0)
               return;
            let name = chooser.files[0].name.replace("/&/g", "&amp;").replace("/</g", "&lt;");
            setMessage("Trying to load file " + name);
            if ( chooser.files[0].type && ! /^text/i.test(chooser.files[0].type))
                throw "Only text files can be loaded.";
            let text = await chooser.files[0].text();
            newProgram(chooser.files[0].name,text);
            setMessage("Successfully loaded file " + name);
       }
       catch (e) {
           setMessage("File load failed!");
           alert("File load failed:\n" + e);
       }
       finally {
           loadBtn.disabled = false;
           loading = false;
       }
    }
    async function doLoad() {
       setMessage("Load file -- select a file or cancel!");
       loading = true;
       loadBtn.disabled = true;
       try {
           let files = await window.showOpenFilePicker();
           if (files.length === 0) {
              setMessage("File load canceled"); // (Can this happen?)
              return;
           }
           let fileData = await files[0].getFile();
           if ( fileData.type && ! /^text/i.test(fileData.type)) 
               throw "Only text files can be loaded.";
           let text = await fileData.text();
           newProgram(fileData.name,text);
           setMessage("Successfully loaded file " + fileData.name.replace("/&/g", "&amp;").replace("/</g", "&lt;"));
       }
       catch (e) {
           if (e.name === "AbortError")
              setMessage("File load canceled");
           else {
              setMessage("File load failed!");
              alert("File load failed:\n" + e);
           }
       }
       finally {
           loadBtn.disabled = false;
           loading = false;
       }
    }
    function newProgram(name,text) {
        let currentProg = programs[programInEditor];
        currentProg.text = document.getElementById("program").value;
        let pos = programs.length;
        name = name.replace(/\.txt$/,"").replace("/&/g", "&amp;").replace("/</g", "&lt;");
        let prog = { name: name, text: text,
                    position: pos, status: "user" };
        programs.push(prog);
        document.getElementById("program").value = text;
        let option = document.createElement("option");
        option.value = "" + (pos+1);
        option.innerHTML = prog.name;
        document.getElementById("selectprogram").appendChild(option);
        document.getElementById("selectprogram").value = "" + (pos+1);
        programInEditor = pos;
    }
    function setMessage(msg) {
       document.getElementById("error").innerHTML = msg;
    }
}


function setUpProgramMenu() {  // Big revisions to file menu andling, November 2023
   var search = location.search;
   if (search === "?files=none" || search === "?files=") {
      programsToLoad = null;
      createMenu();
      return;
   }
   if (search === "" || search.indexOf("?files=") !== 0) {
      createMenu();
      return;
   }
   programsToLoad = "";
   document.getElementById("error").innerHTML = "Trying to load list of sample programs...";
   var fileURL = search.substring(7);
   var ajaxTimeout;
   var ajax = new XMLHttpRequest();
   ajax.open("GET",fileURL);
   ajax.overrideMimeType("text/plain");
   ajax.addEventListener("error",function() {
       clearTimeout(ajaxTimeout);
       document.getElementById("error").innerHTML = "Could not load sample file list.";
       console.log("error while trying to load file list: ajax request error.");
       createMenu();
   });
   ajax.addEventListener("load",function() {
       clearTimeout(ajaxTimeout);
       var text = ajax.responseText;
       document.getElementById("error").innerHTML = "&nbsp;";
       try {
           programs = JSON.parse(text);
           if (programs.length === undefined)
              throw "error";
           for (var i = 0; i < programs.length; i++) {
              if (typeof programs[i] !== "object")
                 throw "error";
              if ( ! ( programs[i].name && programs[i].url ))
                 throw "error";
              if ( ! ( typeof programs[i].name === "string" && typeof programs[i].url === "string"))
                 throw "error";
              program.name = program.name.replace(/&/g, "&amp;").replace(/</g, "&lt;");
           }
           programsToLoad = programs;
       }
       catch (e) {
          console.log("error while trying to load file list: " + e);
          document.getElementById("error").innerHTML = "Could not load sample programs. Syntax error in sample file list.";
       }
       createMenu();
   });
   ajaxTimeout = setTimeout(function() {
       ajax.abort();
       console.log("error while trying to load file list: request timed out.");
       document.getElementById("error").innerHTML = "Could not load sample programs. Could not load sample file list.";
       createMenu();
   }, 10000);
   try {
      ajax.send();
   } catch(e) {
       clearTimeout(ajaxTimeout);
       document.getElementById("error").innerHTML = "Could not load sample programs. Could not load sample file list.";
       createMenu();
   }
   function createMenu() {
      if (programsToLoad && programsToLoad.length > 0) {
         untitledCount = 0;
         programs = programsToLoad;
         let options = "<option value='new'>[New Program]</option>";
         for (let i = 0; i < programs.length; i++) {
            options += "<option value='" + (i+1) +"'>" + programs[i].name + "</option>";
            programs[i].position = i;
            programs[i].status = "not started";
         }
         document.getElementById("selectprogram").innerHTML = options;
         programInEditor = 0;
         startProgramLoad(programs[0]);
      }
      else {
         document.getElementById("selectprogram").innerHTML =
                   "<option value='new'>[New Program]</option>" +
                   "<option value='1'>User Program 1</option>";
         untitledCount = 1;
         programs = [
            { name: "User Program 1", text: "", position: 0, status: "user" }
         ];
         programInEditor = 0;
      }
      document.getElementById("selectprogram").value = "1";
      document.getElementById("selectprogram").onchange = doProgramChange;
   }
}


function init() {
    speed = 3;
    registerDisplay = 1;
    memDisplay = 2;
    autoscroll = true;
    document.getElementById("speed").value = "3";
    document.getElementById("regdisplay").value = "1";
    document.getElementById("memdisplay").value = "2";
       document.getElementById("program").value = "";
    document.getElementById("Addr").value = "";
    document.getElementById("Data").value = "";
    document.getElementById("autoscroll").checked = true;
    buttons = [
        document.getElementById("run"),
        document.getElementById("step"),
        document.getElementById("cycle"),
        document.getElementById("clearmem"),
        document.getElementById("zeropc"),
        document.getElementById("addrtopc"),
        document.getElementById("datatomem")
    ];
    buttons[0].onclick = doRun;
    buttons[1].onclick = doStep;
    buttons[2].onclick = doCycle;
    buttons[3].onclick = doClearMem;
    buttons[4].onclick = doZeroPC;
    buttons[5].onclick = doAddrToPC;
    buttons[6].onclick = doDataToMem;
    enableButtons();
    document.getElementById("load").onclick = doLoadProgram;
    document.getElementById("speed").onchange = doSpeedChange;
    document.getElementById("regdisplay").onchange = doRegisterDisplayChange;
    document.getElementById("memdisplay").onchange = doMemDisplayChange;
    document.getElementById("selectprogram").onchange = doProgramChange;
    document.getElementById("autoscroll").onchange = doAutoscroll;
    document.getElementById("hidememhex").onclick = hideMemExport;
    document.getElementById("showmemhex").onclick = showMemExport;
    globalConverter = new Converter();
    registers = Register.makeRegisters();
    wires = new Array(26);
    memory = new Memory( document.getElementById("mem") );
    for (let i = 0; i < 26; i++) {
        wires[i] = document.getElementById("w" + i);
    }
    try {
        graphicsCanvas = document.getElementById("graphics");
        g = graphicsCanvas.getContext("2d");
        g.fillStyle = "white";
        g.fillRect(0,0,graphicsCanvas.width,graphicsCanvas.height);
    }
    catch (e) {
        document.getElementById("graphicsholder").innerHTML =
           "<p style='color:white'>Graphics<br>view of <br>memory<br>is not<br>available<br>" +
           "because<br>your<br>browser<br>does not<br>support<br>canvas<br>graphics.</p>";
        g = null;
    }
    memory.select(0);
    Register.sync(BitSet.none);
    Register.clearHilite();
    setUpProgramMenu();
    setUpFileHandling();
}

</script>
</head>

<body onload="init();">

<noscript>
   <p style="font-weight: bold; color:red">This page requires Javascript.<br>
   Without Javascript, nothing on this page will be functional.</p>
</noscript>


<p style="border-bottom: 1.5pt solid black;"><span style="font-size:200%; font-weight:bold;margin: 5pt 0 5pt 0;">xComputer</span>
<span style="margin-left: 50pt"><b>Click for: <a href="info.html">information and instructions</a>.</b></span></p>

<table class="prog" border=0 cellspacing=0 cellpadding=0>

<tr>
  <td>
   <p style="margin:0 0 0 20pt; padding:0">
    Select Program: <select id="selectprogram" title="Sets the contents of the program editor.  To start a new, empty program, select '[New Program]'. To change to an existing program, select its name.">
       <option value="1">User Program 1</option>
    </select>
    </p>
  </td>
  <td align=right>
    <p style="margin: 0 0 0 10pt; padding:0">
       <button id="saveBtn" title="Save the program to a local file.">Save</button>
       <button id="loadBtn" title="Load a program from a local file." style="margin-left:7px">Load</button>
    </p>
  </td>
</tr>

<tr>
   <td colspan=2>
     <p style="padding: 0; margin: 5pt 2pt 5pt 20pt">
        <textarea spellcheck="false" placeholder="Input or paste your xComputer program here." id="program" wrap="off" rows=15 cols=80></textarea>
     </p>
   </td>
</tr>

<tr>
   <td colspan=2>
       <p style="margin:0; padding:0"><button style="margin-left:20pt;" id="load"
           title="Convert the program in the editor to machine language and load it into the xComputer simulator.  If an error is found in the program, it will be reported below this button.">Load Program into xComputer</button></p>
   </td>
</tr>
   
</table>


<p id="error">&nbsp;</p>

<div id="comp">
<table border=2 cellspacing=0 cellpadding=4>
<tr>

<td>
   <table border=0>
   <tr>
      <td colspan="2"><p class="heading">Controls</p></td>
   </tr>
   <tr>
      <td><button id="run" title="Start running the program, or stop it if it is currently executing.  The speed of execution is controlled by the menu below. Execution stops automatically if a HLT instruction is encountered.">Run&nbsp;</button>
          <button id="step" title="Perform one step in the execution of one instruction.  Note that control wires that implement the step and registers that are affected by the step will be highlited.">Step</button>
          <button id="cycle" title="Execute one machine language instruction.  This execute single steps until the count register is set to zero.">Cycle</button></td>
      <td><span class="label" align="right">addr:</span>
          <input type=text size=16 id="Addr" title="Input a memory address, which must be a number in the range 0 to 1023. The address is used by the 'Addr to PC' and 'Data to Mem' buttons."></td>
   </tr>
   <tr>
      <td>
         <select id="speed" title="Select the speed at which the program will be run when the 'Run' button is pressed.">
             <option value="1">Fastest Run Speed</option>
             <option value="2">Fast Run Speed</option>
             <option value="3">Moderate Run Speed</option>
             <option value="4">Slow Run Speed</option>
             <option value="5">Slower Run Speed</option>
         </select></td>
      <td><span class="label" align="right">data:</span>
         <input type=text size=16 id="Data" title="Enter data to be placed in memory by the 'Data to Mem' button.  The data can be a number decimal, binary, or hexadecimal form, or it can be an assembly language instruction."></td>
   </tr>
   <tr>
      <td colspan=2><button id="clearmem" title="Set the contents of all locations in memory to zero.">Clear Mem</button>
      <button id="zeropc" title="Place a zero into the PC register.  This lets you start executing the program from the first instruction.  Also sets COUNT register to zero.">Set PC=0</button>
      <button id="addrtopc" title="Copy the contents of the Addr input box, above, into the PC register.  This lets you start program execution at that memory address.  Also sets COUNT register to zero.">Addr to PC</button>
      <button id="datatomem" title="Copy the value in the Data input box, above, into the memory location whose address is given by the Addr input box, above.  This lets you load data or instructions into memory by hand.">Data to Mem</button>
      </td>
   </tr>
   </table>
</td>
<td rowspan=3 valign=top>
   <p class="heading">Memory</p>
   <p><select id="memdisplay" title="Select how the values in memory locations are displayed.">
      <option value="1">Assembly display</option>
      <option value="2">Integer display</option>
      <option value="3">Unsigned display</option>
      <option value="4">Binary display</option>
      <option value="5">ASCII display</option>
   </select></p>
   <div id="memholder">
   <div id="mem">
   </div>
   </div>
   <p><label title="When checked, memory will automatically be scrolled so that the currently selected location is visible.  (However, no autoscrolling is done when the program is run at 'fast' or 'fastest' speed.)"><input type="checkbox" id="autoscroll">Autoscroll</label></p>
</td>
<td rowspan=3 bgcolor="#555555">
   <div id="graphicsholder">
       <canvas id="graphics" width=128 height=512 title="A graphical display of the contents of memory.  Each bit in memory is represented by a dot which is white for zero or black for one.  Each row of dots shows the bits of four consecutive memory locations."></canvas>
   </div>
</td>
</tr>
   
<tr>
<td>
    <table border=0>
    <tr>
       <td colspan=2><p class="heading">Registers</p></td>
       <td colspan=2><select id="regdisplay" title="Select how the contents of the registers are displayed.  The 'Default display' option shows an assembly language instruction in the IR register and integers in the other registers.">
          <option value="1">Default display</option>
          <option value="2">Integer display</option>
          <option value="3">Unsigned display</option>
          <option value="4">Binary display</option>
       </select></td>
    </tr>
    <tr>
       <td align="right"><label class="label" id="X_label" for="X_input">X:</label></td>
       <td><input type=text id="X_input" size=16 readonly=true title="The first input register for the Arithmetic Logic Unit."></td>
       <td align="right"><label class="label" id="COUNT_label" for="COUNT_input">COUNT:</label></td>
       <td><input type=text id="COUNT_input" size=16 readonly=true title="Holds the current step number.  Each instruction is executed by a sequence of steps.  At the end of each instruction, the COUNT registers is reset to zero."></td>
    </tr>
    <tr>
       <td align="right"><label class="label" id="Y_label" for="Y_input">Y:</label></td>
       <td><input type=text id="Y_input" size=16 readonly=true title="The second input register for the Arithmetic Logic Unit."></td>
       <td align="right"><label class="label" id="IR_label" for="IR_input">IR:</label></td>
       <td><input type=text id="IR_input" size=16 readonly=true title="Instructions are copied from memory into this Instruction Register.  This is always done when COUNT is 3; the remaining steps in the instruction cycle will execute the instruction in this register."></td>
    </tr>
    <tr>
       <td align="right"><label class="label" id="FLAG_label" for="FLAG_input">FLAG:</label></td>
       <td><input type=text id="FLAG_input" size=16 readonly=true title="The Arithmetic Logic Unit sets FLAG to zero or one when it does certain computations such as addition or shift."></td>
       <td align="right"><label class="label" id="PC_label" for="PC_input">PC:</label></td>
       <td><input type=text id="PC_input" size=16 readonly=true title="This Program Counter register holds the memory address of the next program instruction to be executed.  It goes up by one in each execution cycle but can also be modified by jump instructions."></td>
    </tr>
    <tr>
       <td align="right"><label class="label" id="AC_label" for="AC_input">AC:</label></td>
       <td><input type=text id="AC_input" size=16 readonly=true title="This Accumulator register holds the result of computations done by the Arithmetic Logic Unit.  It is also used for loading data from memory and storing answers into memeory."></td>
       <td align="right"><label class="label" id="ADDR_label" for="ADDR_input">ADDR:</label></td>
       <td><input type=text id="ADDR_input" size=16 readonly=true title="This Address register holds the address of a memory location.  Data and instructions can only be loaded from and stored to the location that is currently selected by this register."></td>
    </tr>
    </table>
</td>
</tr>

<tr>
<td>
    <table border=0 id="wiretable" title="Program execution is driven by control wires that are turned on and off based on the contents of the COUNT and IR registers.  This panel lists all 26 control wires.  A wire name is highlighted when the wire is on (but not during fast execution).">
    <tr>
      <td colspan=2><p class="heading">Control Wires</p></td>
      <td valign=bottom><p class="wire" id="w0">Select-Add</p></td> 
      <td valign=bottom><p class="wire" id="w1">Select-Subtract</p></td> 
    </tr>
    <tr>
      <td><p class="wire" id="w2">Select-AND</p></td>
      <td><p class="wire" id="w3">Select-OR</p></td> 
      <td><p class="wire" id="w4">Select-NOT</p></td>
      <td><p class="wire" id="w5">Select-Shift-Left</p></td> 
    </tr>
    <tr>
      <td><p class="wire" id="w6">Select-Shift-Right</p></td>
      <td><p class="wire" id="w7">Load-Data-Into-Mem</p></td> 
      <td><p class="wire" id="w8">Load-X-From-AC</p></td> 
      <td><p class="wire" id="w9">Load-Y-From-Mem</p></td> 
    </tr>
    <tr>
      <td><p class="wire" id="w10">Load-Y-From-IR</p></td>
      <td><p class="wire" id="w11">Load-AC-From-ALU</p></td> 
      <td><p class="wire" id="w12">Load-AC-From-Mem</p></td> 
      <td><p class="wire" id="w13">Load-AC-From-IR</p></td> 
    </tr>
    <tr>
      <td><p class="wire" id="w14">Increment-AC</p></td>
      <td><p class="wire" id="w15">Decrement-AC</p></td> 
      <td><p class="wire" id="w16">Load-Flag-From-ALU</p></td> 
      <td><p class="wire" id="w17">Load-PC-From-Mem</p></td> 
    </tr>
    <tr>
      <td><p class="wire" id="w18">Load-PC-From-IR</p></td>
      <td><p class="wire" id="w19">Increment-PC</p></td> 
      <td><p class="wire" id="w20">Load-IR-From-Mem</p></td> 
      <td><p class="wire" id="w21">Load-ADDR-From-IR</p></td> 
    </tr>
    <tr>
      <td><p class="wire" id="w22">Load-ADDR-From-Y</p></td>
      <td><p class="wire" id="w23">Load-ADDR-From-PC</p></td> 
      <td><p class="wire" id="w24">Set-COUNT-To-Zero</p></td> 
      <td><p class="wire" id="w25">Stop-Clock</p></td>
    </tr>
    </table>
</td>
</tr>

</table>
<p style="margin-left:500px"><button id="showmemhex"
   title="Get contents of memory as a list of hexadecimal numbers, which can be loaded in to the Logisim simulation of xComputer.  (This has only a very limited audience.)">Grab Memory for Logisim</button></p>
</div>

<div id="memexportbg">
</div>
<div id="memexport">
<p><button id="hidememhex">Dismiss!</button></p>
<p>
The textarea below shows the contents of the<br>
xComputer memory, in a format that can be <br>
loaded into the RAM component of the Logisim<br>
simulation of xComputer.  This feature has<br>
a very limited audience.  For information, see <br>
the <a href="info.html#logisim">last section</a> of the xComputer info page.
</p>
<p style="text-align:center"><textarea rows="20" cols="20" id="memhex" readonly></textarea>
</div>

</body>
</html>

