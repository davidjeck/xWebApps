<!DOCTYPE html>
<!--
    Web page written by David Eck (https://math.hws.edu/eck/index.html)
    You can do anything you like with this web page and with the code, but
    if you use a substantial portion of it, you should include attribution.
    
    This page implements "turtle graphics".  It can execute programs and
    individual commands written in a made-up xTurtle programming language.
    For more information and instruction, see the info page, info.html,
    availale thorugh a link at the top of this page.
    
    The original xTurtle program was written in about 1993 in Macintosh Object
    Pascal and was translated into a Java applet in about 1997.  This JavaScript
    version is a 2020 translation of the Java applet, and its heritage is
    clear in some of the code (notably some variable names that begin with
    an upper case letter) and in the design of the xTurtle programming language,
    which was based to some extend on Pascal.
    
    The ability to save and load local files was added in November, 2023.  At the
    same time, the handling of the popup menu of examples was changed to allow
    the list of the programs to be set by a search component in the URL that is
    used to access the web app -- see the long comment at the beginning of the
    script, below.
-->
<html>
<head>
<meta charset="UTF-8">

<style type="text/css">
   body {
       background-color: #D8D8D8;
   }
   canvas {
       display: block;
       background-color: #BBBBBB;
   }
   #canvas-holder {
       display: inline-block;
       border: 2px solid black;
       margin: 0;
       padding: 0;
   }
   #controls {
       display: inline-block;
       background-color:white;
       border-left: 2px solid black;
       border-right: 2px solid black;
       border-top: 2px solid black;
       padding: 0;
       margin: 0;
   }
   #controls p {
       margin: 12px 0;
       white-space: nowrap;
   }
   div.group {
       padding: 0 8px;
       border-bottom: 2px solid black;
   }
   #imagediv p {
       margin: 4px 0;
       white-space: nowrap;
   }
   #turtlediv {
       margin: 0 0 0 20px;
       padding: 0;
       position: relative;
   }
   .dialog, #errorreport {
       display: none;
       z-index: 10; 
       position: absolute;
       left: 50px;
       top: 150px;
       width: 500px;
       border-radius: 16px;
       box-shadow: 5px 5px 8px black;
   }
   .dialog {
       border: 2px solid #000099;
       background-color: #D8D8FF;
   }
   #errorreport {
       border: 2px solid #AA0000;
       background-color: #444444;
       color: white;
   }
   .dialog p, #errorreport p {
      padding: 0 10pt;
   }
   
   #status {
       white-space: nowrap;
       font-weight: bold;
       color: #AA0000;
   }
   textarea {
     white-space: pre;
     word-wrap: normal;
     overflow-x: scroll;
   }
</style>

<script>
   
/* programsToLoad contains a list of sample programs that are available on the web site.
 * If this web app is loaded thruogh a URL with no search component, the programs will appear in
 * a popup menu above the textarea that serves as a program editor in the app, and the first program
 * will be loaded into the textarea.  If the search component in the URL is "?files=none", this
 * behavior is surpressed.  Otherwise, in a search component has the form "?files=..." then ... must 
 * be a relative URL to a text file containing a list of files for the popup menu. The content
 * of the file should be a JSON object with the same form as programsToLoad.  That string
 * will replace programsToLoad and will be treated in the same way.  If the file can't be
 * loaded, or if its content does not have the correct form, no files will appear in the menu.
 * The value of an array of objects.  Each object has a "name" property, which will appear
 * in the popup menu, and a "url" property, which is a relative URL to the the file.
 */

var programsToLoad = [  // Default set of programs to be added to the popup menu of examples.
    { "name": "Tutorial 1: Basics",  "url": "programs/Tutorial1_basics.txt" },
    { "name": "Tutorial 2: Variables",  "url": "programs/Tutorial2_variables.txt" },
    { "name": "Tutorial 3: Interaction with User",  "url": "programs/Tutorial3_io.txt" },
    { "name": "Tutorial 4: LOOP",  "url": "programs/Tutorial4_loop.txt" },
    { "name": "Tutorial 5: IF",  "url": "programs/Tutorial5_if.txt" },
    { "name": "Tutorial 6: Subroutines",  "url": "programs/Tutorial6_subroutines.txt" },
    { "name": "Tutorial 7: Recursion",  "url": "programs/Tutorial7_recursion.txt" },
    { "name": "Tutorial 8: Multitasking",  "url": "programs/Tutorial8_multitasking.txt" },
    { "name": "Loop Example: Colored Circles",  "url": "programs/ColoredCircles.txt" },
    { "name": "Recursion Example: Bush",  "url": "programs/RecursiveBush.txt" },
    { "name": "Multitasking Example: Snowflake",  "url": "programs/ParallelSnowflake.txt" },
    { "name": "Multitaksing Example: Brownian Motion", "url": "programs/BrownianMotion.txt" },
    { "name": "Multitasking Example: Persion Tiling",  "url": "programs/PersianTiling.txt" },
    { "name": "Multitasking Example: Grab Demo", "url": "programs/grab.txt"}
];



const maxProcessCount = 1000;
const maxRecursionDepth = 2000;
const maxForkCount = 100;

var canvas, graphics, OSC, OSG;

var turtles;

var programs;
var programInEditor;

var /*TProgram*/ loadedProgram = null;
var loadedProgramSymbols = null;
var loadedProgramName = null;
var loadedProgramTurtle = null;

var alwaysHideTurtles = false;

function TError( message, pos ) {
   this.message = message;
   this.pos = pos;
}

//-------------------------------- Running a program --------------------------------

   var /*TProgram*/ prog;
   var /* BitSet */ Semaphore;
   var /*boolean*/ randomScheduling = false;
   var /*boolean*/ running = false;
   var countDownFrames;
   var /*boolean*/ paused = false;
   var /*double*/ userInput;
   var userInputLoc;
   
   var /*Turtle*/ proc, topProc, activeProcessList;
   var runSpeed = 3;
   var countDownFramesForRunSpeed = [0,0,2,5,13,30];
   
   var /*int*/ totalNumberOfProcesses;
   
   var currentInputDialog = null;
   
   function startRunningProgram(theProgram, theTurtle) {
      prog = theProgram;
      proc = theTurtle;
      Semaphore = 0;
      topProc = proc;
      activeProcessList = proc;
      proc.recursionDepth = 0;
      totalNumberOfProcesses = 0;
      running = true;
      countDownFrames = 15;
      document.getElementById("doit").disabled = true;
      document.getElementById("command").disabled = true;
      document.getElementById("run").disabled = true;
      document.getElementById("pause").disabled = false;
      document.getElementById("stop").disabled = false;
      document.getElementById("status").innerHTML = "xTurtle Status: Running";
      requestAnimationFrame(doInstructions);
   }
   
   function stopRunning() {
      if (!running)
         return;
      if (currentInputDialog) {
         currentInputDialog.style.display = "none";
         currentInputDialog = null;
      }
      running = false;
      paused = false;
      proc = topProc;
      proc.prev = proc.next = proc;
      proc.children = null;
      activeProcessList = proc;
      document.getElementById("doit").disabled = false;
      document.getElementById("command").disabled = false;
      document.getElementById("run").disabled = true;
      document.getElementById("pause").disabled = true;
      document.getElementById("stop").disabled = true;
      document.getElementById("status").innerHTML = "xTurtle Status: Finished " + loadedProgramName;
      doDraw();
      document.getElementById("command").focus();
      document.getElementById("command").select();
   }
   
   function pauseRunning() {
      if (!running || paused)
         return;
      document.getElementById("run").disabled = false;
      document.getElementById("pause").disabled = true;
      paused = true;
   }
   
   function resumeRunning() {
      if (!running || !paused)
         return;
      document.getElementById("run").disabled = true;
      document.getElementById("pause").disabled = false;
      paused = false;
      countDownFrames = 0;
      requestAnimationFrame(doInstructions);
   }
   
   function gotInput() {
      currentInputDialog.style.display = "none";
      if (currentInputDialog == document.getElementById("askuser") ||
               currentInputDialog == document.getElementById("yesorno") )
         proc.store(userInputLoc,userInput);
      currentInputDialog = null;
      if (running && !paused)
         requestAnimationFrame(doInstructions);
   }
   
   function waitForInput(command, message) {
      if ( command == TTokenizer.AskUser_ ) {
         currentInputDialog = document.getElementById("askuser");
         document.getElementById("aumessage").innerHTML = message;
         document.getElementById("auinput").value = "";
         document.getElementById("auinput").focus();
      }
      else if ( command == TTokenizer.TellUser_ ) {
         currentInputDialog = document.getElementById("telluser");
         document.getElementById("tumessage").innerHTML = message;
      }
      else {
         currentInputDialog = document.getElementById("yesorno");
         document.getElementById("ynmessage").innerHTML = message;
      }
      currentInputDialog.style.display = "block";
   }
   
   function showErrorDialog(message) {
       document.getElementById("errorreport").style.display = "block";
       document.getElementById("errormessage").innerHTML = message;
   }
   
   function doError(message) {
      throw new TError(message,-1);
   }
   
   function doInstructions() {
       if (!running || paused || currentInputDialog)
          return;
       if (countDownFrames > 0) {
          countDownFrames--;
          requestAnimationFrame(doInstructions);
          return;
       }
       try {
         countDownFrames = countDownFramesForRunSpeed[runSpeed-1];
         var numberExecuted = 0;
         var drawCommands = 0;
         var insCt = randomScheduling? 3 + Math.floor(7*Math.random()) : 1;
         while (true) {
            let draw = doInstruction();
            insCt--;
            if (insCt <= 0) {
                proc = proc.next;
                insCt = randomScheduling? 5 + Math.floor(10*Math.random()) : 1;
            }
            if (draw) {
                drawCommands++;
                if (runSpeed > 1 || drawCommands == 5) {   
                    break;
                }
            }
            if (!running || currentInputDialog)
               break;
            numberExecuted++;
            if (numberExecuted == 1000) {
                countDownFrames = 0;
                break;
            }
         }
         if (drawCommands > 0) {
            doDraw();
         }
         if (running && !paused && !currentInputDialog) {
            requestAnimationFrame(doInstructions);
         }
       }
       catch (e) {
           stopRunning();
           if (e instanceof TError) {
               showErrorDialog("Runtime error: " + e.message);
           }
           else {
               showErrorDialog("Internal error (this is a bug): " + e);
               if (e.stack) console.log(e.stack);
           }
       }
   }
      
   function doInstruction() {  // returns needsRedraw
      var loc = proc.programCounter;
      proc.programCounter++;
      var kind = prog.ins[loc];
      //console.log("Execute " + kind + " at " + loc);
      if (kind >= TTokenizer.sin_ && kind <= TTokenizer.EQ_) {
         doComputation(kind);
         return false;
      }
      var needsRedraw = false;
      var str;
      var p1 = 0, p2 = 0, p3 = 0, addr = 0;
      if (kind >= TTokenizer.Fork_ && kind <= TTokenizer.hsb_) {
        p1 = proc.pop();
        if (isNaN(p1))
          doError("Uninitialized value used as subroutine parameter.");
        if (kind >= TTokenizer.Move_) {
          p2 = proc.pop();
          if (isNaN(p2))
              doError("Uninitialized value used as subroutine parameter.");
          if (kind >= TTokenizer.rgb_) {
             p3 = proc.pop();
             if (isNaN(p3))
                doError("Uninitialized value used as subroutine parameter.");
          }
        }
      }
      switch (kind) {
       case TTokenizer.Jump_: 
         proc.programCounter = prog.data[loc];
         break;
       case TTokenizer.JumpToSubroutine_:
         proc.recursionDepth++;
         if (proc.recursionDepth > maxRecursionDepth)
            doError("Your program has exceeded the maximum allowed subroutine call depth of " + maxRecursionDepth + ".  Check for 'infinite recursion.'");
         proc.programCounter = prog.data[loc];
         proc.stackRef = proc.stackTop - 1;
         break;
       case TTokenizer.SubroutineSetup_:
       case TTokenizer.FunctionSetup_:
         if (kind == TTokenizer.FunctionSetup_)
           proc.push(NaN);
         proc.push(proc.stackRef);
         proc.push(proc.programCounter);
         break;
       case TTokenizer.AdjustSavedPC_: 
         proc.stack[proc.stackTop - proc.stackStart - prog.data[loc] - 1] = proc.programCounter + 1;
         break;
       case TTokenizer.SetStackRef_:
         proc.stackRef = proc.stackTop - prog.data[loc] - 1;
         break;
       case TTokenizer.Reserve_: 
         for (i = 1; i<= prog.data[loc] - topProc.stackTop; i++)
           proc.push(NaN);
         break;
       case TTokenizer.HideTurtle_:
         needsRedraw = true;
         proc.turtleIsVisible = false;
         break;
       case TTokenizer.ShowTurtle_:
         needsRedraw = true;
         proc.turtleIsVisible = true;
         break;
       case TTokenizer.Clear_: 
         OSG.fillStyle = "white";
         OSG.fillRect(0,0,canvas.width,canvas.height);
         needsRedraw = true;
         break;
       case TTokenizer.Home_: 
         proc.turtleX = proc.turtleY = proc.turtleHeading = 0;
         needsRedraw = true;
         break;
       case TTokenizer.PenUp_: 
         proc.turtleIsDrawing = false;
         break;
       case TTokenizer.PenDown_: 
         proc.turtleIsDrawing = true;
         break;
       case TTokenizer.red_:
         proc.color = "red";
         break;
       case TTokenizer.blue_:
         proc.color = "blue";
         break;
       case TTokenizer.green_:
         proc.color = "green";
         break;
       case TTokenizer.cyan_:
         proc.color = "cyan";
         break;
       case TTokenizer.magenta_:
         proc.color = "magenta";
         break;
       case TTokenizer.yellow_:
         proc.color = "yellow";
         break;
       case TTokenizer.gray_:
         proc.color = "gray";
         break;
       case TTokenizer.darkGray_:
         proc.color = "darkGray";
         break;
       case TTokenizer.lightGray_:
         proc.color = "lightGray";
         break;
       case TTokenizer.black_:
         proc.color = "black";
         break;
       case TTokenizer.white_:
         proc.color = "white";
         break;
       case TTokenizer.Die_:
         needsRedraw = !alwaysHideTurtles;
         doKillProcess();
         break;
       case TTokenizer.Halt_:
         stopRunning();
         break;
       case TTokenizer.return_:
       case TTokenizer.returnFromFunction_: 
         doReturn(prog.data[loc]);
         break;
       case TTokenizer.Fork_: 
         needsRedraw = !alwaysHideTurtles;
         doFork(Math.round(p1));
         break;
       case TTokenizer.JumpIf_: 
         if (p1 == 1)
           proc.programCounter = prog.data[loc];
         break;
       case TTokenizer.Pop_: 
         proc.store(prog.data[loc], p1);
         break;
       case TTokenizer.PopRefParam_:
         addr = proc.fetch(prog.data[loc]);
         proc.store(addr, p1);
         break;
       case TTokenizer.PopFunctionValue_: 
         proc.store(-(proc.stackRef - 2), p1);
         break;
       case TTokenizer.Grab_: 
         if ( (Semaphore & (1 << prog.data[loc])) == 0 ) {
           Semaphore = Semaphore | (1 << prog.data[loc]);
           proc.programCounter++; // bypass jump instruction
         }
         break;
       case TTokenizer.endGrab_: 
         Semaphore = Semaphore & ~(1 << prog.data[loc]);
         break;
       case TTokenizer.Forward_: 
         needsRedraw = true;
         proc.forward(p1);
         break;
       case TTokenizer.Back_: 
         needsRedraw = true;
         proc.forward(-p1);
         break;
       case TTokenizer.Turn_: 
         needsRedraw = proc.turtleIsVisible && !alwaysHideTurtles;
         proc.face(proc.turtleHeading + p1);
         break;
       case TTokenizer.Face_: 
         needsRedraw = proc.turtleIsVisible && !alwaysHideTurtles;
         proc.face(p1);
         break;
       case TTokenizer.Circle_: 
         needsRedraw = true;
         proc.circle(p1);
         break;
       case TTokenizer.Move_: 
         needsRedraw = true;
         proc.moveTo(p2 + proc.turtleX, p1 + proc.turtleY);
         break;
       case TTokenizer.MoveTo_: 
         needsRedraw = true;
         proc.moveTo(p2, p1);
         break;
       case TTokenizer.Arc_:
         needsRedraw = true;
         if (Math.abs(p2) > 360)
            p2 = 360;
         proc.arc(p2, p1);
         break;
       case TTokenizer.DrawText_:
         needsRedraw = true;
         str = makeString(prog.data[loc]);
         proc.text(str);
         break;
       case TTokenizer.rgb_:
         var a1 = Math.round(255*Math.max(0.0,Math.min(p1,1.0)));
         var a2 = Math.round(255*Math.max(0.0,Math.min(p2,1.0)));
         var a3 = Math.round(255*Math.max(0.0,Math.min(p3,1.0)));
         proc.color = "rgb(" + a3 + "," + a2 + "," + a1 + ")";
         break;
       case TTokenizer.hsb_:
         var value = Math.max(0.0,Math.min(p1,1.0));
         var saturation = Math.max(0.0,Math.min(p2,1.0));
         var l = value*(1-saturation/2);
         var s = (l == 0 || l == 1)? 0 : (value-l)/Math.min(l,1-l);
         l = Math.round(100*l);
         s = Math.round(100*s);
         var h = Math.round(360*Math.max(0.0,Math.min(p3,1.0)));
         proc.color = "hsl(" + h + "," + s + "%," + l + "%)";
         break;
       case TTokenizer.Push_:
         p1 = proc.fetch(prog.data[loc]);
         proc.push(p1);
         break;
       case TTokenizer.PushRefParam_:
         addr = proc.fetch(prog.data[loc]);
         p1 = proc.fetch(Math.round(addr));
         proc.push(p1);
         break;
       case TTokenizer.PushAbsoluteReference_: 
         if (prog.data[loc] < 0)
           proc.push(prog.data[loc]);
         else
           proc.push(-(proc.stackRef + prog.data[loc]));
         break;
       case TTokenizer.PushConstant_: 
         proc.push(prog.constantStore[prog.data[loc]]);
         break;
       case TTokenizer.PushDummy_: 
         proc.push(NaN);
         break;
       case TTokenizer.YesOrNo_:
       case TTokenizer.AskUser_:
         str = makeString(prog.data[loc]);
         waitForInput(kind,str);
         userInputLoc = p1;
         break;
       case TTokenizer.TellUser_:
         str = makeString(prog.data[loc]);
         waitForInput(kind,str);
         break;
       case TTokenizer.Random_: 
         proc.push(Math.random());
         break;
       case TTokenizer.turtleX_: 
         proc.push(Math.round(10000 * proc.turtleX) / 10000.0);
         break;
       case TTokenizer.turtleY_: 
         proc.push(Math.round(10000 * proc.turtleY) / 10000.0);
         break;
       case TTokenizer.turtleHeading_: 
         proc.push(Math.round(10000 * proc.turtleHeading) / 10000);
         break;
       case TTokenizer.TurtleIsVisible_: 
         proc.push( proc.turtleIsVisible? 1 : 0 );
         break;
       case TTokenizer.TurtleIsDrawing_: 
         proc.push( proc.turtleIsDrawing? 1 : 0 );
         break;
       case TTokenizer.forkNumber_: 
         proc.push(proc.forkNumber);
      }
      return needsRedraw;
      function makeString (loc) {
         var s = "";
         var str = prog.stringStore[loc];
         var numCt = 0;
         for (let i = 0; i< str.length; i++) {
           if (str.charAt(i) == String.fromCharCode(255))
              numCt++;
         }
         var nums = new Array(numCt);
         for (let i = numCt-1; i>= 0; i--)
            nums[i] = proc.pop();
         numCt = 0;
         for (let i = 0; i < str.length; i++) {
           let ch = str.charAt(i);
           if (ch == String.fromCharCode(255)) {
             if ( ! isFinite(nums[numCt]) )
                s += "(undefined)";
             else
                s = s + niceNum(nums[numCt]);
             numCt++;
           }
           else
             s += ch;
         }
         return s;
      }
      function niceNum(num) {
         if (num == 0)
            return 0;
         if (Math.abs(num) < 0.00005 || Math.abs(num) > 50000)
            return num.toExponential(7);
         var str = num.toPrecision(8);
         if (str.indexOf('.') < 0)
            return str;
         while (str.charAt(str.length-1) == '0') {
            str = str.substring(0,str.length-1);
         }
         if (str == '.' || str == "+." || str == "-.")
            return "0";
         if (str.charAt(str.length-1) == '.')
            str = str.substring(0,str.length-1);
         return str;
      }
      function doKillProcess() {
          if (activeProcessList == proc && proc.next == proc) {
            stopRunning();
            return;
          }
          var newproc = proc.prev;
          if (activeProcessList == proc)
            activeProcessList = newproc;
          proc.next.prev = proc.prev;
          proc.prev.next = proc.next;
          do {
            let parent = proc.parent;
            for (let i = 0; i < parent.children.length; i++) {
              if (parent.children[i] == proc) {
                 totalNumberOfProcesses--;
                 if (parent.children.length == 1)
                    parent.children = null;
                 else
                    parent.children.splice(i,1);
                 break;
              }
            }
            proc = parent;
          } while (proc.children == null);
          proc = newproc;
      }
      function doFork (processCt) {
          if (processCt < 1)
            doError("The number of processes in a fork command must be positive.");
          if (processCt > maxForkCount)
            doError("The number of processes created by a fork command is limited to " + maxForkCount + ".");
          if (processCt == 1)
            return;
          totalNumberOfProcesses += processCt;
          //console.log("Processes " + totalNumberOfProcesses);
          if (totalNumberOfProcesses > maxProcessCount)
             doError("Your program has created more than the permitted maximum of " + maxProcessCount + " processes.");
          proc.children = [];
          for (let i = 1; i<= processCt; i++) {
            let newProc = new Turtle(proc.programCounter, proc);
            proc.children.push(newProc);
            newProc.programCounter = proc.programCounter;
            newProc.stackTop = proc.stackTop;
            newProc.stackStart = proc.stackTop;
            newProc.stackRef = proc.stackRef;
            newProc.turtleX = proc.turtleX;
            newProc.turtleY = proc.turtleY;
            newProc.turtleHeading = proc.turtleHeading;
            newProc.turtleIsVisible = proc.turtleIsVisible;
            newProc.turtleIsDrawing = proc.turtleIsDrawing;
            newProc.recursionDepth = proc.recursionDepth;
            newProc.color = proc.color;
            newProc.forkNumber = i;
            insertProcess(newProc);
          }
          if (activeProcessList == proc)
            activeProcessList = proc.next;
          proc.next.prev = proc.prev;
          proc.prev.next = proc.next;
          proc.prev = proc;
          proc.next = proc;
          proc = proc.children[0].prev;
      }
     function doReturn (stackItems) {
          var newTop = proc.stackTop - stackItems;
          while (newTop <= proc.stackStart) {
            let parent = proc.parent;
            for (let i = 0; i < parent.children.length; i++) {
               if (parent.children[i] == proc) {
                  totalNumberOfProcesses--;
                  if (parent.children.length == 1)
                     parent.children = null;
                  else
                     parent.children.splice(i,1);
                  break;
               }
            }
            if (parent.children != null) { // all children must return before caller resumes
              let nextProc = proc.prev;
              if (activeProcessList == proc) {
                 activeProcessList = proc.prev;
              }
              proc.next.prev = proc.prev;
              proc.prev.next = proc.next;
              proc = nextProc;
              needsRedraw = !alwaysHideTurtles;
              return;
            }
            insertProcess(parent);
            proc.next.prev = proc.prev;
            proc.prev.next = proc.next;
            if (activeProcessList == proc)
              activeProcessList = parent;
            proc = parent;
          }
          proc.stackTop = newTop;
          proc.programCounter = proc.pop();
          proc.stackRef = proc.pop();
          proc.recursionDepth--;
      }
      function insertProcess (newproc) {
        newproc.next = proc;
        newproc.prev = proc.prev;
        proc.prev = newproc;
        newproc.prev.next = newproc;
      }
  }

  function doComputation(kind) {
    var p1=0, p2=0, ans=0;
    p1 = proc.pop();
    if (isNaN(p1))
      doError("Uninitialized value used as subroutine parameter.");
    if (kind >= TTokenizer.plus_) {
      p2 = proc.pop();
      if (isNaN(p2))
          doError("Uninitialized value used as subroutine parameter.");
    }
    switch (kind) {
     case TTokenizer.not_: 
       ans = (p1 == 0)? 1 : 0;
       break;
     case TTokenizer.sin_: 
       ans = Math.sin(p1 / 180 * Math.PI);
       break;
     case TTokenizer.cos_: 
       ans = Math.cos(p1 / 180 * Math.PI);
       break;
     case TTokenizer.tan_:
       ans = Math.tan(p1 / 180 * Math.PI);
       break;
     case TTokenizer.sec_:
       ans = 1 / Math.cos(p1 / 180 * Math.PI);
       break;
     case TTokenizer.cot_:
       ans = Math.cos(p1 / 180 * Math.PI) / Math.sin(p1 / 180 * Math.PI);
       break;
     case TTokenizer.csc_:
       ans = 1 / Math.sin(p1 / 180 * Math.PI);
       break;
     case TTokenizer.arctan_: 
       ans = Math.atan(p1) * 180 / Math.PI;
       break;
     case TTokenizer.arcsin_:
       ans = Math.asin(p1) * 180 / Math.PI;
       break;
     case TTokenizer.arccos_: 
       ans = Math.acos(p1) * 180 / Math.PI;
       break;
     case TTokenizer.abs_: 
       ans = Math.abs(p1);
       break;
     case TTokenizer.sqrt_: 
       if (p1 < 0)
         doError("Illegal attempt to take the square root of a negative number.");
       else
         ans = Math.sqrt(p1);
       break;
     case TTokenizer.exp_: 
       ans = Math.exp(p1);
       break;
     case TTokenizer.ln_: 
       if (p1 < 0)
         doError("Illegal attempt to take the logartihm of a negative number.");
       else
         ans = Math.log(p1);
       break;
     case TTokenizer.round_: 
       ans = Math.round(p1);
       break;
     case TTokenizer.trunc_: 
       ans = Math.floor(p1);
       break;
     case TTokenizer.RandomInt_: 
       ans = Math.floor(Math.random()*p1) + 1;
       break;
     case TTokenizer.UnaryMinus_: 
       ans = -p1;
       break;
     case TTokenizer.plus_: 
       ans = p1 + p2;
       break;
     case TTokenizer.minus_: 
       ans = p2 - p1;
       break;
     case TTokenizer.times_: 
       ans = p1 * p2;
       break;
     case TTokenizer.divide_: 
       if (p1 == 0)
         doError("Illegal attempt to divide by zero.");
       else
         ans = p2 / p1;
       break;
     case TTokenizer.power_:
        ans = Math.pow(p2, p1);
        break;
     case TTokenizer.and_: 
       ans = (p1 == 1 && p2 == 1)? 1 : 0;
       break;
     case TTokenizer.or_: 
       ans = (p1 == 1 || p2 == 1)? 1 : 0;
       break;
     case TTokenizer.LT_: 
       ans = (p2 < p1)? 1: 0;
       break;
     case TTokenizer.GT_: 
       ans = (p2 > p1)? 1: 0;
       break;
     case TTokenizer.LE_: 
       ans = (p2 <= p1)? 1: 0;
       break;
     case TTokenizer.GE_: 
       ans = (p2 >= p1)? 1: 0;
       break;
     case TTokenizer.NE_: 
       ans = (Math.abs(p2 - p1) > 5e-12 * (Math.abs(p2) + Math.abs(p1)))? 1: 0;
       break;
     case TTokenizer.EQ_: 
       ans = (Math.abs(p2 - p1) <= 5e-12 * (Math.abs(p2) + Math.abs(p1)))? 1: 0;
       break;
    }
    if ( ! isFinite(ans) )
       doError("Undefined computation result, or number too big.");
     proc.push(ans);
   }

//--------------------------------- Graphics----------------------------------------

function Turtle(start, parent) {  // Represents a turtle and its execution environment, mostly from TStack in Java vertsion
   this.parent = parent;
   this.turtleX = 0;
   this.turtleY = 0;
   this.turtleHeading = 0;
   this.turtleIsVisible = true;
   this.turtleIsDrawing = true;
   this.forkNumber = 0;
   this.programCounter = start;
   this.stackStart = 0;
   this.stackTop = 0;
   this.stackRef = 0;
   this.next = this;
   this.prev = this;
   this.children = null;
   this.color = "red";
   this.turtleRef = null;
   this.recursionDepth = 0;
   this.stack = [];
}
Turtle.prototype.draw = function() {
   if ( ! this.turtleIsVisible )
       return;
   let cx = (this.turtleX+10)/20 * canvas.width;
   let cy = canvas.height*(1-(this.turtleY+10)/20);
   if (cx >= -10 && cx <= canvas.width + 10 && cy >= -10 && cy <= canvas.height + 10) {
      graphics.save();
      graphics.translate(cx,cy);
      graphics.rotate(-this.turtleHeading/180*Math.PI);
      graphics.beginPath();
      graphics.moveTo(0,-10);
      graphics.lineTo(25,0);
      graphics.lineTo(0,10);
      graphics.closePath();
      graphics.stroke();
      graphics.globalAlpha = 0.33;
      graphics.fill();
      graphics.restore();
   }
};
Turtle.prototype.forward = function(dist) {
   var rad = this.turtleHeading/180 * Math.PI;
   this.moveTo( this.turtleX + dist*Math.cos(rad), this.turtleY + dist*Math.sin(rad) );
};
Turtle.prototype.moveTo = function(x,y) {
    var a = (this.turtleX+10)/20 * canvas.width;
    var b = (1-(this.turtleY+10)/20) * canvas.height;
    this.turtleX = x;
    this.turtleY = y;
    var a1 = (this.turtleX+10)/20 * canvas.width;
    var b1 = (1-(this.turtleY+10)/20) * canvas.height;
    if (this.turtleIsDrawing) {
       OSG.strokeStyle = this.color;
       OSG.beginPath();
       OSG.moveTo(a,b);
       OSG.lineTo(a1,b1);
       OSG.stroke();
    }
};
Turtle.prototype.arc = function(radius,angle) {
    if (Math.abs(angle) >= 360) {
       this.circle(radius);
    }
    var perp =  (radius > 0 ? this.turtleHeading + 90 : this.turtleHeading - 90)/180 * Math.PI;
    var cx = this.turtleX + Math.cos(perp) * Math.abs(radius);
    var cy = this.turtleY + Math.sin(perp) * Math.abs(radius);
    if (radius > 0) {
       this.face(this.turtleHeading + angle);
       this.turtleX = cx + radius*Math.cos(Math.PI + perp + angle/180*Math.PI);
       this.turtleY = cy + radius*Math.sin(Math.PI + perp + angle/180*Math.PI);
    }
    else {
       this.face(this.turtleHeading - angle);
       this.turtleX = cx - radius*Math.cos(Math.PI + perp - angle/180*Math.PI);
       this.turtleY = cy - radius*Math.sin(Math.PI + perp - angle/180*Math.PI);
    }
    if (Math.abs(angle) < 360 && this.turtleIsDrawing) {
       OSG.strokeStyle = this.color;
       cx = (cx+10)/20*canvas.width;
       cy = (1 - (cy+10)/20)*canvas.height;
       radius = radius/20 * canvas.width;
       angle = angle/180*Math.PI;
       OSG.beginPath();
       if (radius > 0) {
          OSG.arc(cx,cy,radius,Math.PI-perp,Math.PI-perp-angle,angle>0);
       }
       else {
          OSG.arc(cx,cy,-radius,Math.PI-perp,Math.PI-perp+angle,angle<0);
       }
       OSG.stroke();
    }
};
Turtle.prototype.circle = function(radius) {
    if (!this.turtleIsDrawing)
        return;
    var perp =  (radius > 0 ? this.turtleHeading + 90 : this.turtleHeading - 90)/180 * Math.PI;
    radius = Math.abs(radius);
    var cx = this.turtleX + Math.cos(perp)*radius;
    var cy = this.turtleY + Math.sin(perp)*radius;
    cx = (cx+10)/20 * canvas.width;
    cy = (1-(cy+10)/20)*canvas.height;
    radius = Math.abs(radius)/20 * canvas.width;
    OSG.beginPath();
    OSG.arc(cx,cy,radius,0,Math.PI*2);
    OSG.strokeStyle = this.color;
    OSG.stroke();
}
Turtle.prototype.text = function(str) {
    var a = (this.turtleX+10)/20 * canvas.width;
    var b = (1-(this.turtleY+10)/20) * canvas.height;
    OSG.fillStyle = this.color;
    OSG.fillText(str,a,b);
    this.turtleY -= 20/canvas.height * 20;
};
Turtle.prototype.face = function(angle) {
   if (Math.abs(angle) > 180) {
    angle = angle % 360;
    if (angle > 180)
     angle = angle - 360;
    else if (angle < -180)
     angle = angle + 360;
   }
   proc.turtleHeading = angle;
};
Turtle.prototype.reinit = function(globalCt) {
  stackTop = globalCt;
  next = this;
  prev = this;
};
Turtle.prototype.push = function(x) {
   var loc = this.stackTop - this.stackStart;
   this.stack[loc] = x;
   this.stackTop++;
};
Turtle.prototype.pop = function() {
   this.stackTop--;
   var loc = this.stackTop - this.stackStart;
   if (loc < 0)
      throw new TError("Internal xTurtle error! Attempt to pop past process start.",0);
   return this.stack[loc];
};
Turtle.prototype.store = function(offset, x) {
 if (offset <= 0)
   offset = -offset;
 else
   offset = this.stackRef + offset;
 var proc = this;
 while (offset < proc.stackStart)
   proc = proc.parent;
 var loc = offset - proc.stackStart;
 proc.stack[loc] = x;
};
Turtle.prototype.fetch = function(offset) {
 if (offset <= 0)
   offset = -offset;
 else
   offset = this.stackRef + offset;
 var proc = this;
 while (offset < proc.stackStart)
   proc = proc.parent;
 var loc = offset - proc.stackStart;
 return proc.stack[loc];
};

function doDraw() {
   graphics.drawImage(OSC,0,0);
   if (activeProcessList && ! alwaysHideTurtles) {
      var first = activeProcessList;
      var turtle = activeProcessList;
      do {
         turtle.draw();
         turtle = turtle.next;
      } while (turtle != first);
   }
}

//-------------------------- Programs ----------------------------------

function TProgram() {
  this.ins = [];
  this.data = [];
  this.pos = [];
  this.constantStore = [];
  this.stringStore = [];
  this.insCt = 0;
  this.stringCt = 0;
  this.constantCt = 0;
  this.globalOffsetCt = 0;
  this.appendStart = 0;
  this.GrabCount = 0;
}
TProgram.prototype.addInstruction = function(/*int*/ insCode, /*int*/ dataVal, /*int*/ position) {
  this.ins.push(insCode);
  this.data.push(dataVal);
  this.pos.push(position);
  this.insCt++;
};
TProgram.prototype.setInsCt = function(ct) {
    this.insCt = ct;
    this.ins.length = ct;
    this.data.length = ct;
    this.pos.length = ct;
};
TProgram.prototype.addString = function(str) {
  this.stringStore.push(str);
  this.stringCt++;
  return this.stringCt - 1;
};
TProgram.prototype.addConstant = function(val) {
  for (let i = 0; i < this.constantCt; i++)
     if (val == this.constantStore[i])
        return i;
  this.constantStore.push(val);
  this.constantCt++;
  return this.constantCt - 1;
};

//----------------------------- Parsing ---------------------------------------

function TTokenizer( /* string */ data, /* TSymbolTable */ ST) {
   this.data = data;
   this.ST = ST;
   this.pos = 0;
   this.NextTok = null;
   this.tokenReady = false;
}
TTokenizer.prototype.NextCh = function() {
  if (this.pos >= this.data.length)
     return String.fromCharCode(0);
  else
     return this.data.charAt(this.pos);
};
TTokenizer.prototype.GetCh = function() {
  if (this.pos >= this.data.length)
     return String.fromCharCode(0);
  else {
     var ch = this.data.charAt(this.pos);
     this.pos++;
     return ch;
  }
};
TTokenizer.prototype.Skip = function() {
   var nesting = 0;
   var start = 0;
   var ch = this.NextCh();
   while (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' || ch == '{') {
     this.pos++;
     if (ch == '{') {
       nesting = 1;
       start = this.pos;
       do {
          ch = this.GetCh();
          if (ch == '{')
             nesting++;
          else if (ch == '}')
             nesting--;
          else if (ch == '\x00')
             throw new TError("End of program occurred before matching '}' found for this comment.", start);
       } while (nesting != 0);
     }
     ch = this.NextCh();
   }
};
TTokenizer.prototype.ReadWord = function() {
   var name = "";
   var ch = this.NextCh();
   while (ch.match(/[a-zA-Z0-9_]/)) {
     ch = this.GetCh();
     if (ch >='A' && ch <= 'Z')
        ch = ch.toLowerCase();
     name += ch;
     ch = this.NextCh();
   }
   var loc = this.ST.findSymbol(name);
   if (loc == -1) {
     this.NextTok = { name: name, kind: TTokenizer.undeclaredName_ };
     return;
   }
   var kind = this.ST.get(loc).kind;
   if (kind == TSymbolTable.keyWordSymb) {
      this.NextTok = { name: name, kind: this.ST.get(loc).token };
      return;
   }
   this.NextTok = { name: name, symbolLocation: loc };
   if (kind == TSymbolTable.variableSymb)
      this.NextTok.kind = TTokenizer.variableName_;
   else if (kind == TSymbolTable.paramSymb)
      this.NextTok.kind = TTokenizer.paramName_;
   else if (kind == TSymbolTable.subSymb)
      this.NextTok.kind = TTokenizer.subName_;
   else if (kind == TSymbolTable.functionSymb)
      this.NextTok.kind = TTokenizer.functionName_;
   else if (kind == TSymbolTable.refParamSymb)
      this.NextTok.kind = TTokenizer.refParamName_;
};
TTokenizer.prototype.ReadString = function() {
   var ch = this.GetCh();
   var str = "";
   ch = this.GetCh();
   var done = false;
   do {
    if (ch == '"' && this.NextCh() == '"')
     ch = this.GetCh();
    else if (ch == '"')
     done = true;
    if (!done)
     if (ch == '\n' || ch == '\r')
        throw new TError("End-of-line occured inside a string.  String must be closed before end-of-line.", this.pos);
     else if (ch === '\x00')
        throw new TError("End of data found in the middle of a string.", this.pos);
     else {
        str += ch;
        ch = this.GetCh();
     }
   } while (!done);
   this.NextTok = { name: "<a string>", kind: TTokenizer.string_, str: str };
};
TTokenizer.prototype.ReadNumber = function() {
   var s = "";
   while (this.NextCh().match(/[0-9]/))
      s += this.GetCh();
   if (this.NextCh() == '.') {
      s += this.GetCh();
      while (this.NextCh().match(/[0-9]/))
        s += this.GetCh();
   }
   if (this.NextCh() == 'e' || this.NextCh() == 'E') {
     s += this.GetCh();
     if (this.NextCh() == '+' || this.NextCh() == '-') 
       s += this.GetCh();
     if ( ! this.NextCh().match(/[0-9]/) )
       throw new TError("Illegal number '" + s + "' encountered in program.", this.pos);
     while (this.NextCh().match(/[0-9]/))
       s += this.GetCh();
   }
   var d = parseFloat(s);
   if (isNaN(d) || !isFinite(d))
      throw new TError("Illegal number '" + s + "' encountered in program.", this.pos);
   this.NextTok = { name: "<a constant>", kind: TTokenizer.number_, value: d };
};
TTokenizer.prototype.ReadPunctuation = function() {
   var ch = this.GetCh();
   this.NextTok = { name: ch };
   switch (ch) {
    case '(': 
       this.NextTok.kind = TTokenizer.leftParen_;
       break;
    case ')': 
       this.NextTok.kind = TTokenizer.rightParen_;
       break;
    case ':': 
       if (this.NextCh() == '=') {
         this.NextTok.kind = TTokenizer.assign_;
         ch = this.GetCh();
         this.NextTok.name = ":=";
       }
       else
         this.NextTok.kind = TTokenizer.colon_;
       break;
    case ',': 
       this.NextTok.kind = TTokenizer.comma_;
       break;
    case '+': 
       this.NextTok.kind = TTokenizer.plus_;
       break;
    case '-': 
       this.NextTok.kind = TTokenizer.minus_;
       break;
    case '*': 
       this.NextTok.kind = TTokenizer.times_;
       break;
    case '/': 
       this.NextTok.kind = TTokenizer.divide_;
       break;
    case '^': 
       this.NextTok.kind = TTokenizer.power_;
       break;
    case '>':
       ch = this.NextCh();
       if (ch == '=' || ch == '>' || ch == '<') {
          ch = this.GetCh();
          if (ch == '=')
             this.NextTok.kind = TTokenizer.GE_;
          else if (ch == '<')
             this.NextTok.kind = TTokenizer.NE_;
          else
             throw new TError(">> is not a legal operator.",this.pos);
          this.NextTok.name += ch;
       }
       else
          this.NextTok.kind = TTokenizer.GT_;    
       break;
    case '<':
       ch = this.NextCh();
       if (ch == '=' || ch == '>' || ch == '<') {
          ch = this.GetCh();
          if (ch == '=')
             this.NextTok.kind = TTokenizer.LE_;
          else if (ch == '>')
             this.NextTok.kind = TTokenizer.NE_;
          else
             throw new TError("<< is not a legal operator.",this.pos);
          this.NextTok.name += ch;
       }
       else
          this.NextTok.kind = TTokenizer.LT_;    
       break;
    case '=':
       ch = this.NextCh();
       if (ch == '=' || ch == '>' || ch == '<') {
          ch = this.GetCh();
          if (ch == '<')
             this.NextTok.kind = TTokenizer.LE_;
          else if (ch == '>')
             this.NextTok.kind = TTokenizer.GE_;
          else
             throw new TError("== is not a legal operator.", this.pos);
          this.NextTok.name += ch;
       }
       else
          this.NextTok.kind = TTokenizer.EQ_;    
       break;
    case '&': 
       this.NextTok.kind = TTokenizer.and_;
       break;
    case '|': 
       this.NextTok.kind = TTokenizer.or_;
       break;
    case '~': 
       this.NextTok.kind = TTokenizer.not_;
       break;
    default:
       throw new TError("Illegal character '" + ch + "' found in input.", this.pos);
   }
};
TTokenizer.prototype.ReadToken = function() {
   this.Skip();
   var ch = this.NextCh();
   if (ch === '\x00') {
      this.NextTok = { kind: TTokenizer.endOfData_ };
   }
   else if (ch.match(/[a-zA-Z_]/)) {
     this.ReadWord();
     if (this.NextTok.kind == TTokenizer.end_) {
       this.Skip();
       if (this.NextCh().match(/[a-zA-Z]/)) {
         this.ReadWord();
         if (this.NextTok.kind == TTokenizer.if_) {
            this.NextTok.kind = TTokenizer.endif_;
            this.NextTok.name = "ENDIF";
         }
         else if (this.NextTok.kind == TTokenizer.loop_) {
            this.NextTok.kind = TTokenizer.endloop_;
            this.NextTok.name = "ENDLOOP";
         }
         else if (this.NextTok.kind == TTokenizer.sub_) {
            this.NextTok.kind = TTokenizer.endsub_;
            this.NextTok.name = "ENDSUB";
         }
         else if (this.NextTok.kind == TTokenizer.function_) {
            this.NextTok.kind = TTokenizer.endfunction_;
            this.NextTok.name = "ENDFUNCTION";
         }
         else if (this.NextTok.kind == TTokenizer.Grab_) {
            this.NextTok.kind = TTokenizer.endGrab_;
            this.NextTok.name = "ENDGRAB";
         }
         else
            throw new TError("The word 'END' can only be used in combinations like 'END IF' and 'END SUB'.", this.pos);
       }
       else
          throw new TError("The word 'END' can only be used in combinations like 'END IF' and 'END SUB'.", this.pos);
     }
     else if (this.NextTok.kind == TTokenizer.exit_) {
        this.Skip();
        let savePos = this.pos; 
        if (this.NextCh().match(/[a-zA-Z]/)) {
           this.ReadWord(); 
           if (this.NextTok.kind == TTokenizer.if_) {
              this.NextTok.kind = TTokenizer.exitif_;
              this.NextTok.name = "EXITIF";
           }
           else if (this.NextTok.kind == TTokenizer.unless_) {
              this.NextTok.kind = TTokenizer.exitunless_;
              this.NextTok.name = "EXITUNLESS";
          }
          else {
             this.NextTok.kind = TTokenizer.exit_;
             this.NextTok.name = "EXIT";
             this.pos = savePos;
          }
       }
       else
          this.pos = savePos;
     }
     else if (this.NextTok.kind == TTokenizer.or_) {
       let savePos = this.pos;
       this.Skip();
       if (this.NextCh().match(/[a-zA-Z]/)) {
          this.ReadWord();
          if (this.NextTok.kind == TTokenizer.if_) {
             this.NextTok.kind = TTokenizer.elseif_;
             this.NextTok.name = "ORIF";
          }
          else {
             this.NextTok.kind = TTokenizer.or_;
             this.NextTok.name = "OR";
             this.pos = savePos;
          }
       }
       else
          this.pos = savePos;
     }
   }
   else if (ch.match(/[0-9.]/))
      this.ReadNumber();
   else if (ch == '"') 
      this.ReadString();
   else 
      this.ReadPunctuation();
   this.NextTok.position = this.pos;
   this.tokenReady = true;
};
TTokenizer.prototype.LookToken = function() {
   if (!this.tokenReady)
     this.ReadToken();
   return this.NextTok;
};
TTokenizer.prototype.GetToken = function() {
   var tok = this.LookToken();
   this.tokenReady = false;
   return tok;
};
TTokenizer.Jump_ = 1;   // subs with zero params
TTokenizer.JumpToSubroutine_ = 2; 
TTokenizer.SubroutineSetup_ = 3; 
TTokenizer.FunctionSetup_ = 4; 
TTokenizer.AdjustSavedPC_ = 5; 
TTokenizer.SetStackRef_ = 6; 
TTokenizer.Reserve_ = 7 ;
TTokenizer.TellUser_ = 8; 
TTokenizer.DrawText_ = 9;
TTokenizer.HideTurtle_ = 10; 
TTokenizer.ShowTurtle_ = 11; 
TTokenizer.Clear_ = 12;
TTokenizer.Home_ = 13;
TTokenizer.PenUp_ = 14; 
TTokenizer.PenDown_ = 15; 
TTokenizer.Fill_ = 16; 
TTokenizer.Halt_ = 17; 
TTokenizer.Grab_ = 18; 
TTokenizer.endGrab_ = 19;
TTokenizer.return_ = 20; 
TTokenizer.returnFromFunction_ = 21;
TTokenizer.red_ = 22;
TTokenizer.blue_ = 23;
TTokenizer.green_ = 24;
TTokenizer.cyan_ = 25;
TTokenizer.magenta_ = 26;
TTokenizer.yellow_ = 27;
TTokenizer.gray_ = 28;
TTokenizer.lightGray_ = 29;
TTokenizer.darkGray_ = 30;
TTokenizer.black_ = 31;
TTokenizer.white_ = 32;
TTokenizer.Die_ = 33;
TTokenizer.Fork_ = 34;  // subs with one param
TTokenizer.JumpIf_ = 35; 
TTokenizer.AskUser_ = 36; 
TTokenizer.YesOrNo_ = 37; 
TTokenizer.Pop_ = 38; 
TTokenizer.PopRefParam_ = 39; 
TTokenizer.PopFunctionValue_ = 40;
TTokenizer.Forward_ = 41; 
TTokenizer.Back_ = 42; 
TTokenizer.Turn_ = 43; 
TTokenizer.Face_ = 44; 
TTokenizer.Circle_ = 45;
TTokenizer.Move_ = 46;  // subs with two params 
TTokenizer.MoveTo_ = 47; 
TTokenizer.Arc_ = 48;
TTokenizer.rgb_ = 49;  // with three params
TTokenizer.hsb_ = 50; 
TTokenizer.Push_ = 51; // functions with 0 params
TTokenizer.PushRefParam_ = 52; 
TTokenizer.PushAbsoluteReference_ = 53; 
TTokenizer.PushConstant_ = 54; 
TTokenizer.PushDummy_ = 55; 
TTokenizer.Random_ = 56; 
TTokenizer.turtleX_ = 57; 
TTokenizer.turtleY_ = 58; 
TTokenizer.turtleHeading_ = 59; 
TTokenizer.TurtleIsVisible_ = 60; 
TTokenizer.TurtleIsDrawing_ = 61;
TTokenizer.forkNumber_ = 62;
TTokenizer.sin_ = 63; // functions with one param
TTokenizer.cos_ = 64; 
TTokenizer.tan_ = 65; 
TTokenizer.sec_ = 66; 
TTokenizer.cot_ = 67; 
TTokenizer.csc_ = 68; 
TTokenizer.arctan_ = 69; 
TTokenizer.arcsin_ = 70; 
TTokenizer.arccos_ = 71; 
TTokenizer.not_ = 72;
TTokenizer.abs_ = 73; 
TTokenizer.sqrt_ = 74; 
TTokenizer.exp_ = 75; 
TTokenizer.ln_ = 76; 
TTokenizer.round_ = 77; 
TTokenizer.trunc_ = 78; 
TTokenizer.RandomInt_ = 79; 
TTokenizer.UnaryMinus_ = 80;
TTokenizer.plus_ = 81; // functions with two params
TTokenizer.minus_ = 82; 
TTokenizer.times_ = 83; 
TTokenizer.divide_ = 84; 
TTokenizer.power_ = 85;
TTokenizer.and_ = 86; 
TTokenizer.or_ = 87; 
TTokenizer.LT_ = 88; 
TTokenizer.GT_ = 89; 
TTokenizer.LE_ = 90; 
TTokenizer.GE_ = 91; 
TTokenizer.NE_ = 92; 
TTokenizer.EQ_ = 93; 
TTokenizer.leftParen_ = 94; // Other tokens; not commands 
TTokenizer.rightParen_ = 95; 
TTokenizer.colon_ = 96; 
TTokenizer.assign_ = 97; 
TTokenizer.comma_ = 98;
TTokenizer.if_ = 99; 
TTokenizer.then_ = 100; 
TTokenizer.else_ = 101; 
TTokenizer.elseif_ = 102; 
TTokenizer.endif_ = 103; 
TTokenizer.end_ = 104;
TTokenizer.loop_ = 105; 
TTokenizer.endloop_ = 106; 
TTokenizer.exit_ = 107; 
TTokenizer.exitif_ = 108; 
TTokenizer.unless_ = 109; 
TTokenizer.exitunless_ = 110;
TTokenizer.sub_ = 111; 
TTokenizer.endsub_ = 112;
TTokenizer.function_ = 113; 
TTokenizer.endfunction_ = 114; 
TTokenizer.ref_ = 115;
TTokenizer.declare_ = 116; 
TTokenizer.predeclare_ = 117; 
TTokenizer.import_ = 118;
TTokenizer.variableName_ = 119; // tokens with values 
TTokenizer.paramName_ = 120; 
TTokenizer.refParamName_ = 121; 
TTokenizer.subName_ = 122; 
TTokenizer.functionName_ = 123; 
TTokenizer.undeclaredName_ = 124; 
TTokenizer.number_ = 125; 
TTokenizer.string_ = 126; 
TTokenizer.endOfData_ = 127;

function TSymbolTable() {
   this.symbolSearchStart = 0;
   this.symbols = [
      {  name: "red", kind: TSymbolTable.keyWordSymb, token: TTokenizer.red_ },
      {  name: "green", kind: TSymbolTable.keyWordSymb, token: TTokenizer.green_ },
      {  name: "blue", kind: TSymbolTable.keyWordSymb, token: TTokenizer.blue_ },
      {  name: "cyan", kind: TSymbolTable.keyWordSymb, token: TTokenizer.cyan_ },
      {  name: "magenta", kind: TSymbolTable.keyWordSymb, token: TTokenizer.magenta_ },
      {  name: "yellow", kind: TSymbolTable.keyWordSymb, token: TTokenizer.yellow_ },
      {  name: "black", kind: TSymbolTable.keyWordSymb, token: TTokenizer.black_ },
      {  name: "white", kind: TSymbolTable.keyWordSymb, token: TTokenizer.white_ },
      {  name: "gray", kind: TSymbolTable.keyWordSymb, token: TTokenizer.gray_ },
      {  name: "lightgray", kind: TSymbolTable.keyWordSymb, token: TTokenizer.lightGray_ },
      {  name: "darkgray", kind: TSymbolTable.keyWordSymb, token: TTokenizer.darkGray_ },
      {  name: "rgb", kind: TSymbolTable.keyWordSymb, token: TTokenizer.rgb_ },
      {  name: "hsb", kind: TSymbolTable.keyWordSymb, token: TTokenizer.hsb_ },
      {  name: "hideturtle", kind: TSymbolTable.keyWordSymb, token: TTokenizer.HideTurtle_ },
      {  name: "showturtle", kind: TSymbolTable.keyWordSymb, token: TTokenizer.ShowTurtle_ },
      {  name: "clear", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Clear_ },
      {  name: "home", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Home_ },
      {  name: "penup", kind: TSymbolTable.keyWordSymb, token: TTokenizer.PenUp_ },
      {  name: "pendown", kind: TSymbolTable.keyWordSymb, token: TTokenizer.PenDown_ },
      {  name: "telluser", kind: TSymbolTable.keyWordSymb, token: TTokenizer.TellUser_ },
      {  name: "askuser", kind: TSymbolTable.keyWordSymb, token: TTokenizer.AskUser_ },
      {  name: "yesorno", kind: TSymbolTable.keyWordSymb, token: TTokenizer.YesOrNo_ },
      {  name: "drawtext", kind: TSymbolTable.keyWordSymb, token: TTokenizer.DrawText_ },
      {  name: "fork", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Fork_ },
      {  name: "halt", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Halt_ },
      {  name: "killprocess", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Die_ },
      {  name: "forward", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Forward_ },
      {  name: "back", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Back_ },
      {  name: "turn", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Turn_ },
      {  name: "face", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Face_ },
      {  name: "circle", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Circle_ },
      {  name: "move", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Move_ },
      {  name: "moveto", kind: TSymbolTable.keyWordSymb, token: TTokenizer.MoveTo_ },
      {  name: "arc", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Arc_ },
      {  name: "random", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Random_ },
      {  name: "xcoord", kind: TSymbolTable.keyWordSymb, token: TTokenizer.turtleX_ },
      {  name: "ycoord", kind: TSymbolTable.keyWordSymb, token: TTokenizer.turtleY_ },
      {  name: "heading", kind: TSymbolTable.keyWordSymb, token: TTokenizer.turtleHeading_ },
      {  name: "isvisible", kind: TSymbolTable.keyWordSymb, token: TTokenizer.TurtleIsVisible_ },
      {  name: "isdrawing", kind: TSymbolTable.keyWordSymb, token: TTokenizer.TurtleIsDrawing_ },
      {  name: "forknumber", kind: TSymbolTable.keyWordSymb, token: TTokenizer.forkNumber_ },
      {  name: "sin", kind: TSymbolTable.keyWordSymb, token: TTokenizer.sin_ },
      {  name: "cos", kind: TSymbolTable.keyWordSymb, token: TTokenizer.cos_ },
      {  name: "tan", kind: TSymbolTable.keyWordSymb, token: TTokenizer.tan_ },
      {  name: "sec", kind: TSymbolTable.keyWordSymb, token: TTokenizer.sec_ },
      {  name: "cot", kind: TSymbolTable.keyWordSymb, token: TTokenizer.cot_ },
      {  name: "csc", kind: TSymbolTable.keyWordSymb, token: TTokenizer.csc_ },
      {  name: "arctan", kind: TSymbolTable.keyWordSymb, token: TTokenizer.arctan_ },
      {  name: "arcsin", kind: TSymbolTable.keyWordSymb, token: TTokenizer.arcsin_ },
      {  name: "arccos", kind: TSymbolTable.keyWordSymb, token: TTokenizer.arccos_ },
      {  name: "abs", kind: TSymbolTable.keyWordSymb, token: TTokenizer.abs_ },
      {  name: "sqrt", kind: TSymbolTable.keyWordSymb, token: TTokenizer.sqrt_ },
      {  name: "exp", kind: TSymbolTable.keyWordSymb, token: TTokenizer.exp_ },
      {  name: "ln", kind: TSymbolTable.keyWordSymb, token: TTokenizer.ln_ },
      {  name: "round", kind: TSymbolTable.keyWordSymb, token: TTokenizer.round_ },
      {  name: "trunc", kind: TSymbolTable.keyWordSymb, token: TTokenizer.trunc_ },
      {  name: "randomint", kind: TSymbolTable.keyWordSymb, token: TTokenizer.RandomInt_ },
      {  name: "and", kind: TSymbolTable.keyWordSymb, token: TTokenizer.and_ },
      {  name: "or", kind: TSymbolTable.keyWordSymb, token: TTokenizer.or_ },
      {  name: "not", kind: TSymbolTable.keyWordSymb, token: TTokenizer.not_ },
      {  name: "if", kind: TSymbolTable.keyWordSymb, token: TTokenizer.if_ },
      {  name: "then", kind: TSymbolTable.keyWordSymb, token: TTokenizer.then_ },
      {  name: "else", kind: TSymbolTable.keyWordSymb, token: TTokenizer.else_ },
      {  name: "orif", kind: TSymbolTable.keyWordSymb, token: TTokenizer.elseif_ },
      {  name: "endif", kind: TSymbolTable.keyWordSymb, token: TTokenizer.endif_ },
      {  name: "end", kind: TSymbolTable.keyWordSymb, token: TTokenizer.end_ },
      {  name: "loop", kind: TSymbolTable.keyWordSymb, token: TTokenizer.loop_ },
      {  name: "endloop", kind: TSymbolTable.keyWordSymb, token: TTokenizer.endloop_ },
      {  name: "exit", kind: TSymbolTable.keyWordSymb, token: TTokenizer.exit_ },
      {  name: "exitif", kind: TSymbolTable.keyWordSymb, token: TTokenizer.exitif_ },
      {  name: "exitunless", kind: TSymbolTable.keyWordSymb, token: TTokenizer.exitunless_ },
      {  name: "unless", kind: TSymbolTable.keyWordSymb, token: TTokenizer.unless_ },
      {  name: "sub", kind: TSymbolTable.keyWordSymb, token: TTokenizer.sub_ },
      {  name: "endsub", kind: TSymbolTable.keyWordSymb, token: TTokenizer.endsub_ },
      {  name: "function", kind: TSymbolTable.keyWordSymb, token: TTokenizer.function_ },
      {  name: "endfunction", kind: TSymbolTable.keyWordSymb, token: TTokenizer.endfunction_ },
      {  name: "return", kind: TSymbolTable.keyWordSymb, token: TTokenizer.return_ },
      {  name: "ref", kind: TSymbolTable.keyWordSymb, token: TTokenizer.ref_ },
      {  name: "declare", kind: TSymbolTable.keyWordSymb, token: TTokenizer.declare_ },
      {  name: "predeclare", kind: TSymbolTable.keyWordSymb, token: TTokenizer.predeclare_ },
      {  name: "import", kind: TSymbolTable.keyWordSymb, token: TTokenizer.import_ },
      {  name: "grab", kind: TSymbolTable.keyWordSymb, token: TTokenizer.Grab_ },
      {  name: "endgrab", kind: TSymbolTable.keyWordSymb, token: TTokenizer.endGrab_ }
   ];
}
TSymbolTable.prototype.addSymbol = function( /*int*/ kind, /*String*/ name) {  // returns int
   var sym = { name: name, kind: kind };
   if ( kind == TSymbolTable.refParamSymb || kind == TSymbolTable.paramSymb || kind == TSymbolTable.variableSymb ) {
       sym.grabNum = -1;
       sym.trueSymbolLoc = this.symbols.length;
   }
   this.symbols.push(sym);
   return this.symbols.length - 1;
};
TSymbolTable.prototype.get = function(loc) {
      return this.symbols[loc];
};
TSymbolTable.prototype.setSubroutineData = function (/*int*/ loc,
          /*int*/ start,
          /*int*/ paramCount,
          /*int representing BitSet*/ paramTypes) {
   var sym = this.symbols[loc];
   sym.start = start;
   sym.paramCount = paramCount;
   sym.paramTypes = paramTypes;
};
TSymbolTable.prototype.setVariableData = function (/*int*/ loc, /*int*/ offset) {
   var sym = this.symbols[loc];
   sym.offset = offset;
};
TSymbolTable.prototype.findSymbol = function (/*String*/ name) {
   for (let i = this.symbols.length - 1; i >= 0; i--) {
      var sym = this.symbols[i];
      if (sym.name == name && (i >= this.symbolSearchStart || 
                sym.kind == TSymbolTable.keyWordSymb || sym.kind == TSymbolTable.subSymb || sym.kind == TSymbolTable.functionSymb)) {
         return i;
      }
   }
   return -1;
};
TSymbolTable.prototype.findGlobalSymbol = function (/*String*/ name) {
   for (let i = 0; i < this.symbols.length; i++) {
      if (this.symbols[i].name == name) {
         return i;
      }
   }
   return -1;
};
TSymbolTable.prototype.startSubroutineSymbols = function() {
   this.symbolSearchStart = this.symbols.length;
};
TSymbolTable.prototype.endSubroutineSymbols = function() {
   this.symbols.length = this.symbolSearchStart;
   this.symbolSearchStart = 0;
};
TSymbolTable.prototype.checkPredeclarations = function() {
   for (let i = 0; i < this.symbols.length; i++) {
      var sym = this.symbols[i];
      if ( (sym.kind == TSymbolTable.subSymb || sym.kind == TSymbolTable.functionSymb) &&
                       (sym.paramTypes & (1 << 31)) != 0 )
         return i;
   }
   return -1;
};
TSymbolTable.undefinedSymb = 0;
TSymbolTable.keyWordSymb = 1;
TSymbolTable.subSymb = 2;
TSymbolTable.functionSymb = 3;
TSymbolTable.variableSymb = 4; 
TSymbolTable.paramSymb = 5;
TSymbolTable.refParamSymb = 6;

var parser = (function() {
   var /*TTokenizer*/ tokenizer;
   var /*TProgram*/ prog;
   var /*TSymbolTable*/ ST;
   var /*int*/ saveGlobalOffsetCt;
   var /*int*/ saveSymbolCt;
   var /*int*/ saveInsCt;
   var /*boolean*/ parsingSubroutine, parsingFunction, returnFound;
   var /*int*/ offsetCt;
   var /*int*/ currentLoopLoc;
   var /*int*/ grabBeingParsed;
   function Error(message) {
     ST.symbols.length = saveSymbolCt;
     prog.globalOffsetCt = saveGlobalOffsetCt;
     prog.setInsCt(saveInsCt);
     var pos = tokenizer.pos;
     tokenizer = null;
     prog = null;
     ST = null;
     throw new TError(message, pos);
   }
   function doParse() {
      var /*TToken*/ tok;
      var /*int*/ undeclared;
      saveGlobalOffsetCt = prog.globalOffsetCt;
      saveSymbolCt = ST.symbols.length;
      ST.symbolSearchStart = 0;
      currentLoopLoc = -1;
      parsingSubroutine = false;
      parsingFunction = false;
      grabBeingParsed = 0;
      do {
       tok = tokenizer.LookToken();
       if (tok.kind == TTokenizer.sub_ || tok.kind == TTokenizer.function_)
         ParseSubroutine();
       else if (tok.kind == TTokenizer.endloop_ ||
                tok.kind ==  TTokenizer.endif_ ||
                tok.kind ==  TTokenizer.endsub_ ||
                tok.kind ==  TTokenizer.endfunction_ ||
                tok.kind ==  TTokenizer.else_ || 
                tok.kind == TTokenizer.elseif_)
        Error("Expecting a statement or declaration.  (CheckNesting)");
       else if (tok.kind == TTokenizer.predeclare_)
        ParseForwardDeclaration();
       else if (tok.kind != TTokenizer.endOfData_)
        ParseStatement();
      } while (tok.kind != TTokenizer.endOfData_);
      prog.addInstruction(TTokenizer.Die_, 0, tokenizer.pos);
      undeclared = ST.checkPredeclarations();
      if (undeclared != -1) {
       var sym = ST.symbols[undeclared];
       if (sym.kind == TSymbolTable.subSymb)
        Error("The predeclared subroutine, '" + sym.name+ "', has never actually been declared.");
       else
        Error("The predeclared function, '" + sym.name+ "', has never actually been declared.");
      }
      prog.appendStart = saveInsCt;
   }
   function ParseDeclaration() {
       var /*TToken*/ firstTok, tok;
       var /*boolean*/ done;
       var /*int*/ loc, offset;
       var /*int*/ skind; // SymbolKinds
       var /*String*/ name;
       var /*int*/ trueSymbolLoc;
       if (grabBeingParsed > 0)
          Error("Declarations cannot occur inside GRAB statements.");
       firstTok = tokenizer.GetToken();
       if (firstTok.kind == TTokenizer.import_ && !(parsingSubroutine || parsingFunction))
        Error("An import statement can only occur in a subroutine or function definition.");
       done = false;
       do {
            tok = tokenizer.GetToken();
            if (tok.kind == TTokenizer.endOfData_)
             Error("Enexpected end of data while reading the list of items for a declaration statemet.");
            else if (tok.kind == TTokenizer.string_ || tok.kind == TTokenizer.number_ || (tok.kind >= TTokenizer.leftParen_ && tok.kind <= TTokenizer.comma_))
             Error("An unexpected illegal item '" + tok.name + "' found in list of items being declared.");
            else if (tok.kind < TTokenizer.variableName_)
             Error("'" +  tok.name + "' is a reserved word.  A reserved word can't be redefined.");
            else if ((tok.kind == TTokenizer.subName_ || tok.kind == TTokenizer.functionName_) && !(parsingSubroutine || parsingFunction))
             Error("The identifier '" + tok.name + "' has already been defined as a subroutine or function name.");
            else if ((tok.kind == TTokenizer.subName_ || tok.kind == TTokenizer.functionName_) && (firstTok.kind == TTokenizer.import_))
             Error("Subroutines and functions do not need to be imported to be used.");
            else if (tok.kind == TTokenizer.paramName_ || tok.kind == TTokenizer.variableName_ || tok.kind == TTokenizer.refParamName_) {
               if (parsingSubroutine || parsingFunction)
                 Error("The Identifier '" + tok.name + "' is already defined in this subroutine.");
               else
                 Error("The Identifier '" + tok.name + "' is already defined.");
            }
            else if (tok.kind == TTokenizer.endOfData_)
             Error("Unexpected end of data while reading the list of items for a declaration statement.");
            else if (!(tok.kind == TTokenizer.undeclaredName_ || tok.kind == TTokenizer.subName_ || tok.kind == TTokenizer.functionName_))
             Error("An unexpected illegal item '" + tok.name + "' found in list of items being declared.");
            if (firstTok.kind == TTokenizer.declare_) {
                 if (parsingSubroutine || parsingFunction) {
                  offsetCt++;
                  offset = offsetCt;
                 }
                 else {
                  offset = -prog.globalOffsetCt;
                  prog.globalOffsetCt++;
                 }
                 if (tok.kind == TTokenizer.undeclaredName_) 
                  loc = ST.addSymbol(TSymbolTable.variableSymb, tok.name);
                 else {
                  loc = tok.symbolLocation;
                  name = ST.symbols[loc].name;
                  loc = ST.addSymbol(TSymbolTable.variableSymb, name);
                 }
                 ST.setVariableData(loc, offset);
                 prog.addInstruction(TTokenizer.PushDummy_, 0, tokenizer.pos);
            }
            else {
              loc = ST.findGlobalSymbol(tok.name);
              if (loc == -1) 
                Error("'" + tok.name + "' cannot be imported because it is undefined.  Only global variables can be imported.");
              skind = ST.get(loc).kind;
              if (skind != TSymbolTable.variableSymb)
               Error("The identifier, '" + tok.name + "', is not a global variable.  Only global variables can be imported.");
              offset = ST.get(loc).offset;
              trueSymbolLoc = loc;
              loc = ST.addSymbol(TSymbolTable.variableSymb, tok.name);
              ST.setVariableData(loc, offset);
              ST.get(loc).trueSymbolLoc = trueSymbolLoc;
            }
            tok = tokenizer.LookToken();
            if (tok.kind != TTokenizer.comma_)
             done = true;
            else
             tok = tokenizer.GetToken();
       } while (!done);
   }
   function ParseFunctionCall (/*int*/ symbLoc) {
      var /*int*/ paramCt;
      var /*BitSet*/ paramTypes;
      var /*String*/ name;
      prog.addInstruction(TTokenizer.FunctionSetup_, 0, tokenizer.pos);
      paramCt = ST.get(symbLoc).paramCount;
      paramTypes = ST.get(symbLoc).paramTypes;
      name = ST.get(symbLoc).name;
      ParseActualParams(paramCt, paramTypes, name);
      prog.addInstruction(TTokenizer.AdjustSavedPC_, paramCt, tokenizer.pos);
      prog.addInstruction(TTokenizer.JumpToSubroutine_, ST.get(symbLoc).start, tokenizer.pos);
   }
   function ParsePrimary() {
      var /*boolean*/ logical;
      var /*TToken*/ tok;
      tok = tokenizer.GetToken();
      logical = false;
      switch (tok.kind) {
       case TTokenizer.leftParen_:
         logical = ParseExpression();
         tok = tokenizer.GetToken();
         if (tok.kind != TTokenizer.rightParen_)
           Error("Found '" +  tok.name + "' while expecting right parenthesis to match previous left parenthesis.");
         break;
       case TTokenizer.functionName_: 
         ParseFunctionCall(tok.symbolLocation);
         break;
       case TTokenizer.variableName_:
       case TTokenizer.paramName_: 
         prog.addInstruction(TTokenizer.Push_, ST.get(tok.symbolLocation).offset, tok.position);
         break;
       case TTokenizer.refParamName_: 
         prog.addInstruction(TTokenizer.PushRefParam_, ST.get(tok.symbolLocation).offset, tok.position);
         break;
       case TTokenizer.number_:
         prog.addInstruction(TTokenizer.PushConstant_, prog.addConstant(tok.value), tok.position);
         break;
       case TTokenizer.Random_:
       case TTokenizer.turtleX_:
       case TTokenizer.turtleY_:
       case TTokenizer.turtleHeading_:
       case TTokenizer.TurtleIsVisible_:
       case TTokenizer.TurtleIsDrawing_:
       case TTokenizer.forkNumber_:
         ParseActualParams(0, 0, tok.name);
         prog.addInstruction(tok.kind, 0, tok.position);
         break;
       case TTokenizer.sin_:
       case TTokenizer.cos_:
       case TTokenizer.tan_:
       case TTokenizer.sec_:
       case TTokenizer.cot_:
       case TTokenizer.csc_:
       case TTokenizer.arctan_:
       case TTokenizer.arcsin_:
       case TTokenizer.arccos_:
       case TTokenizer.abs_:
       case TTokenizer.sqrt_:
       case TTokenizer.exp_:
       case TTokenizer.ln_:
       case TTokenizer.round_:
       case TTokenizer.trunc_:
       case TTokenizer.RandomInt_:
         ParseActualParams(1, null, tok.name);
         prog.addInstruction(tok.kind, 0, tok.position);
         break;
       case TTokenizer.subName_: 
         Error("Subroutine '" + tok.name + "' found while reading an expression.  (Subroutine cannot be used like a function or variable.)");
         break;
       case TTokenizer.undeclaredName_: 
         Error("Undeclared identifier '" + tok.name + "' encountered in an expression.");
         break;
       case TTokenizer.endOfData_: 
         Error("Unexpected end of data encountered while reading an expression.");
         break;
       default:
         Error("Unexpected item '" + tok.name + "' found while reading an expression.");
      }
      return logical;
   }
   function ParseFactor (){
      var /*TToken*/ tok;
      var log2,logical;
      logical = ParsePrimary();
      tok = tokenizer.LookToken();
      while (tok.kind == TTokenizer.power_) {
        if (logical)
         Error("Power operator cannot be applied to logical values.");
        tok = tokenizer.GetToken();
        log2 = ParsePrimary();
        if (log2)
         Error("Power operator  cannot be applied to logical values.");
        prog.addInstruction(tok.kind, 0, tok.position);
        tok = tokenizer.LookToken();
      }
      return logical;
   }
   function ParseTerm () {
      var /*TToken*/ tok;
      var log2,logical;
      logical = ParseFactor();
      tok = tokenizer.LookToken();
      while (tok.kind == TTokenizer.times_ || tok.kind == TTokenizer.divide_) {
        if (logical)
         Error("Operation cannot be applied to logical values.");
        tok = tokenizer.GetToken();
        log2 = ParseFactor();
        if (log2)
         Error("Operation cannot be applied to logical values.");
        prog.addInstruction(tok.kind, 0, tok.position);
        tok = tokenizer.LookToken();
      }
      return logical;
   }
   function ParseExp () {
      var /*TToken*/ tok;
      var /*boolean*/ leadingMinus;
      var log2, logical;
      tok = tokenizer.LookToken();
      leadingMinus = (tok.kind == TTokenizer.minus_);
      if (tok.kind == TTokenizer.minus_ || tok.kind == TTokenizer.plus_)
       tok = tokenizer.GetToken();
      logical = ParseTerm();
      if (leadingMinus) {
        if (logical)
         Error("A minus sign cannot be applied to a logical value.");
        prog.addInstruction(TTokenizer.UnaryMinus_, 0, tok.position);
      }
      tok = tokenizer.LookToken();
      while (tok.kind == TTokenizer.minus_ || tok.kind == TTokenizer.plus_) {
        if (logical) 
         Error("Operation cannot be applied to logical values.");
        tok = tokenizer.GetToken();
        log2 = ParseTerm();
        if (log2) 
         Error("Operation cannot be applied to logical values.");
        prog.addInstruction(tok.kind, 0, tok.position);
        tok = tokenizer.LookToken();
      }
      return logical;
   }
   function ParseComparison () {
      var /*TToken*/ tok;
      var log2, logical;
      logical = ParseExp();
      tok = tokenizer.LookToken();
      if (tok.kind >= TTokenizer.LT_ && tok.kind <=TTokenizer.EQ_) {
        if (logical)
         Error("Comparison operator cannot be applied to a logical value.");
        tok = tokenizer.GetToken();
        log2 = ParseExp();
        if (log2)
         Error("Comparison operator cannot be applied to a logical value.");
        prog.addInstruction(tok.kind, 0, tok.position);
        tok = tokenizer.LookToken();
        if (tok.kind >= TTokenizer.LT_ && tok.kind <=TTokenizer.EQ_)
         Error("Sequences of comparison operators are not allowed.");
        logical = true;
      }
      return logical;
   }
   function ParseLFactor () {
      var /*int*/ notCt;
      var /*TToken*/ tok;
      var /*boolean*/ logical;
      notCt = 0;
      do {
       tok = tokenizer.LookToken();
       if (tok.kind == TTokenizer.not_) {
         notCt++;
         tok = tokenizer.GetToken();
       }
      } while (tok.kind == TTokenizer.not_);
      logical = ParseComparison();
      if (notCt > 0) {
        if (!logical) 
          Error("The operator NOT can only be applied to logical values.");
        if (notCt % 2 == 1)
          prog.addInstruction(TTokenizer.not_, 0, tok.position);
      }
      return logical;
   }
   function ParseLTerm () {
      var /*TToken*/ tok;
      var log2,logical;
      logical = ParseLFactor();
      tok = tokenizer.LookToken();
      while (tok.kind == TTokenizer.and_) {
        tok = tokenizer.GetToken();
        if (!logical)
         Error("The operator AND can only be applied to logical values.");
        log2 = ParseLTerm();
        if (!log2)
         Error("The operator AND can only be applied to logical values.");
        prog.addInstruction(TTokenizer.and_, 0, tok.position);
        tok = tokenizer.LookToken();
      }
      return logical;
   }
   function ParseExpression () {
     var /*TToken*/ tok;
     var /*boolean*/ logical,log2;
     logical = ParseLTerm();
     tok = tokenizer.LookToken();
     while (tok.kind == TTokenizer.or_) {
       tok = tokenizer.GetToken();
       if (!logical)
        Error("The operator OR can only be applied to logical values.");
       log2 = ParseLTerm();
       if (!log2)
        Error("The operator OR can only be applied to logical values.");
       prog.addInstruction(TTokenizer.or_, 0, tok.position);
       tok = tokenizer.LookToken();
     }
     return logical;
   }
   function ParseComputation() {
     var /*boolean*/ logical;
     logical = ParseExpression();
     if (logical)
      Error("Logical value not allowed here; numeric value or expression required.");
   }
   function ParseCondition() {
     var logical;
     logical = ParseExpression();
     if (!logical)
      Error("Numeric value not allowed here; logical value or expression required.");
   }
   function ParseAssignmentStatement() {
     var /*TToken*/ tok, asg;
     tok = tokenizer.GetToken();
     asg = tokenizer.GetToken();
     if (asg.kind != TTokenizer.assign_) {
       if (asg.kind == TTokenizer.leftParen_)
        Error("'" + tok.name + "' is a variable.  It looks like you are trying to use it as a subroutine.");
       else
        Error("Expected the assignment operator, :=, after variable name '" + tok.name + "'");
     }
     ParseComputation();
     if (tok.kind == TTokenizer.refParamName_)
       prog.addInstruction(TTokenizer.PopRefParam_, ST.get(tok.symbolLocation).offset, tok.position);
     else
       prog.addInstruction(TTokenizer.Pop_, ST.get(tok.symbolLocation).offset, tok.position);
   }
   function ParseSubroutineCall() {
     var /*TToken*/ tok;
     var /*int*/ paramCt;
     var /*BitSet*/ paramTypes;
     var /*String*/ name;
     tok = tokenizer.GetToken();
     prog.addInstruction(TTokenizer.SubroutineSetup_, 0, tokenizer.pos);
     var sym = ST.get(tok.symbolLocation);
     paramCt = sym.paramCount;
     paramTypes = sym.paramTypes;
     name = sym.name;
     ParseActualParams(paramCt, paramTypes, name);
     prog.addInstruction(TTokenizer.AdjustSavedPC_, paramCt, tokenizer.pos);
     prog.addInstruction(TTokenizer.JumpToSubroutine_, sym.start, tokenizer.pos);
   }
   function ParseIfStatement() {
     var /*TToken*/ tok;
     var /*int*/ firstJump, prevJump, runner;
     var /*int*/ prevJumpIf;
     tok = tokenizer.GetToken();
     prevJump = -1;
     firstJump = -1;
     prevJumpIf = -1;
     do {
      ParseCondition();
      tok = tokenizer.GetToken();
      if (tok.kind != TTokenizer.then_)
       Error("Expected 'THEN' here as part of an IF statemen.");
      prog.addInstruction(TTokenizer.not_, 0, tokenizer.pos);
      prevJumpIf = prog.insCt;
      prog.addInstruction(TTokenizer.JumpIf_, 0, tokenizer.pos);
      do {
       tok = tokenizer.LookToken();
       if (tok.kind == TTokenizer.endOfData_)
        Error("End of program encountered in the middle of an IF statement.");
       else if (tok.kind == TTokenizer.declare_ || tok.kind == TTokenizer.import_)
        Error("Declarations cannot occur inside IF statements; check for missing END IF.");
       else if (!(tok.kind == TTokenizer.else_ || tok.kind == TTokenizer.elseif_ || tok.kind == TTokenizer.endif_))
        ParseStatement();
      }while (!(tok.kind == TTokenizer.else_ || tok.kind == TTokenizer.elseif_ || tok.kind == TTokenizer.endif_));
      tok = tokenizer.GetToken();
      if (tok.kind == TTokenizer.elseif_ || tok.kind == TTokenizer.else_) {
        if (firstJump == -1)
         firstJump = prog.insCt;
        else
         prog.data[prevJump] = prog.insCt;
        prevJump = prog.insCt;
        prog.addInstruction(TTokenizer.Jump_, 0, tokenizer.pos);
        prog.data[prevJumpIf] = prog.insCt;
        prevJumpIf = -1;
      }
     } while (!(tok.kind == TTokenizer.endif_ || tok.kind == TTokenizer.else_));
     if (tok.kind == TTokenizer.else_) {
       do {
        tok = tokenizer.LookToken();
        if (tok.kind == TTokenizer.endOfData_)
         Error("No matching END IF for IF statement;  end of program encountered inside an IF statement.");
        else if (tok.kind == TTokenizer.elseif_)
         Error("In an IF statement, an OR IF clause cannot follow an ELSE clause.");
        else if (tok.kind == TTokenizer.declare_ || tok.kind == TTokenizer.import_) 
         Error("Declarations cannot occur inside IF statements; check for missing END IF.");
        else if (tok.kind != TTokenizer.endif_)
         ParseStatement();
       } while (tok.kind != TTokenizer.endif_);
       tok = tokenizer.GetToken();
     }
     if (prevJumpIf != -1)
       prog.data[prevJumpIf] = prog.insCt;
     if (firstJump != -1) {
       runner = firstJump;
       do {
        firstJump = prog.data[runner];
        prog.data[runner] = prog.insCt;
        runner = firstJump;
       } while (runner != 0);
     }
   }
   function ParseLoopStatement() {
     var /*int*/ i, saveLoopLoc;
     var /*TToken*/ tok;
     var /*boolean*/ exitexists;
     saveLoopLoc = currentLoopLoc;
     currentLoopLoc = prog.insCt;
     tok = tokenizer.GetToken();
     do {
      tok = tokenizer.LookToken();
      if (tok.kind == TTokenizer.endOfData_)
        Error("Encountered end of program in the middle of a LOOP.");
      else if (tok.kind  == TTokenizer.declare_ || tok.kind == TTokenizer.import_)
       Error("Declarations cannot occur inside of loops.");
      else if (tok.kind != TTokenizer.endloop_)
        ParseStatement();
     } while (tok.kind != TTokenizer.endloop_);
     tok = tokenizer.GetToken();
     prog.addInstruction(TTokenizer.Jump_, currentLoopLoc, tokenizer.pos);
     exitexists = false;
     for (i = currentLoopLoc; i < prog.insCt; i++)
      if ((prog.ins[i] == TTokenizer.Jump_ || prog.ins[i] == TTokenizer.JumpIf_) && prog.data[i] == -currentLoopLoc - 1) {
        prog.data[i] = prog.insCt;
        exitexists = true;
      }
      else if (prog.ins[i] == TTokenizer.Halt_ || prog.ins[i] == TTokenizer.Die_ || prog.ins[i] == TTokenizer.return_)
        exitexists = true;
     if (!exitexists)
       Error("No way is provided to ever exit from LOOP.");
     currentLoopLoc = saveLoopLoc;
   }
   function ParseExitStatement() {
     var /*TToken*/ tok;
     if (currentLoopLoc == -1)
       Error("EXIT statements can only occur inside loops.");
     if (grabBeingParsed > 1)
       Error("An EXIT statement cannnot occur inside a GRAB statement,  except in the ELSE part.");
     tok = tokenizer.GetToken();
     if (tok.kind != TTokenizer.exit_)
       ParseCondition();
     if (tok.kind == TTokenizer.exitunless_)
        prog.addInstruction(TTokenizer.not_, 0, tok.position);
     if (tok.kind == TTokenizer.exit_)
        prog.addInstruction(TTokenizer.Jump_, -currentLoopLoc - 1, tok.position);
     else
        prog.addInstruction(TTokenizer.JumpIf_, -currentLoopLoc - 1, tok.position);
   }
   function ParseReturnStatement() {
     var /*TToken*/ tok;
     if (!(parsingSubroutine || parsingFunction))
        Error("A RETURN statement can occur only in a subroutine or function definition.");
     if (grabBeingParsed > 1)
        Error("A RETURN statement cannot occur inside a GRAB statement, except in the ELSE part.");
     tok = tokenizer.GetToken();
     if (parsingFunction) {
         ParseComputation();
         prog.addInstruction(TTokenizer.PopFunctionValue_, 0, tokenizer.pos);
         prog.addInstruction(TTokenizer.returnFromFunction_, offsetCt, tok.position);
         returnFound = true;
     }
     else
      prog.addInstruction(TTokenizer.return_, offsetCt, tok.position);
   }
   function ParseGrab() {
     var /*TToken*/ tok, varTok;
     var /*int*/ num, jumpLoc;
     var /*boolean*/ elseOccurred;
     var /*int*/ loc;
     tokenizer.GetToken();
     varTok = tokenizer.GetToken();
     if (varTok.kind == TTokenizer.undeclaredName_)
        Error("The identifier '" + varTok.name + "' has not been declared.");
     if (varTok.kind == TTokenizer.variableName_ && ST.get(varTok.symbolLocation).offset > 0)
        Error("The reserved work GRAB must be followed by the name of a global variable.  '" + varTok.name + "' is a local variable.");
     if (varTok.kind != TTokenizer.variableName_)
        Error("The reserved word GRAB must be followed by the name of a global variable.");
     loc = ST.get(varTok.symbolLocation).trueSymbolLoc;
     num = ST.get(loc).grabNum;
     if (num == -1) {
       num = prog.GrabCount;
       if (num == 31)
          Error("A maximum of 32 different variables are supported in all GRAB statements.");
       prog.GrabCount++;
       ST.get(loc).grabNum = num;
     }
     prog.addInstruction(TTokenizer.Grab_, num, tokenizer.pos);
     jumpLoc = prog.insCt;
     prog.addInstruction(TTokenizer.Jump_, jumpLoc - 1, tokenizer.pos);
     tok = tokenizer.GetToken();
     if (tok.kind != TTokenizer.then_)
        Error("Expected to find the reserved word THEN, which is required in a GRAB command.");
     elseOccurred = false;
     grabBeingParsed = 2;
     do {
      tok = tokenizer.LookToken();
      if (tok.kind == TTokenizer.endOfData_)
       Error("Missing ENDGRAB.  End of program occurred inside a GRAB statement.");
      else if (tok.kind == TTokenizer.Fork_ && grabBeingParsed == 2)
       Error("A FORK statement cannot occur inside a GRAB statement, except in the ELSE part.");
      else if (tok.kind == TTokenizer.Die_ && grabBeingParsed == 2)
       Error("A KILLPROCESS statement cannot occur inside a GRAB statement, except in the ELSE part.");
      else if (tok.kind == TTokenizer.else_) {
        grabBeingParsed = 1;
        tok = tokenizer.GetToken();
        elseOccurred = true;
        prog.addInstruction(TTokenizer.endGrab_, num, tokenizer.pos);
        prog.addInstruction(TTokenizer.Jump_, 0, tokenizer.pos);
        prog.data[jumpLoc] = prog.insCt;
        jumpLoc = prog.insCt - 1;
      }
      else if (tok.kind != TTokenizer.endGrab_)
       ParseStatement();
     } while (tok.kind != TTokenizer.endGrab_);
     tok = tokenizer.GetToken();
     if (elseOccurred)
      prog.data[jumpLoc] = prog.insCt;
     else
      prog.addInstruction(TTokenizer.endGrab_, num, tokenizer.pos);
     grabBeingParsed = 0;
   }
   function DoVarForIOStatement (/*String*/ str, /*int*/ start) {
      var i = start; 
      var name = "";
      var /*boolean*/ done;
      var /*int*/ loc;
      var /*int*/ kind; // SymbolKinds
      done = false;
      i = i + 1;
      if (i >= str.length || !str.charAt(i).match(/[a-zA-Z]/))
        Error("Expected a variable name following # in string.");
      do {
        name += str.charAt(i);
        i = i + 1;
      } while ( i < str.length && str.charAt(i).match(/[a-zA-Z0-9_]/));
      loc = ST.findSymbol(name.toLowerCase());
      if (loc == -1)
       Error("Expected variable name after # in string; '" + name + "' is an undeclared identifier.");
      kind = ST.get(loc).kind;
      if (kind == TSymbolTable.refParamSymb)
       prog.addInstruction(TTokenizer.PushRefParam_, ST.get(loc).offset, tokenizer.pos);
      else if (kind == TSymbolTable.paramSymb || kind == TSymbolTable.variableSymb)
       prog.addInstruction(TTokenizer.Push_, ST.get(loc).offset, tokenizer.pos);
      else if (kind == TSymbolTable.keyWordSymb && (ST.get(loc).token >= TTokenizer.turtleX_ && ST.get(loc).token <= TTokenizer.forkNumber_))
       prog.addInstruction(ST.get(loc).token, 0, tokenizer.pos);
      else
       Error("Expected variable name after # in string; '" + name + "' is not a variable name.");
      return i;
   }
   function ParseIOStatement() {
     var /*TToken*/ firstTok, tok;
     var /*int*/ i, len;
     var /*int*/ loc;
     var buf = "";
     firstTok = tokenizer.GetToken();
     tok = tokenizer.GetToken();
     if (tok.kind != TTokenizer.leftParen_)
       Error("Expected left parenthesis to begin parameter list.");
     tok = tokenizer.GetToken();
     if (tok.kind != TTokenizer.string_)
       Error("The first parameter for this subroutine must be a string.");
     loc = prog.stringCt;
     i = 0;
     len = tok.str.length;
     var str = tok.str;
     while (i < len) {
       if (str.charAt(i) == '#') {
         if (i < len-1 && str.charAt(i + 1) == '#') {
           buf += '#';
           i = i + 2;
         }
         else {
           buf += String.fromCharCode(255);
           i = DoVarForIOStatement(str,i);
         }
       }
       else {
         buf += str.charAt(i);
         i = i + 1;
       }
     }
     prog.addString(buf);
     if (firstTok.kind == TTokenizer.AskUser_ || firstTok.kind == TTokenizer.YesOrNo_) {
       tok = tokenizer.GetToken();
       if (tok.kind != TTokenizer.comma_)
        Error("Expected a comman here.  (Two parameters are required.)");
       tok = tokenizer.GetToken();
       if (tok.kind == TTokenizer.refParamName_)
        prog.addInstruction(TTokenizer.Push_, ST.get(tok.symbolLocation).offset, tok.position);
       else if (tok.kind == TTokenizer.variableName_ || tok.kind == TTokenizer.paramName_)
        prog.addInstruction(TTokenizer.PushAbsoluteReference_, ST.get(tok.symbolLocation).offset, tok.position);
       else if (tok.kind == TTokenizer.undeclaredName_)
        Error("Undeclared identifier '" + tok.name + "'.");
       else
        Error("Unexpected item found.  This is a REF parameter;  actual parameter must be a variable name.");
     }
     tok = tokenizer.GetToken();
     if (tok.kind == TTokenizer.comma_)
      Error("Too many parameters provided.");
     else if (tok.kind != TTokenizer.rightParen_)
      Error("Expected right parenthesis to end parameter list.");
     prog.addInstruction(firstTok.kind, loc, firstTok.position);
   }
   function ParseStatement() {
       var /*TToken*/ tok;
       tok = tokenizer.LookToken();
       if ((tok.kind >= TTokenizer.HideTurtle_ && tok.kind <= TTokenizer.Halt_) ||
                   (tok.kind >= TTokenizer.red_ && tok.kind <= TTokenizer.white_)) {
            tok = tokenizer.GetToken();
            ParseActualParams(0, null, tok.name);
            prog.addInstruction(tok.kind, 0, tok.position);
       }
       else if (tok.kind == TTokenizer.Fork_ || (tok.kind >= TTokenizer.Forward_ && tok.kind <= TTokenizer.Circle_)) {
            tok = tokenizer.GetToken();
            ParseActualParams(1, null, tok.name);
            prog.addInstruction(tok.kind, 0, tok.position);
       }
       else if (tok.kind == TTokenizer.functionName_ ||
                      (tok.kind >= TTokenizer.Random_ && tok.kind <= TTokenizer.forkNumber_) ||
                      (tok.kind >= TTokenizer.sin_ && tok.kind <= TTokenizer.arcsin_) ||
                      (tok.kind >= TTokenizer.abs_ && tok.kind <= TTokenizer.RandomInt_))
       Error("Function name '" + tok.name + "' not legal here; functions cannot be used like subroutines or assigned values.");
       else {
         switch (tok.kind) {
          case TTokenizer.variableName_:
          case TTokenizer.refParamName_:
          case TTokenizer.paramName_: 
             ParseAssignmentStatement();
             break;
          case TTokenizer.subName_: 
            ParseSubroutineCall();
            break;
          case TTokenizer.if_: 
            ParseIfStatement();
            break;
          case TTokenizer.loop_: 
            ParseLoopStatement();
            break;
          case TTokenizer.exit_:
          case TTokenizer.exitif_:
          case TTokenizer.exitunless_: 
            ParseExitStatement();
            break;
          case TTokenizer.return_: 
            ParseReturnStatement();
            break;
          case TTokenizer.Grab_: 
            ParseGrab();
            break;
          case TTokenizer.Die_:
            tok = tokenizer.GetToken();
            if (grabBeingParsed == 2)
               Error("A KillProcess command cannot occur in a GRAB statement, except in the ELSE part.");
            if (parsingSubroutine || parsingFunction) {
              prog.addInstruction(TTokenizer.return_, offsetCt, tok.position);
              returnFound = true;
            }
            else
              prog.addInstruction(TTokenizer.Die_, 0, tok.position);
            break;
          case TTokenizer.Move_:
          case TTokenizer.MoveTo_:
          case TTokenizer.Arc_:
             tok = tokenizer.GetToken();
             ParseActualParams(2, null, tok.name);
             prog.addInstruction(tok.kind, 0, tok.position);
             break;
          case TTokenizer.rgb_:
          case TTokenizer.hsb_:
             tok = tokenizer.GetToken();
             ParseActualParams(3, null, tok.name);
             prog.addInstruction(tok.kind, 0, tok.position);
             break;
          case TTokenizer.declare_:
          case TTokenizer.import_: 
            ParseDeclaration();
            break;
          case TTokenizer.AskUser_:
          case TTokenizer.YesOrNo_:
          case TTokenizer.TellUser_:
          case TTokenizer.DrawText_: 
             ParseIOStatement();
             break;
          case TTokenizer.sub_:
          case TTokenizer.function_:
          case TTokenizer.predeclare_: 
             Error("Subroutine and function declarations cannot be nested inside each other or inside statements.");
             break;
          case TTokenizer.endloop_: 
             Error("'END LOOP' found without matching 'LOOP'.  Check nesting of statements.");
             break;
          case TTokenizer.else_:
          case TTokenizer.elseif_:
          case TTokenizer.endif_: 
             Error("'" + tok.name + "' found without matching 'IF'.  Check nesting of statements.");
             break;
          case TTokenizer.endGrab_: 
             Error("'END GRAB' found without matching 'GRAB'.  Check nesting of statements.");
             break;
          case TTokenizer.endsub_: 
             Error("'END SUB' found without matching 'SUB'.  Check nesting.");
             break;
          case TTokenizer.endfunction_: 
             Error("'END FUNCTION found without matching 'FUNCTION'.  Check nesting.");
             break;
          case TTokenizer.undeclaredName_: 
            if (parsingSubroutine)
              Error("The identifier '" + tok.name + "' has not been declared in this subroutine.");
            else if (parsingFunction)
              Error("The identifier '" + tok.name + "' has not been declared in this function.");
            else
              Error("The identifier '" + tok.name + "' has not been declared.");
            break;
          default:
            Error("Unexpected item found; expected a statement or declaration.");
         }
       }
   }
   function ParseActualParams (paramCt, /*BitSet*/ paramTypes, subName) { 
     var /*TToken*/ tok;
     var /*int*/ i;
     if (paramCt == 0) {
       tok = tokenizer.LookToken();
       if (tok.kind == TTokenizer.leftParen_) {
         tokenizer.GetToken();
         tok = tokenizer.GetToken();
         if (tok.kind != TTokenizer.rightParen_)
           Error("Expected right parenthesis; '" + subName + "' has no parameters.");
       }
       return;
     }
     tok = tokenizer.GetToken();
     if (tok.kind != TTokenizer.leftParen_)
       Error("Expected left parenthesis to begin parameter list for '" + subName + "'.");
     for (i = 1; i <= paramCt; i++) {
       tok = tokenizer.LookToken();
       if (paramTypes && (paramTypes & (1 << (i-1))) != 0) {
         tok = tokenizer.GetToken();
         if (tok.kind == TTokenizer.refParamName_)
           prog.addInstruction(TTokenizer.Push_, ST.get(tok.symbolLocation).offset, tok.position);
         else if (tok.kind == TTokenizer.variableName_ || tok.kind == TTokenizer.paramName_)
           prog.addInstruction(TTokenizer.PushAbsoluteReference_, ST.get(tok.symbolLocation).offset, tok.position);
         else if (tok.kind == TTokenizer.undeclaredName_)
           Error("Undeclared identifier, '" +  tok.name + "'.");
         else
           Error("Unexpected item found.  This is a REF parameter;  actual parameter must be a variable name.");
         tok = tokenizer.LookToken();
         if (tok.kind != TTokenizer.comma_ && tok.kind != TTokenizer.rightParen_) 
         Error("Unexpected item found.  This is a REF parameter;  actual parameter must be a variable name.");
       }
       else {
         ParseComputation();
         tok = tokenizer.LookToken();
       }
       tok = tokenizer.GetToken();
       if (i < paramCt) {
         if (tok.kind == TTokenizer.rightParen_)
           Error("Not enough parameters supplied for '" +  subName+  "'.  (" +  paramCt + " required.)");
         else if (tok.kind != TTokenizer.comma_)
           Error("Expected a comma here to separate parameters.");
       }
     }
     if (tok.kind != TTokenizer.rightParen_)
         Error("Expected right parenthesis here to end parameter list for '" + subName + "'.");
   }
   function ParseFormalParams () {
     var /*int*/ paramCt;
     var /*BitSet*/ paramTypes;
     var /*TToken*/ tok;
     var /*int*/ kind; // SymbolKinds
     var /*int*/ loc;
     var /*String*/ name;
     paramCt = 0;
     paramTypes = 0;
     tokenizer.GetToken();  // "("
     tok = tokenizer.LookToken();
     if (tok.kind == TTokenizer.rightParen_) {
       tok = tokenizer.GetToken();
       return [0,0];
     }
     do {
      tok = tokenizer.GetToken();
      if (tok.kind == TTokenizer.ref_) {  
        kind = TSymbolTable.refParamSymb;
        paramTypes = paramTypes | (1 << paramCt);
        tok = tokenizer.GetToken();
      }
      else
       kind = TSymbolTable.paramSymb;
      paramCt++;
      if (tok.kind == TTokenizer.undeclaredName_ || tok.kind == TTokenizer.functionName_ || tok.kind == TTokenizer.subName_) {
        if (paramCt > 30)
          Error("Too many parameters; there is a limit of 30.");
        if (tok.kind == TTokenizer.undeclaredName_)
          loc = ST.addSymbol(kind, tok.name);
        else {
         name = ST.get(tok.symbolLocation).name;
         loc = ST.addSymbol(kind, name);
        }
        offsetCt++;
        ST.setVariableData(loc, offsetCt);
      }
      else if (tok.kind < TTokenizer.variableName_ && !(tok.kind >= TTokenizer.leftParen_ && tok.kind <= TTokenizer.comma_))
       Error("A reserved word can''t be redefined as a parameter name.");
      else if (tok.kind == TTokenizer.paramName_ || tok.kind == TTokenizer.refParamName_)
       Error("Duplicate parameter name.");
      else
       Error("Unexpected item found in formal parameter list.");
      tok = tokenizer.GetToken();
      if (tok.kind != TTokenizer.comma_ && tok.kind != TTokenizer.rightParen_)
       Error("Expected either a comma or a right parenthesis here, while reading a formal parameter list.");
     } while (tok.kind != TTokenizer.rightParen_);
     return [paramCt,paramTypes];
   }
   function ParseForwardDeclaration() {
     var /*TToken*/ firstTok, nameTok, tok;
     var /*int*/ nameLoc;
     var /*int*/ paramCt;
     var /*BitSet*/ paramTypes;
     tokenizer.GetToken();  // "predeclare"
     firstTok = tokenizer.GetToken();
     if (firstTok.kind != TTokenizer.sub_ && firstTok.kind != TTokenizer.function_)
      Error("The reserved word 'PREDECLARE' must be followed by either 'SUB' or 'FUNCTION'.");
     nameTok = tokenizer.GetToken();
     if (nameTok.kind != TTokenizer.undeclaredName_) {
      if (nameTok.kind < TTokenizer.variableName_)
       Error("You can't redefine a reserved word.");
      else
       Error("The identifier '" + nameTok.name + "' has already been defined.");
     }
     if (firstTok.kind == TTokenizer.sub_)
      nameLoc = ST.addSymbol(TSymbolTable.subSymb, nameTok.name);
     else
      nameLoc = ST.addSymbol(TSymbolTable.functionSymb, nameTok.name);
     prog.addInstruction(TTokenizer.Jump_, prog.insCt + 2, tokenizer.pos);
     prog.addInstruction(TTokenizer.Jump_, 0, tokenizer.pos);
     paramCt = 0;
     paramTypes = 0;
     tok = tokenizer.LookToken();
     if (tok.kind == TTokenizer.leftParen_) {
       tok = tokenizer.GetToken();
       tok = tokenizer.LookToken();
       if (tok.kind != TTokenizer.rightParen_)
        do {
         if (paramCt == 30)
            Error("There is a maximum of 30 parameters for a subroutine or function.");
         paramCt++;
         tok = tokenizer.GetToken();
         if (tok.kind == TTokenizer.ref_) {
           paramTypes = paramTypes | (1 << (paramCt-1));
           tok = tokenizer.GetToken();
         }
         if (tok.kind < TTokenizer.variableName_ || tok.kind == TTokenizer.string_ || tok.kind == TTokenizer.number_)
           Error("Expected an identifier here as the name for a dummy parameter.");
         tok = tokenizer.LookToken();
         if (tok.kind == TTokenizer.comma_)
            tok = tokenizer.GetToken();
        } while (tok.kind == TTokenizer.comma_);
       if (tok.kind != TTokenizer.rightParen_)
        Error("Expected a right parenthesis to end parameter list or a comma to separate parameters.");
       tok = tokenizer.GetToken();
     }
     paramTypes = paramTypes | (1 << 31);  // this sub is predeclared
     ST.setSubroutineData(nameLoc, prog.insCt - 1, paramCt, paramTypes);
   }
   function ParseSubroutine() {
     var /*TToken*/ tok, nameTok, firstTok;
     var /*int*/ nameLoc, i;
     var /*int*/ paramCt;
     var /*int*/ codeStart;
     var /*BitSet*/ paramTypes;
     var /*boolean*/ predeclared;
     var sym;
     offsetCt = 0;
     firstTok = tokenizer.GetToken();
     if (firstTok.kind == TTokenizer.sub_)
      parsingSubroutine = true;
     else {
       parsingFunction = true;
       returnFound = false;
     }
     nameTok = tokenizer.GetToken();
     predeclared = false;
     if (nameTok.kind == TTokenizer.subName_ || nameTok.kind == TTokenizer.functionName_) {
       sym = ST.get(nameTok.symbolLocation);
       if ( (sym.paramTypes & (1 << 31)) == 0 )
        Error("The identifier '" + nameTok.name + "' has already been defined.");
       else if (nameTok.kind == TTokenizer.subName_ && firstTok.kind == TTokenizer.function_)
        Error("This was previously predeclared as a subroutine; it cannot be redefined as a function.");
       else if (nameTok.kind == TTokenizer.functionName_ && firstTok.kind == TTokenizer.sub_)
        Error("This was previously predeclared as a function; it cannot be redefined as a subroutine.");
       else
        predeclared = true;
     }
     else if (nameTok.kind != TTokenizer.undeclaredName_) {
      if (nameTok.kind < TTokenizer.variableName_)
       Error("You can't use a reserved word or a symbol as the name of a subroutine or function.");
      else
       Error("The identifier '" + nameTok.name + "' has already been defined.");
     }
     if (predeclared)
      nameLoc = nameTok.symbolLocation;
     else if (firstTok.kind == TTokenizer.sub_)
      nameLoc = ST.addSymbol(TSymbolTable.subSymb, nameTok.name);
     else
      nameLoc = ST.addSymbol(TSymbolTable.functionSymb, nameTok.name);
     ST.startSubroutineSymbols();
     codeStart = prog.insCt;
     prog.addInstruction(TTokenizer.Jump_, 0, tokenizer.pos);
     if (predeclared) {
       sym = ST.get(nameLoc);
       sym.paramTypes = sym.paramTypes & ~(1<<31);
       prog.data[sym.start] = prog.insCt;
     }
     tok = tokenizer.LookToken();
     if (tok.kind != TTokenizer.leftParen_) {
       paramCt = 0;
       paramTypes = 0;
     }
     else {
       var subdata = ParseFormalParams();
       paramCt = subdata[0];
       paramTypes = subdata[1];
       tok = tokenizer.LookToken();
     }
     if (predeclared) {
       sym = ST.get(nameLoc);
       if (paramCt != sym.paramCount)
        Error("The number of parameters given here does not agree with the number in the predeclaration of this subroutine.");
       for (i = 0; i < paramCt; i++)
         if ( (paramTypes & (1<<i)) != (sym.paramTypes & (1<<i)) )
           Error("The type of parameter number " + (i + 1) + "(REF or non-REF) does not agree with its type in the predeclaration of this subroutine.");
     }
     else
      ST.setSubroutineData(nameLoc, codeStart + 1, paramCt, paramTypes);
     prog.addInstruction(TTokenizer.SetStackRef_, paramCt, tokenizer.pos);
     do {
      if (tok.kind == TTokenizer.endfunction_ && parsingSubroutine)
       Error("Unexpected 'END FUNCTION' -- expecting END SUB or a statement or declaration.");
      else if (tok.kind == TTokenizer.endsub_ && parsingFunction)
       Error("Unexpected 'END SUB' -- expecting END FUNCTION or a statement or declaration.");
      else if (tok.kind == TTokenizer.endif_ || tok.kind == TTokenizer.endloop_ || tok.kind == TTokenizer.else_ || tok.kind == TTokenizer.elseif_) {
       if (parsingSubroutine)
        Error("Expecting END SUB or a statement or declaration.  (CheckNesting)");
       else
        Error("Expecting END FUNCTION or a statement or declaration.  (CheckNesting)");
      }
      ParseStatement();
      tok = tokenizer.LookToken();
     } while (tok.kind != TTokenizer.endsub_ && tok.kind != TTokenizer.endfunction_);
     if (parsingFunction && !returnFound)
      Error("No return statement in function; it has no way to return a value.");
     if (tok.kind == TTokenizer.endsub_) {
       if (firstTok.kind == TTokenizer.function_)
        Error("END FUNCTION is required to end a function definition.");
     }
     else if (firstTok.kind == TTokenizer.sub_)
      Error("END SUB is required to end a subroutine definition.");
     tok = tokenizer.GetToken();
     prog.addInstruction(TTokenizer.return_, offsetCt, tokenizer.pos);
     ST.endSubroutineSymbols();
     prog.data[codeStart] = prog.insCt;
     parsingSubroutine = false;
     parsingFunction = false;
   }
   return {
      parse: function(/*String*/ str, /*TSymbolTable*/ symbs) {
         if (str == null || str.trim().length == 0)
            throw new TError("Data is empty; no program available for compilation.",-1);
         saveInsCt = 0;
         ST = symbs;
         tokenizer = new TTokenizer(str,ST);
         prog = new TProgram();
         doParse();
         var temp = prog;
         prog = null;
         tokenizer = null;
         return temp;
      },
      parseAppend: function(/*String*/ str, /*TSymbolTable*/ symbs, /*TProgram*/ program) {
         if (str == null || str.trim().length == 0)
            throw new TError("Data is empty; no program available for compilation.",-1);
         saveInsCt = program.insCt;
         ST = symbs;
         prog = program;
         tokenizer = new TTokenizer(str,ST);
         doParse();
         tokenizer = null;
         prog = null;
         ST = null;
      }
   };
})();

//------------------------------------------------------------------------

function indent(str) {
     var oldText = str;
     var len = oldText.length;
     var newText = "";
     var pos = 0;
     var indentCt = 0;
     var NewindentCt = 0;
     var previousWord = "";
     var line = "";
     while (pos < len) {
        let ch = oldText.charAt(pos);
        if (ch == '"')
         CopyString();
        else if (ch == '{')
         CopyComment();
        else if (ch.match(/[a-zA-Z_]/))
         CopyWord();
        else {
          if (ch == '\n' || ch == '\r') {
             putEOL();
             if (ch == '\r' && pos+1 < len && oldText.charAt(pos+1) == '\n')
                pos++;
             pos++;
             while (pos < len && (oldText.charAt(pos) == ' ' || oldText.charAt(pos) == '\t'))
                pos++;
          }
          else {
             PutCh(ch);
             pos++;
          }
        }
     }
     if (line.length != 0)
        Put(line);
     return newText;
     function Put(s) {
       newText += s;
     }     
     function PutCh(ch) {
       line += ch;
     }     
     function putEOL() {
         line += '\n';
         if (line.charAt(0) != '\r' && line.charAt(0) != '\n') {
          for (let i = 0; i < indentCt; i++)
             Put(" ");
         }
         Put(line);
         line = "";
         indentCt = NewindentCt;
     }
     function CopyString() {
       do {
            let ch = oldText.charAt(pos);
            if (ch == '\n')
               putEOL();
            else if (ch == '\r') {
               putEOL();
               if (pos+1 < len && oldText.charAt(pos) == '\n')
                  pos++;
            }
            else
               PutCh(oldText.charAt(pos));
            pos = pos + 1;
       } while (pos < len && oldText.charAt(pos) != '"');
       if (pos < len) {
          PutCh(oldText.charAt(pos));
          pos = pos + 1;
       }
     }
     function CopyComment() {
       var nesting = 0;
       do {
        let ch = oldText.charAt(pos);
        if (ch == '{') {
           PutCh('{');
           nesting ++;
        }
        else if (ch == '}') {
           PutCh('}');
           nesting --;
        }
        else if (ch == '\n')
           putEOL();
        else if (ch == '\r') {
           putEOL();
           if (pos+1 < len && oldText.charAt(pos+1) == '\n')
              pos++;
        }
        else
          PutCh(ch);
        pos = pos + 1;
       } while (pos < len && nesting > 0);
     }
     function NextWordIsIf() {
       var p = pos;
       while (p < len && !oldText.charAt(p.match(/[a-zA-Z]/))) {
        if (oldText.charAt(p) == '{') {
          let nesting = 0;
          do {
            if (oldText.charAt(p) == '{')
               nesting++;
            else if (oldText.charAt(p) == '}')
               nesting--;
            p = p + 1;
          } while (p < len && nesting > 0);
          if (p < len)
           p = p + 1;
        }
        else
         p = p + 1;
       }
       return (p + 1 < len) && 
              (oldText.charAt(p) == 'i'|| oldText.charAt(p) == 'I') &&
              (oldText.charAt(p + 1) == 'f' || oldText.charAt(p + 1) == 'F') &&
              ((p + 2 == len) || 
                      !(oldText.charAt(p + 2) == '_' || oldText.charAt(p+2).match(/[a-zA-Z_]/)));
     }
     function CopyWord() {
       var w = "";
       do {
          w += oldText.charAt(pos);
          pos++;
       } while (pos < len && 
                  (oldText.charAt(pos) == '_' || oldText.charAt(pos).match(/[a-zA-Z0-9]/)));
       if (w.length > 11) {
         for (let i = 0; i < w.length; i++)
            PutCh(w.charAt(i));
         previousWord = w;
         return;
       }
       let lcw = w.toLowerCase();
       if (lcw == "end") {
         if (line.length == 0)
          indentCt = indentCt - 3;
         NewindentCt = NewindentCt - 3;
       }
       else if (lcw == "orif" || lcw == "else" ||
                      (lcw == "or" && NextWordIsIf())) {
         if (line.length == 0)
           indentCt = indentCt - 3;
       }
       else {
         if (lcw == "if" && (previousWord == "or" || previousWord == "exit")) { }
         else if ((lcw == "sub" || lcw == "function") && previousWord == "predeclare") { }
         else if (lcw == "sub" || lcw == "if" || lcw == "loop" || 
                      lcw == "grab" || lcw == "function") {
           if (previousWord != "end")
             NewindentCt = NewindentCt + 3;
         }
         else if (lcw == "endsub" || lcw == "endif" || lcw == "endloop" || 
                         lcw == "endgrab" || lcw == "endfunction") {
           if (line.length == 0)
             indentCt = indentCt - 3;
           NewindentCt = NewindentCt - 3;
         }
       }
       previousWord = lcw;
       for (let i = 0; i < w.length; i++)
         PutCh(w.charAt(i));
     }
}

function doIndent() {
   var program = document.getElementById("program").value;
   var indented = indent(program);
   document.getElementById("program").value = indented;
}

function startProgramLoad(program) {  
   if (program.status != "not started")
      return;
   program.status = "loading";
   program.text = "Waiting for program '" + program.name + "' to load from url " + program.url;
   if (program.position == programInEditor) {
       document.getElementById("program").value = program.text;
       document.getElementById("program").disabled = true;
   }
   var ajaxTimeout;
   var ajax = new XMLHttpRequest();
   ajax.open("GET",program.url);
   ajax.overrideMimeType("text/plain");
   ajax.addEventListener("error",function() {
       clearTimeout(ajaxTimeout);
       program.text = "Error: Program could not be loaded from " + program.url;
       program.status = "error";
       doneLoad();
   });
   ajax.addEventListener("load",function() {
       clearTimeout(ajaxTimeout);
       program.text = ajax.responseText;
       program.status = "loaded";
       doneLoad();
   });
   ajaxTimeout = setTimeout(function() {
       ajax.abort();
       program.text = "Error: Request timed out while trying to load from " + program.url;
       program.status = "error";
       doneLoad();
   }, 30000);
   try {
      ajax.send();
   } catch(e) {
       clearTimeout(ajaxTimeout);
       program.status = "error";
       program.text = "Error while trying to send request for example: " + program.url;
       doneLoad();
   }
   function doneLoad() {
      if (program.position == programInEditor) {
          document.getElementById("program").value = program.text;
          document.getElementById("program").disabled = false;
      }
   }
}


function doProgramChange() {
   let currentProg = programs[programInEditor];
   currentProg.text = document.getElementById("program").value;
   let p = document.getElementById("selectprogram").value;
   document.getElementById("programerror").innerHTML = "&nbsp;";
   document.getElementById("status").innerHTML = "xTurtle Status: Idle";
   if (p == "new") {
       untitledCount++;
       let pos = programs.length;
       let prog = { name: "User Program " + untitledCount, text: "",
                    position: pos, status: "user" };
        programs.push(prog);
        document.getElementById("program").value = "";
        let option = document.createElement("option");
        option.value = "" + (pos+1);
        option.innerHTML = prog.name;
        document.getElementById("selectprogram").appendChild(option);
        document.getElementById("selectprogram").value = "" + (pos+1);
        document.getElementById("program").disabled = false;
        programInEditor = pos;
   }
   else {
       p = Number(p) - 1;
       let prog = programs[p];
       programInEditor = prog.position;
       if (prog.status == "not started") {
          startProgramLoad(prog);
       }
       else {
           document.getElementById("program").value = prog.text;
           document.getElementById("program").disabled = (prog.status == "loading");
       }
   }
}

function doFinishAskUser() {
    var ans = parseFloat(document.getElementById("auinput").value.trim());
    if (isFinite(ans) ) {
        userInput = ans;
        gotInput();
    }
    else {
        alert("Your input for AskUser is not a number.  Please enter a number before continuing.");
        document.getElementById("auinput").focus();
        document.getElementById("auinput").select();
    }
}

function doClear() {
   stopRunning();
   activeProcessList = new Turtle();
   loadedProgram = null;
   loadedProgramName = null;
   OSG.fillStyle = "white";
   OSG.fillRect(0,0,canvas.width,canvas.height);
   doDraw();
   document.getElementById("doit").disabled = false;
   document.getElementById("command").disabled = false;
   document.getElementById("run").disabled = true;
   document.getElementById("pause").disabled = true;
   document.getElementById("stop").disabled = true;
   if (currentInputDialog)
      currentInputDialog.style.display = "none";
   document.getElementById("errorreport").style.display = "none";
   document.getElementById("programerror").innerHTML = "&nbsp;";
   document.getElementById("status").innerHTML = "xTurtle Status: Idle";
}

function doUserCommands() {
   var commands = document.getElementById("command").value.trim();
   if (commands.length == 0) {
       showErrorDialog("Enter some commands in the input box before trying to execute them!");
       return;
   }
   document.getElementById("programerror").innerHTML = "&nbsp;";
   try {
      if (loadedProgram) {
         let start = loadedProgram.insCt;
         parser.parseAppend(commands,loadedProgramSymbols,loadedProgram);
         loadedProgramTurtle.programCounter = start;
      }
      else {
         let ST = new TSymbolTable();
         let prog = parser.parse(commands,ST);
         loadedProgram = prog;
         loadedProgramSymbols = ST;
         loadedProgramIncludesUserCommands = true;
         loadedProgramTurtle = new Turtle(0,null);
      }
   }
   catch (e) {
      if (e instanceof TError) {
         showErrorDialog("Compilation error: " + e.message);
         document.getElementById("command").setSelectionRange(e.pos,e.pos);
         document.getElementById("command").focus();
      }
      else {
         showErrorDialog("Internal error (this is a bug): " + e);
      }
      document.getElementById("command").focus();
      document.getElementById("command").select();
      return;
   }
   loadedProgramName = "&lt;User Commands&gt;";
   document.getElementById("errorreport").style.display = "none";
   startRunningProgram(loadedProgram,loadedProgramTurtle);
}

function doRunProgram() {
   stopRunning();
   var text = document.getElementById("program").value;
   try {
      var ST = new TSymbolTable();
      var prog = parser.parse(text,ST);
      doClear();
      loadedProgram = prog;
      loadedProgramSymbols = ST;
      loadedProgramIncludesUserCommands = false;
      loadedProgramTurtle = new Turtle(0,null);
      loadedProgramName = '"' + programs[programInEditor].name + '"';
      startRunningProgram(prog,loadedProgramTurtle);
      window.scrollTo(0,window.pageYOffset+document.getElementById("status").getBoundingClientRect().top);   }
   catch (e) {
      if ( e instanceof TError ) {
         document.getElementById("programerror").innerHTML = "Syntax error: " + e.message;
         document.getElementById("program").setSelectionRange(e.pos,e.pos);
         document.getElementById("program").focus();
      }
      else {
         document.getElementById("programerror").innerHTML = "Internal error (this is a bug): " + e;
      }
   }
}


function setUpFileHandling() {  // File handling for saving and loading files; added November 2023.
   var saveBtn = document.getElementById("saveBtn");
   var loadBtn = document.getElementById("loadBtn");
   var loading = false;
   if (window.showOpenFilePicker && FileSystemFileHandle && FileSystemFileHandle.prototype.getFile) {
        loadBtn.addEventListener("click",doLoad,false);
    }
    else {
        let chooser = document.createElement("input");
        chooser.type = "file";
        chooser.id = "chooseloadfile";
        chooser.style.display = "none";
        document.getElementById("controls").appendChild(chooser);
        loadBtn.addEventListener("click",doBasicLoad,false);
        loadBtn.title += "  This will look like uploading a file, but it will only be loaded locally.";
    }
    if (window.showSaveFilePicker && FileSystemFileHandle && FileSystemFileHandle.prototype.createWritable) {
        saveBtn.addEventListener("click",doSave,false);  
    }
    else {
        saveBtn.addEventListener("click",doBasicSave,false);
        saveBtn.title += "  This will look like downloading a file.";
    }
    function doBasicSave() {
        if (loading)
           return;
        let content = document.getElementById("program").value;
        let name = programs[programInEditor].name.replace(/&lt;/g,"<").replace(/&amp;/g,"&");
        let blob = new Blob([content], {type: 'text/plain'});
        let link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = name + ".txt";
        link.click();
        URL.revokeObjectURL(link.href);
    }
    async function doSave() {
        if (loading)
           return;
        let content = document.getElementById("program").value;
        let name = programs[programInEditor].name.replace(/&lt;/g,"<").replace(/&amp;/g,"&");
        let blob = new Blob([content], {type: 'text/plain'});
        let options = { suggestedName: name + ".txt" };
        try {
            let fileHandle = await window.showSaveFilePicker(options);
            let stream = await fileHandle.createWritable();
            await stream.write(blob);
            await stream.close();
            setMessage("File has been saved.");
        }
        catch (e) {
            if (e.name !== "AbortError") {
                setMessage("Error while attempting to save file!");
                alert("Error while saving file:\n" + e);
            }
        }
    }
    function doBasicLoad() {
        let chooser = document.getElementById("chooseloadfile");
        chooser.value = "";
        document.getElementById("chooseloadfile").addEventListener("change",handleBasicFileLoad,false);
        chooser.click();
    }
    async function handleBasicFileLoad() {
       loadBtn.disabled = true;
       loading = true;
       try {
            let chooser = document.getElementById("chooseloadfile");
            chooser.removeEventListener("change",handleBasicFileLoad,false);
            if (chooser.files.length === 0)
               return;
            let name = chooser.files[0].name.replace("/&/g", "&amp;").replace("/</g", "&lt;");
            setMessage("Trying to load file " + name);
            if ( chooser.files[0].type && ! /^text/i.test(chooser.files[0].type))
                throw "Only text files can be loaded.";
            let text = await chooser.files[0].text();
            newProgram(chooser.files[0].name,text);
            setMessage("Successfully loaded file " + name);
       }
       catch (e) {
           setMessage("File load failed!");
           alert("File load failed:\n" + e);
       }
       finally {
           loadBtn.disabled = false;
           loading = false;
       }
    }
    async function doLoad() {
       setMessage("Load file -- select a file or cancel!");
       loading = true;
       loadBtn.disabled = true;
       try {
           let files = await window.showOpenFilePicker();
           if (files.length === 0) {
              setMessage("File load canceled"); // (Can this happen?)
              return;
           }
           let fileData = await files[0].getFile();
           if ( fileData.type && ! /^text/i.test(fileData.type)) 
               throw "Only text files can be loaded.";
           let text = await fileData.text();
           newProgram(fileData.name,text);
           setMessage("Successfully loaded file " + fileData.name.replace("/&/g", "&amp;").replace("/</g", "&lt;"));
       }
       catch (e) {
           if (e.name === "AbortError")
              setMessage("File load canceled");
           else {
              setMessage("File load failed!");
              alert("File load failed:\n" + e);
           }
       }
       finally {
           loadBtn.disabled = false;
           loading = false;
       }
    }
    function newProgram(name,text) {
        let currentProg = programs[programInEditor];
        currentProg.text = document.getElementById("program").value;
        let pos = programs.length;
        name = name.replace(/\.txt$/,"").replace("/&/g", "&amp;").replace("/</g", "&lt;");
        let prog = { name: name, text: text,
                    position: pos, status: "user" };
        programs.push(prog);
        document.getElementById("program").value = text;
        document.getElementById("programerror").innerHTML = "&nbsp;";
        let option = document.createElement("option");
        option.value = "" + (pos+1);
        option.innerHTML = prog.name;
        document.getElementById("selectprogram").appendChild(option);
        document.getElementById("selectprogram").value = "" + (pos+1);
        programInEditor = pos;
    }
    function setMessage(msg) {
       document.getElementById("status").innerHTML = "xTurtle Status: " + msg;
    }
}


function setUpProgramMenu() {  // Big revisions to file menu andling, November 2023
   var search = decodeURIComponent(location.search);
   if (search === "?files=none" || search === "?files=") {
      programsToLoad = null;
      createMenu();
      return;
   }
   if (search === "" || search.indexOf("?files=") !== 0) {
      createMenu();
      return;
   }
   programsToLoad = "";
   document.getElementById("programerror").innerHTML = "Trying to load list of sample programs...";
   var fileURL = search.substring(7);
   var ajaxTimeout;
   var ajax = new XMLHttpRequest();
   ajax.open("GET",fileURL);
   ajax.overrideMimeType("text/plain");
   ajax.addEventListener("error",function() {
       clearTimeout(ajaxTimeout);
       document.getElementById("status").innerHTML = "xTurtle Status:  Could not load sample file list.";
       console.log("error while trying to load file list: ajax request error.");
       document.getElementById("programerror").innerHTML = "&nbsp;";
       createMenu();
   });
   ajax.addEventListener("load",function() {
       clearTimeout(ajaxTimeout);
       var text = ajax.responseText;
       document.getElementById("programerror").innerHTML = "&nbsp;";
       try {
           programs = JSON.parse(text);
           if (programs.length === undefined)
              throw "error";
           for (var i = 0; i < programs.length; i++) {
              if (typeof programs[i] !== "object")
                 throw "error";
              if ( ! ( programs[i].name && programs[i].url ))
                 throw "error";
              if ( ! ( typeof programs[i].name === "string" && typeof programs[i].url === "string"))
                 throw "error";
              program.name = program.name.replace(/&/g, "&amp;").replace(/</g, "&lt;");
           }
           programsToLoad = programs;
       }
       catch (e) {
          console.log("error while trying to load file list: " + e);
          document.getElementById("status").innerHTML = "xTurtle Status:  Syntax error in sample file list.";
       }
       createMenu();
   });
   ajaxTimeout = setTimeout(function() {
       ajax.abort();
       console.log("error while trying to load file list: request timed out.");
       document.getElementById("status").innerHTML = "xTurtle Status:  Could not load sample file list.";
       document.getElementById("programerror").innerHTML = "&nbsp;";
       createMenu();
   }, 10000);
   try {
      ajax.send();
   } catch(e) {
       clearTimeout(ajaxTimeout);
       document.getElementById("status").innerHTML = "xTurtle Status:  Could not load sample file list.";
       document.getElementById("programerror").innerHTML = "&nbsp;";
       createMenu();
   }
   function createMenu() {
      if (programsToLoad && programsToLoad.length > 0) {
         untitledCount = 0;
         programs = programsToLoad;
         let options = "<option value='new'>[New Program]</option>";
         for (let i = 0; i < programs.length; i++) {
            options += "<option value='" + (i+1) +"'>" + programs[i].name + "</option>";
            programs[i].position = i;
            programs[i].status = "not started";
         }
         document.getElementById("selectprogram").innerHTML = options;
         programInEditor = 0;
         startProgramLoad(programs[0]);
      }
      else {
         document.getElementById("selectprogram").innerHTML =
                   "<option value='new'>[New Program]</option>" +
                   "<option value='1'>User Program 1</option>";
         untitledCount = 1;
         programs = [
            { name: "User Program 1", text: "", position: 0, status: "user" }
         ];
         programInEditor = 0;
      }
      document.getElementById("selectprogram").value = "1";
      document.getElementById("selectprogram").onchange = doProgramChange;
   }
}

function init() {
    try {
        canvas = document.getElementById("canvas");
        graphics = canvas.getContext("2d");
        graphics.strokeStyle = "blue";
        OSC = document.createElement("canvas");
        OSC.width = canvas.width;
        OSC.height = canvas.height;
        OSG = OSC.getContext("2d");
        OSG.lineWidth = 2;
        OSG.font = "15px Serif";
    }
    catch (e) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires canvas graphics support, which is not available in your browser.";
         return;
    }
    document.getElementById("reset").onclick = doClear;
    document.getElementById("pause").onclick = pauseRunning;
    document.getElementById("stop").onclick = stopRunning;
    document.getElementById("run").onclick = resumeRunning;
    document.getElementById("doit").onclick = doUserCommands;
    document.getElementById("command").onkeydown = function(evt) { if (evt.keyCode == 13) doUserCommands(); };
    document.getElementById("command").value = "";
    document.getElementById("speedselect").onchange = function() {runSpeed = document.getElementById("speedselect").value;};
    document.getElementById("speedselect").value = "" + runSpeed;
    document.getElementById("hideturtles").onchange = function() {
         alwaysHideTurtles = document.getElementById("hideturtles").checked;
         if (!running || paused)
            doDraw();
    };
    document.getElementById("hideturtles").checked = alwaysHideTurtles;
    document.getElementById("lockstep").onchange = function() {randomScheduling = !document.getElementById("lockstep").checked;};
    document.getElementById("lockstep").checked = !randomScheduling;
    document.getElementById("tuok").onclick = gotInput;
    document.getElementById("ynyes").onclick = function() { userInput = 1; gotInput(); };
    document.getElementById("ynno").onclick = function() { userInput = 0; gotInput(); };
    document.getElementById("auok").onclick = doFinishAskUser;
    document.getElementById("runprog").onclick = doRunProgram;
    document.getElementById("indent").onclick = doIndent;
    document.getElementById("errorreport").onmousedown = function() { document.getElementById("errorreport").style.display = "none"; };
    setUpProgramMenu();
    setUpFileHandling();
    doClear();
}





</script>
</head>
<body onload="init()">

<noscript>
   <p style="font-weight: bold; color:red">This page requires Javascript.<br>
   Without Javascript, nothing on this page will be functional.</p>
</noscript>


<p style="border-bottom: 1.5pt solid black;"><span style="font-size:200%; font-weight:bold;margin: 5pt 0 5pt 0;">xTurtle Turtle Graphics</span>
<span style="margin-left: 50pt"><b>Click for: <a href="info.html">information and instructions</a>.</b></span></p>


<table border=0 cellspacing=0 cellpadding=0>

<tr>
  <td>
   <p style="margin:0 0 0 20pt; padding:0">
    Select Program: <select id="selectprogram" title="Sets the contents of the program editor.  To start a new, empty program, select '[New Program]'. To change to an existing program, select its name.">
       <option value="1">User Program 1</option>
    </select>
    </p>
  </td>
  <td align=right>
    <p style="margin: 0 0 0 10pt; padding:0">
       <button id="saveBtn" title="Save the program to a local file.">Save</button>
       <button id="loadBtn" title="Load a program from a local file." style="margin-left:7px">Load</button>
    </p>
  </td>
</tr>

<tr>
   <td colspan=2>
     <p style="padding: 0; margin: 5pt 2pt 5pt 20pt">
        <textarea spellcheck="false" placeholder="Input or paste your xTurtle program here." id="program" wrap="off" rows=20 cols=80></textarea>
     </p>
   </td>
</tr>

<tr>
   <td>
      <p style="margin:0; padding:0"><button style="margin-left:20pt;" id="runprog"
         title="Compile the program and, if no error is found, load it and run it.  If an error is found, it will be reported below.">Run the program!</button>
      </p>
   </td>
   <td align=right>
      <p style="margin:0; padding:0"><button style="margin-left:72pt" id="indent"
         title="Fix the indentation of the lines of the program to show its structure. This can be useful to check for proper nesting when writing a program.">Indent the program</button>
      </p>
   </td>
</tr>
   
</table>


<p style="color: #AA0000; font-weight: bold" id="programerror">&nbsp;</p>
<hr>

  <p id="status">xTurtle status: Idle.</p>


<table border=0 cellpadding=0 cellspacing=0>
<tr valign="top"><td>
<div id="controls">
   <div class="group">
       <p><button id="reset" title="Clear the drawing, forget any subroutines and variables that have been declared, and return the turtle to its default location and properties.">Reset</button>
   </div>
   <div class="group">
       <p><label title="When checked, all turtles are forced to be hidden and only the lines that they draw are shown."><input type="checkbox" id="hideturtles"> Hide Turtles</label></p>
       <p><label title="When checked, in a multitasking program all turtles get exactly equal amounts of processing time.  Only affects program that use the 'Fork' command."><input type="checkbox" id="lockstep"> Lockstep</label></p>
   </div>
   <div class="group">
      <p>Run Speed:</p>
      <p style="margin-left: 20pt"><select id="speedselect" title="Set the speed at which the turtle progresses as a program runs.">
          <option value="1">Fastest</option>
          <option value="2">Faster</option>
          <option value="3">Fast</option>
          <option value="4">Moderate</option>
          <option value="5">Slow</option>
          <option value="6">Slowest</option>
      </select></p>
   </div>
   <div class="group">
      <p><button id="pause" title="Pause execution of the running program.">Pause</button></p>
      <p><button id="run" title="Resume running the program.  Enabled only when the program has been paused.">Continue</button></p>
      <p><button id="stop" title="Stop the execution of the current program; the execution cannot then be resumed.">Abort</button></p>
   </div>
</div>
</td><td>
<div id="turtlediv">
  <p style="margin:0; padding:0">
      <input type="text" size="50" id="command" spellcheck="false" placeholder="Enter xTurtle commands here">
      <button id="doit" title="Run the command or commands in the input box.  You can also just press return while typing in the input box.">Do It!</button></p>
  <p><div id="canvas-holder">
     <canvas id="canvas" width="600" height="600"></canvas>  <!-- NOTE: CANVAS MUST BE SQUARE -->
  </div></p>
  <div class="dialog" id="telluser">
     <p style="text-align: center">(from TellUser)</p>
     <hr>
     <p id="tumessage"></p>
     <p style="text-align: right"><button id="tuok">OK</button></p>
  </div>
  <div class="dialog" id="askuser">
     <p style="text-align: center">(from TellUser; response must be a number)</p>
     <hr>
     <p id="aumessage"></p>
     <p style="text-align: right"><input type="text" size="12" id="auinput"> <button id="auok">OK</button></p>
  </div>
  <div class="dialog" id="yesorno">
     <p style="text-align: center">(from YesOrNo)</p>
     <hr>
     <p id="ynmessage"></p>
     <p style="text-align: right"><button id="ynyes">Yes</button> <button id="ynno">No</button></p>
  </div>
  <div id="errorreport">
     <p style="text-align: center">ERROR</p>
     <hr>
     <p id="errormessage"></p>
  </div>
</div>
</td></tr></table>

</body>
</html>
