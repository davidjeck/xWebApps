<!DOCTYPE html>
<!--
    Web page written by David Eck, http://math.hws.edu/eck/index.html
    You can do anything you like with this web page and with the code, but
    if you use a substantial portion of it, you should include attribution.

    This is a fairly complete "Mandelbrot Set" viewer program, including
    the ability to do arbitrary precision computation (very slowly) when you
    zoom in too far to do the calcultions with regular floating point numbers.
    It can save and load examples as XML in a clunky way, by copy-and-paste
    between files and a textarea that appears when "Show XML Input/Export"
    is clicked.  All of the ideas and some of the code were ported from
    an older program that was written in java.

    This file depends on the scripts mandelbrot-worker.js and Daniel Trebbien's
    BigDecimal-all-last.min.js.
   
    August, 2019. Added Palette Editor.
    January, 2020. Improved Palette Editor.
    April, 2020.  Cleaned up standard palettes, removed a few, added Dark Colors palette.
    May, 2020.  Change maximum image width and height from 2500 to 10000 (but that
        doesn't necessarily mean very large images will work on every device).
    October, 2021.  Fixed a bug in startJob() and startSecondPass() that showed up
        when the change in y-value from one line to the next is very small.  This was
        done previously by successive subtraction, which introduced errors.  Thanks to
        Robert Munafo for finding and fixing the bug.
    August, 2022.  Use localStorage to save workerCount between sessions.
    May, 2023. Attempt to make a WebGPU worker available for high precision computations.
    May, 2023.  Corrected use of putImageData (which was bizarrely wrong in its 
        interpretation of the difference between CSS pixels and device pixels -- but
        in practice the error had no effect on any device where I used this app.
-->
<html>
<head>
<meta charset="UTF-8">
<title>Mandelbrot Viewer</title>
<style type="text/css">
   body {
       background-color: #D8D8D8;
   }
   canvas {
       display: block;
       background-color: #BBBBBB;
   }
   #canvas-holder {
       display: inline-block;
       border: 2px solid black;
       margin: 0;
       padding: 0;
   }
   #controls {
       display: inline-block;
       background-color:white;
       border-left: 2px solid black;
       border-right: 2px solid black;
       border-top: 2px solid black;
       padding: 0;
       margin-right:10px;
   }
   #controls p {
       margin: 12px 0;
       white-space: nowrap;
   }
   div.group {
       padding: 0 8px;
       border-bottom: 2px solid black;
   }
   #imagediv p {
       margin: 4px 0;
       white-space: nowrap;
   }
   #imagediv {
       margin-left: 20px;
       padding: 0;
   }
   #status, #gpuinfo {
       white-space: nowrap;
       font-weight: bold;
       color: #AA0000;
   }
   #xmlimportbg {
       position: fixed;
       z-index: 10;
       opacity: 0.7;
       background-color: black;
       left: 0;
       top: 0;
       width: 100%;
       height: 100%;
       display: none;
   }
   #xmlimport, #paletteEditor {
       position: absolute;
       left: 50px;
       top: 50px;
       z-index:20;
       padding: 10px;
       background-color: #D8D8FF;
       border: 2px solid #000099;
       border-radius: 16px;
       box-shadow: 5px 5px 8px black;
       display: none;
   }
   textarea {
     white-space: pre;
     word-wrap: normal;
     overflow-x: scroll;
   }
</style>
<script src="BigDecimal-all-last.min.js"></script>
<script>

"use strict";

var HP_CUTOFF_EXP = 16;
var HP_CUTOFF = new BigDecimal("1e-16");
var TEN = new BigDecimal("10");
var TWO = new BigDecimal("2");


var OSC;  // Off-screen canvas, holds the the Mandelbrot set.
var OSG;  // Graphics context for on-screen canvas.
var canvas;    // On-screen canvas -- shows OSC, with stuff possibly drawn on top.
var graphics;  // Graphics context for on-screen canvas.

var ArrayType = window.Uint32Array || Array;

var workers;
var wokerCount = 1;
var jobNum = 0;

var running = false;
var repaintTimeout;

var /* BigDecimal */ xmin_requested, ymin_requested, xmax_requested, ymax_requested;
var /* BigDecimal */ xmin, ymin, xmax, ymax;
var /* BigDecimal */ dx, dy;
var /* Uint32Array */ xminArray, yvalArray, dxArray;

var jobs;
var jobsCompleted;
var workerCount = 1;
var jobStartTime, timePerJob;
var highPrecision;

var COMPUTING_FIRST_PASS = 1, DONE_FIRST_PASS = 2, COMPUTING_SECOND_PASS = 3, IDLE = 4;
var state = IDLE;

var dragbox = null;

var maxIterations;
var palette;
var stretchPalette;
var fixedPaletteLength;
var paletteLength, paletteOffsetFraction;
var paletteColors;

var savedIterationCounts;
var savedIterationCounts2ndPass;

var imageData, hres, vres;  // for setting pixel colors.

var currentXML = null;

var undoList = null; // will be an array; null here prevents SetDefaults from adding a spurious undo item
var undoCount = 0;
var applyUndoInProgress = false;

var paletteEditInProgress = false;

var interlaced = true;
var interlaceOrder = (function() {
      var order = [127];
      for (var i = 64; i >= 1; i /= 2) {
          var ct = order.length;
          for (var j = 0; j < ct; j++) {
              order.push(order[j] - i);
          }
      }
      return order;
   })();

var digits, chunks;
var /* BigDecimal */ twoTo16 = new BigDecimal("65536");
var log2of10 = Math.log(10)/Math.log(2);

var gpuWorker;          // Variables added May 2023 for WebGPU support
var gpu_ok = false;
var gpuJobCt;
var cpuJobCt;
var runningWithGPU;
var currentGPUJob;


function convert( /* int[] */ x, /* BigDecimal */ X, /* int */ count) {
    var neg = false;
    if (X.signum() == -1) {
        neg = true;
        X = X.negate();
    }
    x[0] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    for (var i = 1; i < count; i++) {
        X = X.subtract(new BigDecimal(""+x[i-1]));
        X = X.multiply(twoTo16);
        x[i] = Number(X.setScale(0,BigDecimal.ROUND_DOWN).toString());
    }
    if (neg) {
        negate(x,count);
    }
    function negate( /* int[] */ x, /* int */ chunks) {
        for (var i = 0; i < chunks; i++)
            x[i] = 0xFFFF-x[i];
        ++x[chunks-1];
        for (var i = chunks-1; i > 0 && (x[i] & 0x10000) != 0; i--) {
            x[i] &= 0xFFFF;
            ++x[i-1];
        }
        x[0] &= 0xFFFF;
    }
}



function setLimits(x1, x2, y1, y2, recordUndo) {
    var oldLimits = [xmin_requested,xmax_requested,ymin_requested,ymax_requested];
    xmin_requested = x1;
    xmax_requested = x2;
    ymin_requested = y1;
    ymax_requested = y2;
    if (xmax_requested.compareTo(xmin_requested) < 0) {
       var temp = xmin_requested;
       xmin_requested = xmax_requested;
       xmax_requested = temp;
    }
    if (ymax_requested.compareTo(ymin_requested) < 0) {
       var temp = ymax_requested;
       ymax_requested = ymin_requested;
       ymin_requested = temp;
    }
    checkAspect();
    if (recordUndo) {
        addUndoItem("Change Limits", oldLimits, [xmin_requested,xmax_requested,ymin_requested,ymax_requested]);
    }
}

function checkAspect() {  // adjust requested x/y limits to match aspect ratio of image
    xmin = xmin_requested;
    xmax = xmax_requested;
    ymin = ymin_requested;
    ymax = ymax_requested;
    if (xmin.scale() < HP_CUTOFF_EXP + 8)
        xmin = xmin.setScale(HP_CUTOFF_EXP + 8);
    if (xmax.scale() < HP_CUTOFF_EXP + 8)
        xmax = xmax.setScale(HP_CUTOFF_EXP + 8);
    if (ymin.scale() < HP_CUTOFF_EXP + 8)
        ymin = ymin.setScale(HP_CUTOFF_EXP + 8);
    if (ymax.scale() < HP_CUTOFF_EXP + 8)
        ymax = ymax.setScale(HP_CUTOFF_EXP + 8);
    var dx = xmax.subtract(xmin).setScale(Math.max(xmax.scale(),HP_CUTOFF_EXP)*2, BigDecimal.ROUND_HALF_EVEN);
    dx = dx.divide(new BigDecimal("" + canvas.width),BigDecimal.ROUND_HALF_EVEN);
    var precision = 0;
    while (dx.compareTo(TWO) < 0) {
       precision++;
       dx = dx.multiply(TEN);
    }
    if (precision < HP_CUTOFF_EXP)
        precision = HP_CUTOFF_EXP;
    var scale = precision + 5 + Math.floor((precision-10)/10);
    xmin = xmin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    xmax = xmax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymin = ymin.setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    ymax = ymax.setScale(scale,BigDecimal.ROUND_HALF_EVEN);

    var width = xmax.subtract(xmin);
    var height = ymax.subtract(ymin);
    var aspect = width.divide(height,BigDecimal.ROUND_HALF_EVEN);
    var windowAspect = new BigDecimal( "" + canvas.width/canvas.height );
    if (aspect.compareTo(windowAspect) < 0) {
        var newWidth = width.multiply(windowAspect).divide(aspect,BigDecimal.ROUND_HALF_EVEN);
        var center = xmax.add(xmin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        xmax = center.add(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale, BigDecimal.ROUND_HALF_EVEN);
        xmin = center.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
    else if (aspect.compareTo(windowAspect) > 0) {
        var newHeight = height.multiply(aspect).divide(windowAspect,BigDecimal.ROUND_HALF_EVEN);
        var center = ymax.add(ymin).divide(TWO,BigDecimal.ROUND_HALF_EVEN);
        ymax = center.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
        ymin = center.subtract(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN)).setScale(scale,BigDecimal.ROUND_HALF_EVEN);
    }
}


function doDraw() {
    graphics.drawImage(OSC,0,0);
    if (dragbox && dragbox.width > 2 && dragbox.height > 2) {
       dragbox.draw();
    }
}

function repaint() {
    doDraw();
    if (running) {
       repaintTimeout = setTimeout(repaint, 500);
       var pass = state == COMPUTING_SECOND_PASS ? " second pass" : "";
       var prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
       document.getElementById("status").innerHTML =
                "Computing" + pass + ", " + prec + "...  Completed " + jobsCompleted + " of " + canvas.height + " rows";
    }
    else {
        document.getElementById("status").innerHTML = "Idle";
    }
}

function newWorkers(count) { // Note (May 2023): the WebGPU worker is not recreated.
    var i;
    if (workers) {
       for (i = 0; i < workers.length; i++) {
          workers[i].terminate();
       }
    }
    workers = [];
    for (i = 0; i < count; i++) {
       workers[i] = new Worker("mandelbrot-worker.js");
       workers[i].onmessage = jobFinished;
    }
}

function stopJob() {
    if (running) {
       jobNum++;
       running = false;
       document.getElementById("stop").disabled = true;
       if (repaintTimeout)
          clearTimeout(repaintTimeout);
       repaintTimeout = null;
       repaint();
       if (timePerJob < 0 || timePerJob > 150) {
           //console.log("Making new workers");
           newWorkers(workerCount);
       }
    }
}

function startJob() {
    if (running) {
       stopJob();
    }
    graphics.fillRect(0,0,canvas.width,canvas.height);
    OSG.fillStyle="#BBBBBB";
    OSG.fillRect(0,0,canvas.width,canvas.height);
    imageData = OSG.getImageData(0,0,canvas.width,1);
    hres = Math.round(imageData.width/canvas.width);
    vres = imageData.height;
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    highPrecision = dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(new BigDecimal("0"));
    var rows = canvas.height;
    var columns = canvas.width;
    savedIterationCounts = new Array(rows);
    savedIterationCounts2ndPass = new Array(rows+1);
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        dxArray = new ArrayType(chunks+1);
        xminArray = new ArrayType(chunks+1);
        convert(xminArray, xmin, chunks+1);
        convert(dxArray,dx,chunks+1);
        for ( var row = 0; row < rows; row++) {
            var yValArray = new ArrayType(chunks+1);
            convert(yValArray, yVal, chunks+1);
            jobs[rows - 1- row] = {
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray
            };
            yVal = yVal.subtract(dy);
        }
    }
    else {
        var xmin_d = Number(xmin.toString());
        var ymax_d = Number(ymax.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
//        var yVal_d = ymax_d;  // deleted
// Modified October 2021 to fix a bug that showed up when dy_d is very small:
// Compute yVal_d with multiplication rather than by successive subtractions of dy_d.
        for ( var row = 0; row < rows; row++) {
            var yVal_d = ymax_d - row*dy_d;  // added
            jobs[rows - 1- row] = {
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d
            };
//            yVal_d = yVal_d - dy_d;  // deleted
        }
    }
    if (interlaced) {
        var sortedJobs = jobs;
        jobs = [];
        for (var i = 0; i < interlaceOrder.length; i++) {
            for (var j = interlaceOrder[i]; j < sortedJobs.length; j += interlaceOrder.length) {
                jobs.push(sortedJobs[j]);
                //if (sortedJobs[j] == null) {  // for debugging
                //    throw "bad logic";
                //}
                //sortedJobs[j] = null;
            }
        }
    }
    jobsCompleted = 0;
    for (var i = 0; i < workerCount; i++) {
        var j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterations,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal
        ]);
    }
    if (gpu_ok && highPrecision && document.getElementById("gpuselect").checked) {  // WebGPU support Added May 2023
        gpuWorker.postMessage(["setup",jobNum, maxIterations,highPrecision,-1]);  // gpuWorker will respond with [jobNum,"gpuready"]
        document.getElementById("gpuinfo").innerHTML = "Using the WebGPU worker.";
        runningWithGPU = true;
        currentGPUJob = null;
    }
    else {
       document.getElementById("gpuinfo").innerHTML = "&nbsp;";
       runningWithGPU = false;
    }
    gpuJobCt = 0;
    cpuJobCt = 0;
    running = true;
    document.getElementById("stop").disabled = false;
    var prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
    document.getElementById("status").innerHTML = "Computing, " + prec + "...";
    repaintTimeout = setTimeout(repaint,333);
    timePerJob = -1;
    jobStartTime = new Date().getTime();
    state = COMPUTING_FIRST_PASS;
    currentXML = currentExampletoXML();
}

function jobFinished(msg) {
    var job = msg.data;
    if (job[0] === "gpufail") {  // WebGPU support added May 2023
        document.getElementById("gpumessage").innerHTML = "WebGPU has FAILED!! (" + job[2] + ")";
        document.getElementById("gpuinfo").innerHTML = "WebGPU use has been abandoned because of an error.";
        document.getElementById("gpuholder").style.display = "none";
        gpu_ok = false;
        gpuWorker.terminate();
        gpuWorker = null;
        runningWithGPU = false;
        if (currentGPUJob !== null)
            jobs.push(currentGPUJob); // redo the failed job with a CPU worker
        return;
    }
    if (job[0] != jobNum)
       return;
    if (job[1] === "gpuready") { // for WebGPU support, May 2023
       if (jobs.length > 0) {
           var j = jobs.pop();
           gpuWorker.postMessage([
                "task", j.row, j.columns,
                j.xmin, j.dx, j.yVal
            ]);
           currentGPUJob = j;
       }
       return;
    }
    if (jobs.length > 0) {
       var worker = (job[3] === -1)? gpuWorker : workers[job[3]];  // WebGPU support (woker number -1) added May 2023
       var j = jobs.pop();
       worker.postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal
        ]);
       if (job[3] === -1)
          currentGPUJob = j;
    }
    if (job[3] === -1)
       gpuJobCt++;
    else
       cpuJobCt++;
    timePerJob = ( (new Date().getTime()) - jobStartTime) / jobsCompleted;
    var iterationCounts = job[2];
    var row = job[1];
    if (state == COMPUTING_FIRST_PASS) {
       savedIterationCounts[row] = iterationCounts;
       putRow(row);
       if (paletteEditInProgress) {
           histogram.update(iterationCounts);
           palettePreview.update(row,iterationCounts);
       }
    }
    else {
       savedIterationCounts2ndPass[row] = iterationCounts;
       if (row > 0) {
           putRow(row-1);
       }
    }
    jobsCompleted++;
    if (state == COMPUTING_FIRST_PASS) {
        if (jobsCompleted == canvas.height) {
          state = DONE_FIRST_PASS;
          stopJob();
          if (document.getElementById("secondpass").checked) {
             startSecondPass();
          }
          else if (runningWithGPU)  // WebGPU support added May 2023
               document.getElementById("gpuinfo").innerHTML = "WebGPU worker did " + gpuJobCt + " rows; CPU workers did " + cpuJobCt + " rows.";
       }
    }
    else {
        if (jobsCompleted == canvas.height + 1) {
            state = IDLE;
            stopJob();
            if (runningWithGPU)  // WebGPU support added May 2023
               document.getElementById("gpuinfo").innerHTML = "WebGPU worker did " + gpuJobCt + " rows; CPU workers did " + cpuJobCt + " rows.";
        }
    }
}

function startSecondPass() {
    if (running) {
       stopJob();
    }
    dx = xmax.subtract(xmin).divide(new BigDecimal(""+(canvas.width-1)),BigDecimal.ROUND_HALF_EVEN);
    dy = ymax.subtract(ymin).divide(new BigDecimal(""+(canvas.height-1)),BigDecimal.ROUND_HALF_EVEN);
    var dxHalf = dx.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    var dyHalf = dy.divide(TWO,BigDecimal.ROUND_HALF_EVEN);
    highPrecision = dy.compareTo(HP_CUTOFF) < 0;
    jobs = [];
    var yVal = ymax.add(dyHalf);
    var xStart = xmin.subtract(dxHalf);
    var rows = canvas.height + 1;
    var columns = canvas.width + 1;
    if (highPrecision) {
        digits = xmin.scale();
        chunks = Math.floor((digits * log2of10)/16 + 2);
        dxArray = new ArrayType(chunks+1);
        xminArray = new ArrayType(chunks+1);
        convert(xminArray, xStart, chunks+1);
        convert(dxArray,dx,chunks+1);
        for ( var row = 0; row < rows; row++) {
            var yValArray = new ArrayType(chunks+1);
            convert(yValArray, yVal, chunks+1);
            jobs[rows - 1- row] = {
                row: row,
                columns: columns,
                xmin: xminArray,
                dx: dxArray,
                yVal: yValArray
            };
            yVal = yVal.subtract(dy);
        }
    }
    else {
        var xmin_d = Number(xStart.toString());
        var dx_d = Number(dx.toString());
        var dy_d = Number(dy.toString());
//        var yVal_d = Number(ymax.toString()) + dy_d/2;   // deleted
// Modified October 2021 to fix a bug that showed up when dy_d is very small:
// Compute yVal_d by multiplication rather than by successive subtractions of dy_d.
        var yVal_max = Number(ymax.toString()) + dy_d/2;
        for ( var row = 0; row < rows; row++) {
            var yVal_d = yVal_max - row*dy_d; // added
            jobs[rows - 1- row] = {
                row: row,
                columns: columns,
                xmin: xmin_d,
                dx: dx_d,
                yVal: yVal_d
            };
//            yVal_d = yVal_d - dy_d;  // deleted
        }
    }
    jobsCompleted = 0;
    for (var i = 0; i < workerCount; i++) {
        var j = jobs.pop();
        j.workerNum = i;
        workers[i].postMessage(["setup",jobNum, maxIterations,highPrecision,i]);
        workers[i].postMessage([
            "task", j.row, j.columns,
            j.xmin, j.dx, j.yVal
        ]);
    }
    if (runningWithGPU) { // WebGPU support added May 2023
        j.workerNum = -1;
        gpuWorker.postMessage(["setup",jobNum, maxIterations,highPrecision,-1]); // gpuWorker will respond with [jobNum,"gpuready"]
        currentGPUJob = null;
    }
    running = true;
    document.getElementById("stop").disabled = false;
    var prec = highPrecision? "high precision, " + digits + " digits" : "normal precision";
    document.getElementById("status").innerHTML = "Computing 2nd Pass, " + prec + "...";
    repaintTimeout = setTimeout(repaint,500);
    timePerJob = -1;
    jobStartTime = new Date().getTime();
    state = COMPUTING_SECOND_PASS;
}

function putRow(row) {
    var iterationCounts = savedIterationCounts[row];
    var above = savedIterationCounts2ndPass[row];
    var below = savedIterationCounts2ndPass[row+1];
    var average = above && below;
    var secondPassColor;
    var ct;
    if (average) {
       ct = above[0];
       var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       ct = below[0];
       var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
       secondPassColor = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
    }
    var columns = canvas.width;
    for (var i = 0; i < columns; i++) {
       ct = iterationCounts[i];
       var color;
       if (ct < 0) {
          color = [0,0,0];
       }
       else {
          var paletteIndex = iterationCounts[i] % paletteLength;
          color = paletteColors[paletteIndex];
       }
       if (average) {
           ct = above[i+1];
           var c1 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           ct = below[i+1];
           var c2 = ct < 0 ? [0,0,0] : paletteColors[ ct%paletteLength ];
           var secondPassColor2 = [c1[0]+c2[0],c1[1]+c2[1],c1[2]+c2[2]];
           color = [ // had a bug where I modified the color that was still in the palette array!
               ( 4*color[0] + secondPassColor[0] + secondPassColor2[0] ) / 8,
               ( 4*color[1] + secondPassColor[1] + secondPassColor2[1] ) / 8,
               ( 4*color[2] + secondPassColor[2] + secondPassColor2[2] ) / 8
           ];
           secondPassColor = secondPassColor2;
       }
       for (var j = 0; j < vres; j++) {  // fill all hres*vres device pixels in one screen pixel
           var p = (columns*j + i)*4*hres;
           for (var k = 0; k < hres; k++) {
               imageData.data[p] = color[0];
               imageData.data[p+1] = color[1];
               imageData.data[p+2] = color[2];
               imageData.data[p+3] = 255;
           }
       }
    }
    OSG.putImageData(imageData,0,row);
}

function setDefaults() {
    var oldXML = currentXML;
    stopJob();
    setLimits(new BigDecimal("-2.2"), new BigDecimal("0.8"), new BigDecimal("-1.2"), new BigDecimal("1.2"), false);
    stretchPalette = false;
    fixedPaletteLength = 250;
    maxIterations = 1000;
    paletteOffsetFraction = 0;
    palette = new Palette();
    createPaletteColors();
    document.getElementById("maxIterSelect").value = "1000";
    document.getElementById("custommaxiter").style.display = "none";
    document.getElementById("custompallen").style.display = "none";
    document.getElementById("custoffset").style.display = "none";
    document.getElementById("customsize").style.display = "none";
    document.getElementById("paletteLengthSelect").value = "250";
    document.getElementById("paletteOffsetSelect").value = "0";
    document.getElementById("imagesize").value = "800 600";
    if (canvas.width != 800 || canvas.height != 600) {
      canvas.width = 800;
      canvas.height = 600;
      OSC.width = 800;
      OSC.height = 600;
      checkAspect();
    }
    startJob();
    if (undoList) {
        addUndoItem("Restore Defaults", oldXML, currentXML);
    }
}

function remapColors() {
    for (var row = 0; row < canvas.height; row++) {
       if (savedIterationCounts[row]) {
           putRow(row);
       }
    }
    doDraw();
    currentXML = currentExampletoXML();
}

function createPaletteColors() {
    var length = stretchPalette ? maxIterations : fixedPaletteLength;
    paletteLength = length;
    var offset = Math.round(paletteOffsetFraction * paletteLength);
    paletteColors = palette.makeRGBs(paletteLength,offset);
}

function DragBox(x,y) {
    this.x = this.left = x;
    this.y = this.top = y;
    this.width = 0;
    this.height = 0;
}
DragBox.prototype.draw = function() {  // Draw the box on the on-screen canvas
    graphics.strokeStyle = "#FFFFFF";
    graphics.lineWidth = 4;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
    graphics.strokeStyle = "#000000";
    graphics.lineWidth = 2;
    graphics.strokeRect(this.left,this.top,this.width,this.height);
}
DragBox.prototype.setCorner = function(x1,y1) {
    var w = Math.abs(x1 - this.x);
    var h = Math.abs(y1 - this.y);
    if (w < 3 || h < 3) {
        this.width = this.height = 0;
        return;
    }
    var aspect = canvas.width/canvas.height;
    var rectAspect = w / h;
    if (aspect > rectAspect)
        w = Math.round(w*aspect/rectAspect);
    else if (aspect < rectAspect)
        h = Math.round(h*rectAspect/aspect);
    if (this.x < x1) {
        this.left = this.x;
    }
    else {
        this.left = this.x - w;
    }
    if (this.y < y1) {
        this.top = this.y;
    }
    else {
        this.top = this.y - h;
    }
    this.width = w;
    this.height = h;
}
DragBox.prototype.zoom = function(zoomin) {
    if (this.width <= 2 || this.height <= 2)
       return;
    stopJob();
    if (zoomin == false) {
        doZoomOutFromRect(this.left, this.top, this.width, this.height);
    }
    else {
        doZoomInOnRect(this.left, this.top, this.width, this.height);
    }
    startJob();
}

function doZoomInOnRect(x,y,width,height) {
    var rectX = new BigDecimal("" + Math.round(x));  // (Firefox can have fractional parts)
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var pixelWidth = xmax.subtract(xmin).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = ymax.subtract(ymin).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.add(pixelWidth.multiply(rectX));
    newYmax = ymax.subtract(pixelHeight.multiply(rectY));
    var newWidth = pixelWidth.multiply(rectW);
    var newHeight = pixelHeight.multiply(rectH);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, true);
}

function doZoomOutFromRect(x,y,width,height) {
    var rectX = new BigDecimal("" + Math.round(x));
    var rectY = new BigDecimal("" + Math.round(y));
    var rectW = new BigDecimal("" + Math.round(width));
    var rectH = new BigDecimal("" + Math.round(height));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var newPixelWidth = xmax.subtract(xmin).divide(rectW,BigDecimal.ROUND_HALF_EVEN);
    var newPixelHeight = ymax.subtract(ymin).divide(rectH,BigDecimal.ROUND_HALF_EVEN);
    var newXmin,newXmax,newYmin,newYmax;
    newXmin = xmin.subtract(newPixelWidth.multiply(rectX));
    newYmax = ymax.add(newPixelHeight.multiply(rectY));
    var newWidth = newPixelWidth.multiply(ImageWidth);
    var newHeight = newPixelHeight.multiply(ImageHeight);
    newXmax = newXmin.add(newWidth);
    newYmin = newYmax.subtract(newHeight);
    setLimits(newXmin, newXmax, newYmin, newYmax, true);
}

function zoom(x, y, zoomFactor, recenter) {  // (x,y) is center of zoom, in pizels; recenter moves that point to center of image
    stopJob();
    var zf = new BigDecimal("" + zoomFactor);
    var X = new BigDecimal("" + Math.round(x));
    var Y = new BigDecimal("" + Math.round(y));
    var ImageWidth = new BigDecimal("" + canvas.width);
    var ImageHeight = new BigDecimal("" + canvas.height);
    var oldWidth = xmax.subtract(xmin);
    var oldHeight = ymax.subtract(ymin);
    var newWidth = oldWidth.multiply(zf);
    var newHeight = oldHeight.multiply(zf);
    if (newWidth.compareTo(new BigDecimal("100")) > 0) {
        document.getElementById("status").innerHTML =
            "Zooming out that far would reduce the whole Mandelbrot set to a dot.  Ignored.";
        return;
    }
    var pixelWidth = newWidth.divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN);
    var pixelHeight = newHeight.divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN);
    var centerX = xmin.add(X.multiply(oldWidth).divide(ImageWidth,BigDecimal.ROUND_HALF_EVEN));
    var centerY = ymax.subtract(Y.multiply(oldHeight).divide(ImageHeight,BigDecimal.ROUND_HALF_EVEN));
    var newXmin,newXmax,newYmin,newYmax;
    if (recenter) {
        newXmin = centerX.subtract(newWidth.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
        newYmax = centerY.add(newHeight.divide(TWO,BigDecimal.ROUND_HALF_EVEN));
    }
    else {
        newXmin = centerX.subtract(X.multiply(pixelWidth));
        newYmax = centerY.add(Y.multiply(pixelHeight));
    }
    newYmin = newYmax.subtract(newHeight);
    newXmax = newXmin.add(newWidth);
    setLimits(newXmin, newXmax, newYmin, newYmax, true);
    startJob();
}


function setUpDragging() {  // for image canvas
    var zoomin;
    var startX, startY; // for mouse only
    dragbox = null;  // initially, the mouse is not being dragged.
    canvas.addEventListener("dblclick",doMouseDoubleClick,false);
    new Mouser(canvas, startDrag, continueDrag, endDrag, true);
    function startDrag(x,y,evt) {
        if (evt && evt.button != 0)  // only allow left button to start drag
            return false;
        startX = x;
        startY = y;
        dragbox = null;
        zoomin = ! (evt && evt.shiftKey); 
        return true;
    }
    function continueDrag(x,y) {  
        if (dragbox == null) {
            if ( Math.abs(startX - x) < 3 && Math.abs(startY - y) < 3) {
                return;  // don't show zoombox until mouse/touch has moved a bit.
            }
            dragbox = new DragBox(startX,startY);
        }
        dragbox.setCorner(x,y);
        doDraw();
    }
    function endDrag() {
        if (dragbox != null) {
            dragbox.zoom(zoomin);
            dragbox = null;
            doDraw();
        }
    }
    function doMouseDoubleClick(evt) { 
        if (dragbox || evt.button != 0) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        var zoomFactor = evt.shiftKey? 2 : 0.5;
        zoom(x,y,zoomFactor,!evt.altKey);
    }
 }

function Mouser(canvas, startDrag, continueDrag, endDrag, mouseMoveOnCanvasOnly) {
      // functions startDrag, continueDrag take canvas coords (x,y); for a mouse event event object is also passed.
      // function endDrag takes no parameter for touched, mouse event for mouse actions.
      // function startDrag returns a boolean, true if the down action should start a drag.
    var dragging = false;
    canvas.addEventListener("mousedown",doMouseDown,false);
    canvas.addEventListener("touchstart",doTouchStart,false);
    function doMouseDown(evt) { 
        if (dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        if (startDrag(x,y,evt)) {
            dragging = true;
            (mouseMoveOnCanvasOnly? canvas : document).addEventListener("mousemove",doMouseMove,false);
            document.addEventListener("mouseup",doMouseUp,false);
        }
    }
    function doMouseMove(evt) {
        if (!dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;
        continueDrag(x,y,evt); 
    }
    function doMouseUp(evt) {
        if (dragging) {  
            dragging = false;
            (mouseMoveOnCanvasOnly? canvas : document).removeEventListener("mousemove",doMouseMove,false);
            document.removeEventListener("mouseup",doMouseUp,false);
            endDrag(evt);
        }
    }
    function doTouchStart(evt){
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        evt.preventDefault();
        if (dragging) {
            return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.touches[0].clientX - r.left;
        var y = evt.touches[0].clientY - r.top;
        if (startDrag(x,y)) {
            dragging = true;
            canvas.addEventListener("touchmove", doTouchMove);
            canvas.addEventListener("touchend", doTouchEnd);
            canvas.addEventListener("touchcancel", doTouchCancel);
        }
    }
    function doTouchMove(evt){
        if (!dragging)
           return;
        evt.preventDefault();
        if (evt.touches.length != 1) {
           doTouchCancel();
           return;
        }
        var r = canvas.getBoundingClientRect();
        var x = evt.touches[0].clientX - r.left;
        var y = evt.touches[0].clientY - r.top;
        continueDrag(x,y);
    }
    function doTouchEnd(evt) {
        doTouchCancel();
    }
    function doTouchCancel() {
        if (dragging) {
           canvas.removeEventListener("touchmove", doTouchMove);
           canvas.removeEventListener("touchend", doTouchEnd);
           canvas.removeEventListener("touchcancel", doTouchCancel);
           endDrag();
           dragging = false;
        }
    }
}

function changeWorkerCount() {
    var ct = Number(document.getElementById("threadCountSelect").value);
    if (workers && ct == workers.length)
       return;
    var restart  = running;
    if (running) {
        stopJob();
    }
    workerCount = ct;
    newWorkers(ct);
    if (restart) {
        startJob();
    }
    try {
      localStorage.setItem("mandelbrotWorkerCount", "" + ct);
    }
    catch(e) {
    }
}

function changeMaxIterations() {
    var val = document.getElementById("maxIterSelect").value;
    var iter;
    if (val == "Custom") {
        document.getElementById("maxiterinput").value = "" + maxIterations;
        document.getElementById("custommaxiter").style.display = "inline";
    }
    else {
        document.getElementById("custommaxiter").style.display = "none";
        iter = Number(val);
        setMaxIterations(iter);
    }
}
function setMaxIterations(iter) {
    if (iter == maxIterations)
       return;
    var oldval = maxIterations;
    stopJob();
    maxIterations = iter;
    createPaletteColors();
    startJob();
    addUndoItem("Change MaxIterations", oldval, maxIterations);
}
function doCustomMaxIterations() {
    var iter = Math.round(Number(document.getElementById("maxiterinput").value.trim()));
    if (isNaN(iter) || iter < 10) {
        document.getElementById("status").innerHTML = "Illegal value for max iterations.  Must be an integer greater than 9.";
        return;
    }
    setMaxIterations(iter);
}


function changePaletteLength() {
    var val = document.getElementById("paletteLengthSelect").value;
    var len;
    if (val == "Custom") {
        var length = stretchPalette ? maxIterations : fixedPaletteLength;
        stretchPalette = false;
        fixedPaletteLength = length;
        document.getElementById("palleninput").value = "" + length;
        document.getElementById("custompallen").style.display = "inline";
    }
    else if (val == "Match") {
        var oldval = [stretchPalette, stretchPalette ? maxIterations : fixedPaletteLength];
        stretchPalette = true;
        if (paletteLength != maxIterations) {
            stopJob();
            createPaletteColors();
            startJob();
            addUndoItem("Change PaletteLength", oldval, [stretchPalette,paletteLength]);
        }
        document.getElementById("custompallen").style.display = "none";
    }
    else {
       len = parseInt(val);
       if (len != paletteLength) {
          addUndoItem("Change PaletteLength", [stretchPalette, paletteLength], [false,len]);
       }
       setFixedPaletteLength(len);
       document.getElementById("custompallen").style.display = "none";
    }
}
function setFixedPaletteLength(len) {
    fixedPaletteLength = len;
    stretchPalette = false;
    if (fixedPaletteLength != paletteLength) {
       createPaletteColors();
       remapColors();
    }
}
function doCustomPaletteLength() {
    var val = Math.round(Number(document.getElementById("palleninput").value.trim()));
    if (val == fixedPaletteLength)
        return;
    if (isNaN(val) || val < 1) {
        document.getElementById("status").innerHTML = "Illegal value for number of colors.  Must be an integer greater than zero.";
        return;
    }
    var oldval = [false,fixedPaletteLength];
    var newval = [false,val];
    addUndoItem("Change PaletteLength", oldval, newval);
    setFixedPaletteLength(val);
}

function changePaletteOffset() {
    var val = document.getElementById("paletteOffsetSelect").value;
    if (val == "Custom") {
        var current = 100 * paletteOffsetFraction;
        document.getElementById("offsetinput").value = (current == Math.round(current))? current : current.toPrecision(3);
        document.getElementById("custoffset").style.display = "inline";
    }
    else {
        var fractionOffset = Number(val);
        setPaletteOffset(fractionOffset);
        document.getElementById("custoffset").style.display = "none";
    }
}
function doApplyCustomPaletteOffset() {
    var val = Number(document.getElementById("offsetinput").value.trim());
    if (isNaN(val) || val < 0 || val > 100) {
        document.getElementById("status").innerHTML =
             "Illegal value for percentage offset.  Must be a number in the range 0 to 100.";
    }
    else {
       setPaletteOffset(val/100);
    }
}
function setPaletteOffset(fractionOffset) {
    document.getElementById("status").innerHTML = "Idle";
    if (fractionOffset == paletteOffsetFraction) {
        return;
    }
    addUndoItem("Change PaletteOffset", paletteOffsetFraction, fractionOffset);
    paletteOffsetFraction = fractionOffset;
    createPaletteColors();
    remapColors();
}

function changeInterlaced() {
   var checked = document.getElementById("interlaced").checked;
   if (checked == interlaced) {
       return;
   }
   interlaced = checked;
   if (running) {
       stopJob();
       startJob();
   }
}

function changeImageSize() {
    var val = document.getElementById("imagesize").value;
    if (val == "Custom") {
        document.getElementById("customwidth").value = "" + canvas.width;
        document.getElementById("customheight").value = "" + canvas.height;
        document.getElementById("customsize").style.display = "inline";
    }
    else {
        document.getElementById("customsize").style.display = "none";
        var sizes = val.split(" ");
        var width = Number(sizes[0]);
        var height = Number(sizes[1]);
        setImageSize(width,height,true);
    }
}
function setImageSize(w,h) {
    if (w == canvas.width && h == canvas.height) {
        return;
    }
    var oldval = [canvas.width,canvas.height];
    stopJob();
    canvas.width = w;
    canvas.height = h;
    OSC.width = w;
    OSC.height = h;
    checkAspect();
    startJob();
    addUndoItem("Change Image Size", oldval, [canvas.width,canvas.height]);
}
function doCustomSize() {
    var width = Math.round(Number(document.getElementById("customwidth").value.trim()));
    var height = Math.round(Number(document.getElementById("customheight").value.trim()));
    if (isNaN(width) || width < 50 || width > 10000) {
        document.getElementById("status").innerHTML = "Illegal value for image width.  Must be an integer in the range 50 to 10000.";
        return;
    }
    if (isNaN(height) || height < 50 || height > 10000) {
        document.getElementById("status").innerHTML = "Illegal value for image height.  Must be an integer in the range 50 to 10000.";
        return;
    }
    setImageSize(width,height,true);
}

function doApplyStandardPalette() {
    var name = document.getElementById("standardPaletteSelect").value;
    var oldval = palette;
    palette = Palette.createStandardPalette(name);
    createPaletteColors();
    remapColors();
    addUndoItem("Change Palette", oldval.copy(), palette.copy());
}

function changeSecondPass() {
    var checked = document.getElementById("secondpass").checked;
    if (checked && !running && state == DONE_FIRST_PASS) {
        startSecondPass();
    }
}

function doZoomIn() {
    zoom(canvas.width/2, canvas.height/2, document.getElementById("zoomInAmount").value, false);
}

function doZoomOut() {
    zoom(canvas.width/2, canvas.height/2, document.getElementById("zoomOutAmount").value, false);
}

//---------------------- Undo/Redo ---------------------------------------

function doUndo() {
    if (undoCount > 0) {
        var item = undoList[undoCount-1];
        undoCount--;
        document.getElementById("undo").disabled = (undoCount == 0);
        document.getElementById("undo").innerHTML = undoCount? ("Undo " + undoList[undoCount-1].name) : "Undo";
        document.getElementById("redo").disabled = false;
        document.getElementById("redo").innerHTML = "Redo " + item.name;
        applyUndoItem(item.name, item.oldValue);
    }
}

function doRedo() {
    if (undoCount < undoList.length) {
        var item = undoList[undoCount];
        undoCount++;
        document.getElementById("undo").disabled = false;
        document.getElementById("undo").innerHTML = "Undo " + item.name;
        document.getElementById("redo").disabled = (undoCount == undoList.length);
        document.getElementById("redo").innerHTML = (undoCount < undoList.length)? ("Redo " + undoList[undoCount].name) : "Redo";
        applyUndoItem(item.name, item.newValue);
    }
}

function addUndoItem(name, oldValue, newValue) {  
    if (applyUndoInProgress) {
        return;
    }
    undoList.length = undoCount;
    undoList.push( { name: name, oldValue: oldValue, newValue: newValue } );
    if (undoList.length > 100) {
        undoList.shift();
    }
    undoCount = undoList.length;
    document.getElementById("undo").disabled = false;
    document.getElementById("undo").innerHTML = "Undo " + name;
    document.getElementById("redo").disabled = true;
    document.getElementById("redo").innerHTML = "Redo";
}

function applyUndoItem(name, value) {
    applyUndoInProgress = true;
    switch (name) {
      case "Restore Defaults":
      case "Import Example":
         installExampleFromXML(value,false,true);
         break;
      case "Change PaletteOffset":
         setPaletteOffset(value);
         createPaletteColors();
         remapColors();
         break;
      case "Change Limits":
         stopJob();
         setLimits(value[0],value[1],value[2],value[3],false);
         startJob();
         break;
      case "Change Image Size":
         setImageSize(value[0],value[1]);
         var val = value[0] + " " + value[1];
         if (["200 150", "400 300", "640 480", "800 600", "1024 768", "1200 900", "1600 900", "425 550", "850 1100"].indexOf(val) < 0) {
             document.getElementById("imagesize").value = "Custom";
             document.getElementById("customsize").style.display = "inline";
             document.getElementById("customwidth").value = "" + value[0];
             document.getElementById("customheight").value = "" + value[1];
         }
         else {
             document.getElementById("imagesize").value = val;
             document.getElementById("customsize").style.display = "none";
         }
         break;
      case "Change PaletteLength":
         setPaletteLength(value[0],value[1]);
         createPaletteColors();
         remapColors();
         break;
      case "Change MaxIterations":
         setMaxIterations(value);
         if ([25,50,100,250,500,1000,2500,5000,10000,25000,50000].indexOf(value) < 0) {
             document.getElementById("custommaxiter").style.display = "inline";
             document.getElementById("maxIterSelect").value = "Custom";
             document.getElementById("maxiterinput").value = "" + value;
         }
         else {
             document.getElementById("custommaxiter").style.display = "none";
             document.getElementById("maxIterSelect").value = "" + value;
         }
         break;
      case "Change Palette":
         palette = value.copy();
         createPaletteColors();
         remapColors();
         break;
      case "Edit Palette":
        palette = value[0].copy();
        setPaletteLength(value[1],value[2]);
        setPaletteOffset(value[3]);
        createPaletteColors();
        remapColors();
        break;
    }
    applyUndoInProgress = false;
    function setPaletteLength(stretch,length) {
         if (stretch) {
            stretchPalette = true;
            document.getElementById("paletteLengthSelect").value = "Match";
            document.getElementById("custompallen").style.display = "none";
         }
         else  {
             stretchPalette = false;
             fixedPaletteLength = length;
             if ([50,100,250,500,1000,2500,5000].indexOf(length) < 0) {
                document.getElementById("custompallen").style.display = "inline";
                document.getElementById("paletteLengthSelect").value = "Custom";
                document.getElementById("palleninput").value = "" + length;
             }
             else {
                document.getElementById("custompallen").style.display = "none";
                document.getElementById("paletteLengthSelect").value = "" + length;
             }
         }
    }
    function setPaletteOffset(fraction) {
         paletteOffsetFraction = fraction;
         if ([0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9].indexOf(fraction) < 0) {
              document.getElementById("paletteOffsetSelect").value = "Custom";
              document.getElementById("custoffset").style.display = "inline";
              fraction *= 100;
              document.getElementById("offsetinput").value = (fraction == Math.round(fraction))? fraction : fraction.toPrecision(3);
         }
         else {
              document.getElementById("paletteOffsetSelect").value = "" + fraction;
              document.getElementById("custoffset").style.display = "none";
         }
    }
}

//--------------------- Palette ------------------------------------------
function Palette(colorType,divisionPoints,colors) {
   this.colorType = colorType || "HSB";
   this.divisionPoints = divisionPoints || [0,1];
   this.divisionColors = colors || (this.colorType == "HSB" ? [ [0,1,1], [1,1,1] ] : [ [1,1,1], [0,0,0] ]);
}
Palette.prototype.getColor = function(position) {  // 0.0 <= position <= 1.0
    var pt = 1;
    while (position > this.divisionPoints[pt])
        pt++;
    var ratio = (position - this.divisionPoints[pt-1]) /
                   (this.divisionPoints[pt] - this.divisionPoints[pt-1]);
    var c1 = this.divisionColors[pt-1];
    var c2 = this.divisionColors[pt];
    var a = c1[0] + ratio*(c2[0] - c1[0]);
    var b = c1[1] + ratio*(c2[1] - c1[1]);
    var c = c1[2] + ratio*(c2[2] - c1[2]);
    return this.toRGB(a,b,c);
};
Palette.prototype.toRGB = function(a,b,c) {  // 3 non-clamped color components.
    a = (this.colorType == "HSB")? (a - Math.floor(a)) : clamp(a);
    b = clamp(b);
    c = clamp(c);
    var color;
    if (this.colorType == "HSB")
        color = rgbFromHSV(a, b, c);
    else
        color = [a,b,c];
    color[0] = Math.round(color[0]*255);
    color[1] = Math.round(color[1]*255);
    color[2] = Math.round(color[2]*255);
    return color;
	function clamp(x) {
		x = 2*(x/2 - Math.floor(x/2));
		if (x > 1)
			x = 2 - x;
		return x;
	}
    function rgbFromHSV(h,s,v) {  // all components in range 0 to 1
        h *= 360;
        var r,g,b;
        var c,x;
        c = v*s;
        x = (h < 120)? h/60 : (h < 240)? (h-120)/60 : (h-240)/60;
        x = c * (1-Math.abs(x-1));
        x += (v-c);
        switch (Math.floor(h/60)) {
            case 0: r = v; g = x; b = v-c; break;
            case 1: r = x; g = v; b = v-c; break;
            case 2: r = v-c; g = v; b = x; break;
            case 3: r = v-c; g = x; b = v; break;
            case 4: r = x; g = v-c; b = v; break;
            case 5: r = v; g = v-c; b = x; break;
        }
        return [r,g,b];
    }
};
Palette.prototype.makeRGBs = function(paletteLength, offset) {
    var rgb = new Array(paletteLength);
    rgb[offset % paletteLength] =
             this.toRGB(this.divisionColors[0][0],this.divisionColors[0][1],this.divisionColors[0][2]);
    var dx = 1.0 / (paletteLength-1);
    for (var i = 1; i < paletteLength-1; i++) {
        rgb[(offset+i) % paletteLength] = this.getColor(i*dx);
    }
    var last = this.divisionColors.length - 1;
    rgb[(offset+paletteLength-1) % paletteLength] =
              this.toRGB(this.divisionColors[last][0],this.divisionColors[last][1],this.divisionColors[last][2]);
    return rgb;
};
Palette.prototype.makeCanvasColors = function(paletteLength, offset) {
    var rgb = this.makeRGBs(paletteLength,offset);
    var colors = new Array(rgb.length);
    for (var i = 0; i < rgb.length; i++)
        colors[i] = "rgb(" + rgb[i][0] + "," + rgb[i][1] + "," + rgb[i][2] + ")";
    return colors;
};
Palette.prototype.toXMLString = function() {
   var xml = "<palette colorType='" + this.colorType + "'>\n";
   for (var i = 0; i < this.divisionPoints.length; i++) {
       xml += "   <divisionPoint position='" + this.divisionPoints[i] + "' color='" +
            this.divisionColors[i][0] + ";" + this.divisionColors[i][1] + ";" +this.divisionColors[i][2] +
            "'/>\n";
   }
   xml += "</palette>\n";
   return xml;
};
Palette.prototype.copy = function() {
    var divColors = [];
    for (var i = 0; i < this.divisionColors.length; i++) {
        divColors.push(this.divisionColors[i].slice(0));
    }
    return new Palette(this.colorType,this.divisionPoints.slice(0),divColors);
};
Palette.fromXML = function( paletteNode ) {  // can throw an exception
    try {
       var children = paletteNode.childNodes;
       var type = paletteNode.getAttribute("colorType") || "RBG";
       if (type != "HSB" && type != "RGB") {
           throw "Bad colorType.";
       }
       var points = [];
       var colors = [];
       for (var i = 0; i < children.length; i++) {
          var child = children.item(i);
          if (child.nodeType == 1 && child.tagName == "divisionPoint") { // element node
              var pt = child.getAttribute("position");
              var rgb = child.getAttribute("color");
              if (pt === null || rgb === null) {
                  throw "Missing data for divisionPoint";
              }
              pt = Number(pt);
              rgb = rgb.split(";");
              rgb = [Number(rgb[0]),Number(rgb[1]),Number(rgb[2])];
              if (isNaN(pt) || pt < 0 || pt > 1) {
                   throw "Bad data for divisionPoint";
              }
              for (var j = 0; j < 3; j++) {
                   if (isNaN(rgb[j]) || rgb[j] < 0 ){
                      throw "Bad data for divisionPoint color";
                   }
                   else if (rgb[j] < 0) {
                      throw "Color component number " + (j+1) + " can't be less than zero.";
                   }
                   else if (rgb[j] > 1 && (j > 0 || type == "RGB")) {
                      throw "Color component number " + (j+1) + " can't be greater than one.";
                   }
              }
              if (i > 0 && pt <= points[points.length-1]) {
                  throw "Division points out of order";
              }
              points.push(pt);
              colors.push(rgb);
          }
       }
       if (points.length < 2 || points[0] != 0 || points[points.length-1] != 1) {
           throw "Illegal divisionPoint data";
       }
       return new Palette(type, points, colors);
    }
    catch (e) {
        throw "Illegal palette definition: " + e;
    }
};
Palette.createStandardPalette = function(name) {
    var palette;
    switch (name) {
        case "Grayscale":
           palette = new Palette("RGB");
           break;
        case "CyclicGrayscale":
           palette = new Palette("RGB",[0,0.5,1],[[0,0,0],[1,1,1],[0,0,0]]);
           break;
        case "Red/Cyan":
           palette = new Palette("RGB",[0,0.5,1],[[1,0,0],[0,1,1],[1,0,0]]);
           break;
        case "Blue/Gold":
           palette = new Palette("RGB",[0,0.5,1],[[0.1,0.1,1],[1,0.6,0],[0.3,0.3,1]]);
           break;
        case "EarthAndSky":
           palette = new Palette("RGB",[0,0.15,0.33,0.67,0.85,1],
                     [[1,1,1],[1,0.8,0],[0.53,0.12,0.075],[0,0,0.6],[0,0.4,1],[1,1,1]]);
           break;
        case "HotAndCold":
           palette = new Palette("RGB",[0,0.16,0.5,0.84,1],
                     [[1,1,1],[0,0.4,1],[0.2,0.2,0.2],[1,0,0.8],[1,1,1]]);
           break;
        case "Fire":
           palette = new Palette("RGB",[0,0.17,0.83,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1]]);
           break;
        case "Cyclic Fire":
           palette = new Palette("RGB",[0,0.2,0.4,0.5,0.6,0.8,1],
                     [[0,0,0],[1,0,0],[1,1,0],[1,1,1],[1,1,0],[1,0,0],[0,0,0]]);
           break;
        case "TreeColors":
           palette = new Palette("HSB",[0,0.33,0.66,1],
                     [[0.1266,0.5955,0.2993],[0.0896,0.3566,0.6575],[0.6195,0.8215,0.4039],[0.1266,0.5955,0.2993]]);
           break;
        case "Seashore":
           palette = new Palette("RGB",[0,0.1667,0.3333,0.5,0.6667,0.8333,1],
                     [[0.7909,0.9961,0.7630],[0.8974,0.8953,0.6565],[0.9465,0.3161,0.1267],[0.5184,0.1109,0.0917],
                              [0.0198,0.4563,0.6839],[0.5385,0.8259,0.8177],[0.7909,0.9961,0.7630]]);
           break;
        case "Pastels":
           palette = new Palette("RGB",[0,0.180781,0.418566,0.627035,0.858306,1],
                     [ [ 0.80585,0.81648,0.82180 ], [ 0.43882,0.52393,1 ], [ 1,0.35904,0.58244 ],
                       [ 1,1,0.52127 ], [ 0.54787,0.93351,0.56914 ], [ 0.80585,0.81648,0.82180 ] ]);
           break;
        case "Dark":
           palette = new Palette("RGB",['0','0.18241042','0.38599348','0.57166123','0.78338762','1'],
                         [  [0.65957446,0,0],[0,0.30585106,0.58776595],[0.81648936,0.41489361,0.07180851],
                                [0,0.48670212,0.16489361],[0.29787234,0.13829787,0.75],[0.65957446,0,0] ]);
//           palette = new Palette("RGB",[0,0.18241,0.38599,0.57166,0.78338,1],
//                       [ [0.65957,0,0],[0,0.40159,0.74734],[0.87234,0.49202,0.07180],
//                           [0,0.48670,0.16489],[0.29787,0.13829,0.75], [0.65957,0,0] ]);
           break;
        case "Random":
           var c = [Math.random(),Math.random(),Math.random()];
           palette = new Palette("RGB",[],[]);
           palette.divisionPoints[0] = 0;
           palette.divisionColors[0] = c;
           for (var i = 1; i <= 5; i++) {
               palette.divisionPoints[i] = i/6;
               palette.divisionColors[i] = [Math.random(),Math.random(),Math.random()];
           }
           palette.divisionPoints[6] = 1;
           palette.divisionColors[6] = c;
           break;
        default: // "Spectrum"
           palette = new Palette();
    }
    return palette;
};

//----- Palette Editor ---------------------------------------------------------------

function showPaletteEditor() {
    if (!colorEditCanvas) {  // showing for the first time, do initialization
        document.getElementById("applyPaletteEdit").onclick = applyAndClose;
        document.getElementById("revertPaletteEdit").onclick = revert;
        document.getElementById("dismissPaletteEdit").onclick = dismiss;
        document.getElementById("addcolorstop").onclick = function() { colorEditCanvas.addColorStop(); };
        document.getElementById("deletecolorstop").onclick = function() { colorEditCanvas.deleteColorStop(); };
        document.getElementById("lockcolors").onchange = setLeftRightColorsLocked;
        document.getElementById("paletteEditStandardInstall").onclick = installStandard;
        document.getElementById("paletteEditStandardSelect").value = "EarthAndSky";
        document.addEventListener("keydown", doKey, false);
        updateDuringDrag = document.getElementById("updateWhileDraggingCheck").checked;
        document.getElementById("updateWhileDraggingCheck").oninput = function() { 
           updateDuringDrag =document.getElementById("updateWhileDraggingCheck").checked;
        };
        histogramPalette = document.getElementById("histogrampalette");
        colorEditCanvas = new ColorEditCanvas();
        colorSliders = [ 
           new SliderAndInput(document.getElementById("colorslider0"), document.getElementById("colorinput0"), 0, 1),
           new SliderAndInput(document.getElementById("colorslider1"), document.getElementById("colorinput1"), 0, 1),
           new SliderAndInput(document.getElementById("colorslider2"), document.getElementById("colorinput2"), 0, 1)
        ];
        colorSliders[0].onchange = function(v) { newColorSliderValue(0,v); };
        colorSliders[1].onchange = function(v) { newColorSliderValue(1,v); };
        colorSliders[2].onchange = function(v) { newColorSliderValue(2,v); };
        paletteLengthSlider = new SliderAndInput(document.getElementById("lengthslider"), document.getElementById("editorlengthinput"), 1, maxIterations, paletteLength, true, true);
        paletteOffsetSlider = new SliderAndInput(document.getElementById("offsetslider"), document.getElementById("editoroffsetinput"), 0, 100, paletteOffsetFraction*100);
        paletteLengthSlider.onchange = newPaletteMappingInEditor;
        paletteOffsetSlider.onchange = newPaletteMappingInEditor;
    }
    paletteEditInProgress = true;
    document.getElementById("paletteEditor").style.display="block";
    document.getElementById("xmlimportbg").style.display = "block";
    copyOfCurrentPalette = palette.copy();
    histogram = new Histogram();
    palettePreview = new PalettePreview();
    installPaletteInEditor(palette);
    paletteLengthSlider.reset(1,maxIterations,paletteLength);
    paletteOffsetSlider.setValue(paletteOffsetFraction*100);
    document.getElementById("applyPaletteEdit").disabled = true;
    document.getElementById("revertPaletteEdit").disabled = true;
    function applyAndClose() {
        var newval = [paletteInEditor, false, paletteLengthInEditor, paletteOffsetFractionInEditor];
        addUndoItem("Edit Palette", 
                       [copyOfCurrentPalette, stretchPalette, fixedPaletteLength, paletteOffsetFraction], 
                       newval);
        applyUndoItem("Edit Palette", newval);
        dismiss();
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("paletteEditor").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
        paletteEditInProgress = false;
        histogram = null;
        palettePreview = null;
        paletteInEditor = null;
        colorsInEditor = null;
    }
    function revert() { 
        installPaletteInEditor( copyOfCurrentPalette );
        palettePreview.redraw();
        document.getElementById("applyPaletteEdit").disabled = true;
        document.getElementById("revertPaletteEdit").disabled = true;
    }
    function installStandard() {
        var name = document.getElementById("paletteEditStandardSelect").value;
        var p = Palette.createStandardPalette(name);
        installPaletteInEditor( p, paletteLengthInEditor, paletteOffsetFractionInEditor );
        document.getElementById("applyPaletteEdit").disabled = false;
        document.getElementById("revertPaletteEdit").disabled = false;
        palettePreview.redraw();
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

var copyOfCurrentPalette;
var paletteInEditor;
var paletteLengthInEditor;
var paletteOffsetFractionInEditor;
var histogram;
var histogramPalette;
var palettePreview;
var colorEditCanvas = null;
var leftRightColorsLocked;
var saveRightColorWhileLocked;
var colorsInEditor;
var colorSliders;
var paletteLengthSlider;
var paletteOffsetSlider;
var updateDuringDrag;

function installPaletteInEditor(palette,length,offsetFraction) {
    paletteInEditor = palette.copy();
    var leftCol = paletteInEditor.divisionColors[0];
    var rightCol = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
    var locked = leftCol[1] == rightCol[1] && leftCol[2] == rightCol[2] &&
           (leftCol[0] == rightCol[0] || (paletteInEditor.colorType == "HSB" &&
                leftCol[0] - Math.floor(leftCol[0]) == rightCol[0] - Math.floor(rightCol[0])));
    colorEditCanvas.setLocked(locked,true);
    document.getElementById("lockcolors").checked = locked;
    paletteLengthInEditor = (typeof length != "undefined")? length : paletteLength;
    paletteLengthSlider.setValue(paletteLengthInEditor);
    paletteOffsetFractionInEditor = (typeof offsetFraction != "undefined")? offsetFraction : paletteOffsetFraction;
    paletteOffsetSlider.setValue(paletteOffsetFractionInEditor*100);
    colorEditCanvas.colorsChanged();
    colorEditCanvas.select(0);
    newColorsInEditor();
    if (!updateDuringDrag)
        palettePreview.redraw();
    if (palette.colorType == "RGB") {
        document.getElementById("colorlabel0").innerHTML = "Red";
        document.getElementById("colorlabel1").innerHTML = "Green";
        document.getElementById("colorlabel2").innerHTML = "Blue";
    }
    else {
        document.getElementById("colorlabel0").innerHTML = "Hue";
        document.getElementById("colorlabel1").innerHTML = "Saturation";
        document.getElementById("colorlabel2").innerHTML = "Brightness";
    }
    if (palette.colorType == "HSB")
        colorSliders[0].setAllowOutOfRange( true, true  );
    else
        colorSliders[0].setAllowOutOfRange( false, false);
    if (palette.colorType == "HSB") { 
       var n = Math.floor(palette.divisionColors[0][0]);
       colorSliders[0].reset(n,n+1,palette.divisionColors[0][0]);
       colorSliders[0].canvas.title = "Drag the slider to set the hue of the selected color stop to a value in the range " +
                                       n + " to " + (n+1) + ". Values outside this range can be set in the textbox.";
    }
    else {
       colorSliders[0].reset(0,1,palette.divisionColors[0][0]);
       colorSliders[0].canvas.title = "Drag the slider to set the red component of the selected color stop to a value in the range 0.0 to 1.0.";
    }
    colorSliders[1].setValue(palette.divisionColors[0][1]);
    colorSliders[2].setValue(palette.divisionColors[0][2]);
}

function newColorsInEditor() {
    var offset = Math.round(paletteLengthInEditor * paletteOffsetFractionInEditor);
    colorsInEditor = paletteInEditor.makeCanvasColors(paletteLengthInEditor,offset);
    colorEditCanvas.draw();
    if (updateDuringDrag)
        palettePreview.redraw();
    redrawHistogramPalette();
    document.getElementById("applyPaletteEdit").disabled = false;
    document.getElementById("revertPaletteEdit").disabled = false;
}

function newPaletteMappingInEditor() {
    paletteLengthInEditor = paletteLengthSlider.value;
    paletteOffsetFractionInEditor = paletteOffsetSlider.value / 100;
    var offset = Math.round(paletteLengthInEditor * paletteOffsetFractionInEditor);
    colorsInEditor = paletteInEditor.makeCanvasColors(paletteLengthInEditor,offset);
    if (updateDuringDrag)
        palettePreview.redraw();
    redrawHistogramPalette();
    document.getElementById("applyPaletteEdit").disabled = false;
    document.getElementById("revertPaletteEdit").disabled = false;
}

function newColorSliderValue(componentIndex,value) {
   var colorNum = colorEditCanvas.getSelected();
   var color = paletteInEditor.divisionColors[colorNum];
   color[componentIndex] = value;
   var color2 = null;
   if (leftRightColorsLocked) {
       if (colorNum == 0) {
           color2 = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
       }
       else if (colorNum == paletteInEditor.divisionColors.length-1) {
           color2 = paletteInEditor.divisionColors[0];
       }
   }
   if (color2 != null) {
       if (componentIndex == 0 && paletteInEditor.colorType == "HSB") {
           var n = Math.floor(color2[0]);
           color2[0] = n + (value - Math.floor(value));
       }
       else {
           color2[componentIndex] = value;
       }
       saveRightColorWhileLocked = null;
   }
   colorEditCanvas.colorsChanged();
   newColorsInEditor();
}

function redrawHistogramPalette() {
     var hg = histogramPalette.getContext('2d');
     var onecopy = paletteLengthInEditor/maxIterations * (histogramPalette.width-2);
     for (var i = 1; i < histogramPalette.width-1; i++) {
         var fraction = ((i-1) % onecopy) / onecopy;
         var index = Math.max(0, Math.min(colorsInEditor.length,Math.round(fraction * colorsInEditor.length)));
         hg.fillStyle = colorsInEditor[index];
         hg.fillRect(i,0,1,histogramPalette.height);
     }
     hg.strokeStyle = "black";
     hg.strokeRect(0.5,0.5,histogramPalette.width-1,histogramPalette.height-1);
}

function setLeftRightColorsLocked() {
    var locked = document.getElementById("lockcolors").checked;
    colorEditCanvas.setLocked(locked);
}

function ColorEditCanvas() {
    var canvas = document.getElementById("coloredit");
    var g = canvas.getContext('2d');
    var size = canvas.width - 16;
    var colors = null;
    var selected;
    var prevX;
    var me = this;
    new Mouser(canvas, 
       function(x,y) {
           for (var i = 0; i < paletteInEditor.divisionPoints.length; i++) {
              var p = 8 + Math.floor(paletteInEditor.divisionPoints[i] * size);
              if ((x > p-2 && x < p+3) || (y > 48 && (x > p-6 & x < p+7))) {
                  prevX = x;
                  if (i != selected) {
                      me.select(i);
                      me.draw();
                  }
                  return i > 0 && i < paletteInEditor.divisionPoints.length - 1;
              }
           }
           return false;
       },
       function (x,y) {
            var position = 8 + Math.floor(paletteInEditor.divisionPoints[selected] * size);
            var left = 8 + Math.floor(paletteInEditor.divisionPoints[selected-1] * size);
            var right = 8 + Math.floor(paletteInEditor.divisionPoints[selected+1] * size);
            var change = x - prevX;
            prevX = x;
            var newposition = Math.min(right-10,Math.max(left+10,position + change));
            if (newposition != position) {
                paletteInEditor.divisionPoints[selected] = (newposition-8)/size;
                colors = null;
                newColorsInEditor();
            }
       },
       function () {
               if (!updateDuringDrag)
                   palettePreview.redraw();
           }
     );
     canvas.ondblclick = function(evt) {
        if (evt.button != 0)
           return;
        var r = canvas.getBoundingClientRect();
        var x = evt.clientX - r.left;
        var y = evt.clientY - r.top;    
        if (y > 50)
           return;
        for (var i = 1; i < paletteInEditor.divisionPoints.length; i++) {
            var leftDP = paletteInEditor.divisionPoints[i-1];
            var rightDP = paletteInEditor.divisionPoints[i];
            var left = 8 + Math.floor( leftDP * size);
            var right = 8 + Math.floor(rightDP * size);
            if (x > left+9 && x < right-9) {
                var divisionPt = (x-8)/size;
                var t = (divisionPt - leftDP) / (rightDP - leftDP);
                var leftCol = paletteInEditor.divisionColors[i-1];
                var rightCol = paletteInEditor.divisionColors[i];
                var col = [ (1-t)*leftCol[0]+t*rightCol[0], (1-t)*leftCol[1]+t*rightCol[1], (1-t)*leftCol[2]+t*rightCol[2] ];
                paletteInEditor.divisionPoints.splice(i,0,divisionPt);
                paletteInEditor.divisionColors.splice(i,0,col);
                me.select(i);
                me.draw();
                break;
            }
        }
     };
     this.addColorStop = function() {
         var left = selected - 1;
         var right = selected + 1; 
         while (left >= 0 || right < paletteInEditor.divisionPoints.length) {
                // try to find room alternately to left and to right of selected stop
            if (placeColorStopBetween(right-1,right))
               return;
            right++;
            if (placeColorStopBetween(left,left+1))
                return;
            left--;
         }
         alert("Sorry, can't find room for another color stop.");
         function placeColorStopBetween( a, b ) {  // b - a = 1
             if (a < 0 || b >= paletteInEditor.divisionPoints.length)
                return false;
             var leftDP = paletteInEditor.divisionPoints[a];
             var rightDP = paletteInEditor.divisionPoints[b];
             if ( (rightDP-leftDP)*size > 19) {
                var divisionPt = (leftDP + rightDP)/2;
                var leftCol = paletteInEditor.divisionColors[a];
                var rightCol = paletteInEditor.divisionColors[b];
                var col = [ (leftCol[0]+rightCol[0])/2, (leftCol[1]+rightCol[1])/2, (leftCol[2]+rightCol[2])/2 ];
                paletteInEditor.divisionPoints.splice(b,0,divisionPt);
                paletteInEditor.divisionColors.splice(b,0,col);
                me.select(b);
                me.draw();
                return true;
             }
             return false;
         }
     };
     this.deleteColorStop = function() {
         if (selected > 0 && selected < paletteInEditor.divisionPoints.length-1) {
             paletteInEditor.divisionPoints.splice(selected,1);
             paletteInEditor.divisionColors.splice(selected,1);
             me.select(selected-1);
             colors = null;
             newColorsInEditor();
             me.draw();
         }
     };
     this.setLocked = function(lock,onInstall) {
         leftRightColorsLocked = lock;
         if (onInstall) {
             saveRightColorWhileLocked = null;
             return;
         }
         var leftCol = paletteInEditor.divisionColors[0];
         var rightCol = paletteInEditor.divisionColors[paletteInEditor.divisionColors.length-1];
         if (leftRightColorsLocked) {
            var save = [];
            save.push(rightCol[0]);
            save.push(rightCol[1]);
            save.push(rightCol[2]);
            rightCol[1] = leftCol[1];
            rightCol[2] = leftCol[2];
            if (paletteInEditor.colorType == "HSB") {
                var n = Math.floor(rightCol[0]);
                rightCol[0] = n + (leftCol[0] - Math.floor(leftCol[0]));
            }
            else {
                rightCol[0] = leftCol[0];
            }
            colors = null;
            newColorsInEditor();
            if (selected == paletteInEditor.divisionColors.length-1)
               me.select(selected);
            saveRightColorWhileLocked = save;
         }
         else if (saveRightColorWhileLocked != null) {
            rightCol[0] = saveRightColorWhileLocked[0];
            rightCol[1] = saveRightColorWhileLocked[1];
            rightCol[2] = saveRightColorWhileLocked[2];
            saveRightColorWhileLocked = null;
            colors = null;
            newColorsInEditor();
            if (selected == paletteInEditor.divisionColors.length-1)
               me.select(selected);
         }
     };
     this.select = function(colorIndex) {
         selected = colorIndex;
         if (paletteInEditor.colorType == "HSB") { 
            var n = Math.floor(paletteInEditor.divisionColors[selected][0]); 
            colorSliders[0].reset(n,n+1,paletteInEditor.divisionColors[selected][0]);
            colorSliders[0].canvas.title = "Drag the slider to set the hue of the selected color stop to a value in the range " +
                                            n + " to " + (n+1) + ". Values outside this range can be set in the textbox.";
         }
         else {
             colorSliders[0].setValue(paletteInEditor.divisionColors[selected][0]);
         }
         colorSliders[1].setValue(paletteInEditor.divisionColors[selected][1]);
         colorSliders[2].setValue(paletteInEditor.divisionColors[selected][2]);
         document.getElementById("deletecolorstop").disabled = !(selected > 0 && selected < paletteInEditor.divisionPoints.length-1);
     };
     this.getSelected = function() {
        return selected;
     };
     this.colorsChanged = function() {
        colors = null;
     };
     this.draw = function() {
         g.fillStyle = "#e8e8e8";
         g.fillRect(0,0,canvas.width,canvas.height);
         if (colors == null)
             colors = paletteInEditor.makeCanvasColors(size,0);
         for (var i = 0; i < size; i++) {
             g.fillStyle = colors[i];
             g.fillRect(8+i,3,1,40);
         }
         g.lineWidth = 2;
         g.strokeRect(7,2,size+2,41);
         for (var i = 0; i < paletteInEditor.divisionPoints.length; i++) {
            var x = 8 + Math.floor(paletteInEditor.divisionPoints[i] * size);
            var c = paletteInEditor.divisionColors[i]; 
            c = paletteInEditor.toRGB(c[0],c[1],c[2]); 
            c = "rgb(" + c[0] + "," + c[1] + "," + c[2] + ")";
            if ( i == selected ) {
                g.fillStyle = "black";
                g.fillRect(x-3,1,6,42);
                g.fillRect(x-7,51,14,29);
                g.fillStyle = "lightgray";
                g.fillRect(x-2,2,4,40);
                g.fillRect(x-6,52,12,27);
                g.fillStyle = c;
                g.fillRect(x-1,3,2,38);
            }
            g.fillStyle = "black";
            g.fillRect(x-1,43,2,10);
            g.fillRect(x-5,53,10,25);
            g.fillStyle = c;
            g.fillRect(x-4,54,8,23);
         }
     };
}

function PalettePreview() {
   var previewIterationCounts;
   var previewRect;
   var preview = document.getElementById("preview");
   var g = preview.getContext("2d");
   if (canvas.width >= canvas.height) {
       var h = Math.round(canvas.height/canvas.width * (preview.height-2));
       previewRect = { left:1, top: 1+Math.floor((preview.height-h)/2), width: preview.width-2, height: h };
   }
   else {
       var w = Math.round(canvas.width/canvas.height * (preview.width-2));
       previewRect = { left: 1+Math.floor((preview.width-w)/2), top: 1, width: w, height: preview.height-2 };
   }
   var previewCounts = new Array(previewRect.height);
   var desiredRow = new Array(previewRect.height+1);
   var currentRow = new Array(previewRect.height);
   var i,j;
   for (i = 0; i < previewRect.height; i++) {
       desiredRow[i] = Math.floor( i * canvas.height/previewRect.height );
       currentRow[i] = -1;
   }
   desiredRow[previewRect.height+1] = canvas.height;
   for (i = 0; i < previewRect.height; i++) {
       for (j = desiredRow[i]; j < desiredRow[i+1]; j++) {
           if (savedIterationCounts[j]) {
               currentRow[i] = j;
               previewCounts[i] = new Int32Array(previewRect.width);
               for (var k = 0; k < previewRect.width; k++) {
                   var index = Math.floor( k / previewRect.width * savedIterationCounts[j].length );
                   previewCounts[i][k] = savedIterationCounts[j][index];
               }
               break;
           }
       }
   }
   this.update = function(newRowNumber, newRowCounts) {
      for (var k = 0; k < previewRect.height; k++) { 
          if (newRowNumber < desiredRow[k+1]) { 
             if (currentRow[k] == -1 || (currentRow[k] != desiredRow[k] && newRowNumber < currentRow[k])) { 
                 currentRow[k] = newRowNumber;
                 newColors(k,newRowCounts);
             }
             break;
          }
      }
   };
   function newColors(row,counts) {
       previewCounts[row] = new Int32Array(previewRect.width);
       for (var k = 0; k < previewRect.width; k++) {
           var index = Math.floor( k / previewRect.width * counts.length );
           previewCounts[row][k] = counts[index];
       }
       showRow(row);
   }
   function showRow(row) { 
       for (var k = 0; k < previewRect.width; k++) {
           if (previewCounts[row][k] == -1)
               g.fillStyle="black";
           else {
               var index = previewCounts[row][k] % paletteLengthInEditor;
               g.fillStyle = colorsInEditor[index];
           }
           g.fillRect(k+previewRect.left,row+previewRect.top,1,1);
       }
   }
   function drawBG() {
      g.fillStyle="#e8e8e8";
      g.fillRect(0,0,preview.width,preview.height);
      g.lineWidth = 1;
      g.strokeStyle = "black";
      g.strokeRect( previewRect.left-0.5, previewRect.top-0.5, previewRect.width+1, previewRect.height );
   }
   this.redraw = function() {
      drawBG();
      for (var i = 0; i < previewCounts.length; i++) {
         if (previewCounts[i])
             showRow(i);
      }
   };
}

function Histogram() {
   var canvas = document.getElementById("histogram");
   var histogramWidth = canvas.width - 15;
   var histogramHeight = canvas.height - 15;
   var histogramCounts = new Int32Array(maxIterations+1);
   for (var j = 0; j < savedIterationCounts.length; j++) {
       if (savedIterationCounts[j]) {
          var counts = savedIterationCounts[j];
          for (var k = 0; k < counts.length; k++)
              histogramCounts[counts[k]] ++;
       }
   }
   this.update = function(newcounts) {
       for (var i = 0; i < newcounts.length; i++) {
           histogramCounts[newcounts[i]] ++;
       }
       redraw();
   };
   function redraw() {
       var g = canvas.getContext("2d");
       g.fillStyle = "white";
       g.fillRect(0,0,canvas.width,canvas.height);
       g.lineWidth = 2;
       g.strokeStyle = "red";
       g.beginPath();
       g.moveTo(8,5);
       g.lineTo(8,canvas.height-8);
       g.lineTo(canvas.width-5,canvas.height-8);
       g.stroke();
       var i,a,b;
       var maxct = 0;
       for (i = 1; i < histogramCounts.length; i++)
           maxct = Math.max(histogramCounts[i],maxct);
       if (maxct == 0)
           return;
       g.lineWidth=1;
       g.strokeStyle="black";
       g.beginPath();
       for (i = 1; i < histogramCounts.length; i++) {
           if (histogramCounts[i] > 0) {
               a = Math.round(i/histogramCounts.length * histogramWidth) + 10.5;
               b = Math.ceil(histogramCounts[i]/maxct * histogramHeight) + 0.5; 
               g.moveTo(a,canvas.height-10);
               g.lineTo(a,canvas.height-10-b);
           }
       }
       g.stroke();
   }
   redraw();
}

function SliderAndInput(canvas,textbox,min,max,val,integerOnly,allowOutOfRange) {
    this.canvas = canvas;
    this.textbox = textbox;
    this.min = (typeof min == "number")? min : 0.0;    
    this.max = (typeof max == "number")? max : this.min + 100.0;    
    this.value = (typeof val == "number")? val : this.min;
    this.integerOnly = (typeof integerOnly == "undefined")? false : integerOnly;
    this.allowOutOfRange = (typeof allowOutOfRange == "undefined")? false : allowOutOfRange;
    this.allowLessThanMin = false;
    this.g = this.canvas.getContext("2d");
    this.g.translate(0,-8);  // fudge for resuing old code
    this.size = this.canvas.width - 25;
    if (this.allowOutOfRange)
       this.size -= 20;
    this.setTabLeft();
    this.valueToTextbox();
    this.draw();
    this.onchange = null;
    var me = this;
    var valueInTextbox, savedValueWhileEditing, saveTitle;
    textbox.style.color = "black";
    textbox.style.backgroundColor = "white";
    textbox.style.padding = "2px";
    textbox.onfocus = function() { 
        valueInTextbox = savedValueWhileEditing = this.value; 
        textbox.style.backgroundColor="#d8ffd8";
        saveTitle = textbox.title;
        textbox.title = "Editing slider value. Press return or move to another input box to apply the new value, if legal.";
    };
    textbox.onblur = function() { 
        textbox.style.backgroundColor="white";
        if (checkTextbox())
            me.setValue(valueInTextbox);
        else
            me.setValue(savedValueWhileEditing);
        if (!updateDuringDrag)
            palettePreview.redraw();
        me.valueToTextbox();
        textbox.title = saveTitle;
        textbox.style.backgroundColor = "white";
    };
    textbox.oninput = function() { 
        checkTextbox();
    };
    textbox.onkeydown = function(evt) {
       if (evt.keyCode == 13 && checkTextbox()) {
          me.setValue(valueInTextbox);
          valueInTextbox = me.value;
          if (!updateDuringDrag)
              palettePreview.redraw();
       }
    };
    function checkTextbox() {
       var val = Number(textbox.value);
       if (isNaN(val)) {
           textbox.style.backgroundColor = "#ff9090";
           textbox.title = "The value in the input box is not a number!";
           return false;
       }
       if (me.integerOnly)
          val = Math.round(val);
       if (val < 0 || (val < me.min && !me.allowLessThanMin) || (val > me.max && !me.allowOutOfRange)) {
           textbox.style.backgroundColor = "#ffff90";
           textbox.title = "The value in the textbox is not in the legal range for the slider";
           return false;
       }
       valueInTextbox = val;
       textbox.style.backgroundColor="#d8ffd8";
       textbox.title = "Editing slider value. Press return or move to another input box to apply the new value, if legal.";
       return true;
    }
    var offset;
    new Mouser(this.canvas,
        function(x,y) {
           if (y < 23 && x > me.tabLeft - 2 && x < me.tabLeft + 22) {
              offset = x - (me.tabLeft+10);
              return true;
           }
           else if (y > 20 && x > 14 && x < me.canvas.width - 5) {
              var val = (x - 15)/me.size * (me.max-me.min) + me.min;
              me.setValue(val);
              return false;
           }
        },
        function(x,y) {
           x = x - offset;
           var val = (x - 15)/me.size * (me.max-me.min) + me.min;
           if (val > me.max)
              val = me.max;
           if (val < me.min)
              val = me.min;
           me.setValue(val); 
        },
        function() {
            if (!updateDuringDrag)
                palettePreview.redraw();
        }
    );
}
SliderAndInput.prototype.setAllowOutOfRange = function( allow, allowLessThanMin ) {
    if (this.allowOutOfRange == allow && this.allowLessThanMin == allowLessThanMin)
       return;
    this.allowOutOfRange = allow;
    if (allowLessThanMin)
        this.allowLessThanMin = true;
    else
        this.allowLessThanMin = false;
    this.size = this.canvas.width - 25;
    if (this.allowOutOfRange)
       this.size -= 20;
    this.setTabLeft();
    this.draw();
};
SliderAndInput.prototype.reset = function(min,max,val) {
//    if (this.min != min || this.max != max) {
        this.min = min;
        this.max = max;
        this.value = "none";
        this.setValue(val);
//    }
};
SliderAndInput.prototype.setValue = function(val) { 
    var newval = this.integerOnly? Math.round(val) : val;
    if ( ! this.allowOutOfRange ) {
        newval = Math.min(this.max,newval);
    }
    if ( ! this.allowOutOfRange ) {
        newval = Math.max(this.min,newval);
    }
    newval = Math.max(0,newval);
    if (this.value != newval) { 
        this.value = newval;
        this.valueToTextbox();
        this.changed();
    }
};
SliderAndInput.prototype.valueToTextbox = function() {
    if (this.integerOnly)
        this.textbox.value = "" + this.value;
    else
        this.textbox.value = this.value.toPrecision(3);
};
SliderAndInput.prototype.setTabLeft = function() {
   if (this.value > this.max  || this.value < this.min)
      this.tabLeft = this.size + 20;
   else
      this.tabLeft = 5 + Math.floor((this.value - this.min)/(this.max - this.min) * this.size);
};
SliderAndInput.prototype.changed = function() {
   this.setTabLeft();
   this.draw();
   if (this.onchange)
      this.onchange(this.value);
};
SliderAndInput.prototype.draw = function() {
    var graphics = this.g;
    graphics.save();
    graphics.fillStyle = "#e8e8e8";
    graphics.fillRect(0,8,this.canvas.width,this.canvas.height);
    graphics.beginPath();
    graphics.moveTo(15, 35);
    graphics.lineTo(15 + this.size, 35);
    graphics.strokeStyle = "black";
    graphics.lineWidth = 10;
    graphics.lineCap = "round";
    graphics.stroke();
    graphics.strokeStyle = "gray";
    graphics.lineWidth = 7.5;
    graphics.lineCap = "butt";
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(15, 35);
    graphics.lineTo(Math.min(this.tabLeft + 10,15+this.size), 35);
    graphics.strokeStyle = "lightgray";
    graphics.stroke();
    graphics.fillStyle = "black";
    graphics.lineWidth = 1;
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 10, 36);
    graphics.lineTo(this.tabLeft + 20, 30);
    graphics.lineTo(this.tabLeft + 20, 10);
    graphics.lineTo(this.tabLeft, 10);
    graphics.lineTo(this.tabLeft, 30);
    graphics.closePath();
    graphics.fillStyle = "#9090FF";
    graphics.fill();
    graphics.strokeStyle = "#000099";
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 4.5, 14);
    graphics.lineTo(this.tabLeft + 4.5, 26);
    graphics.moveTo(this.tabLeft + 9.5, 14);
    graphics.lineTo(this.tabLeft + 9.5, 26);
    graphics.moveTo(this.tabLeft + 14.5, 14);
    graphics.lineTo(this.tabLeft + 14.5, 26);
    graphics.stroke();
    graphics.beginPath();
    graphics.moveTo(this.tabLeft + 6, 16);
    graphics.lineTo(this.tabLeft + 6, 28);
    graphics.moveTo(this.tabLeft + 11, 16);
    graphics.lineTo(this.tabLeft + 11, 28);
    graphics.moveTo(this.tabLeft + 16, 16);
    graphics.lineTo(this.tabLeft + 16, 28);
    graphics.strokeStyle = "white";
    graphics.stroke();
    graphics.restore();
};



//-------------------------------------------------------------------------------------------

function currentExampletoXML() {
    var offset = Math.round(paletteOffsetFraction * paletteLength);
    return "<?xml version='1.0'?>\n<mandelbrot_settings_2>\n" +
            "<image_size width='" + canvas.width + "' height='" + canvas.height + "'/>\n" +
            "<limits>\n   <xmin>" + xmin_requested.toString() + "</xmin>\n" +
            "   <xmax>" + xmax_requested.toString() + "</xmax>\n" +
            "   <ymin>" + ymin_requested.toString() + "</ymin>\n" +
            "   <ymax>" + ymax_requested.toString() + "</ymax>\n</limits>\n" +
            palette.toXMLString() +
            "<palette_mapping length='" + paletteLength + "' offset='" + offset + "'/>\n" +
            "<max_iterations value='" + maxIterations + "'/>\n" +
            "</mandelbrot_settings_2>\n";
}

function installExampleFromXML(xmlString, recordUndo, respectSize, dontShowError) {
    var oldXML = currentXML;
    stopJob();
    try {
      var parser = new DOMParser();
      var doc = parser.parseFromString(xmlString,"text/xml").documentElement;
      var width,height,xmin,xmax,ymin,ymax,colors,length,offset,iterations;
      if (respectSize) {
          var size = doc.getElementsByTagName("image_size");
          if (size == 0) {
              respectSize = false;
          }
          else {
              width = Number(size[0].getAttribute("width"));
              height = Number(size[0].getAttribute("height"));
              if (isNaN(width) || width > 10000 || width < 50 || isNaN(height) || height > 10000 || height < 50) {
                   respectSize = false;
              }
          }
      }
      xmin = doc.getElementsByTagName("xmin").item(0).textContent;
      xmax = doc.getElementsByTagName("xmax").item(0).textContent;
      ymin = doc.getElementsByTagName("ymin").item(0).textContent;
      ymax = doc.getElementsByTagName("ymax").item(0).textContent;
      colors = Palette.fromXML( doc.getElementsByTagName("palette").item(0));
      var map = doc.getElementsByTagName("palette_mapping");
      if (map.length > 0) {
          length = Number(map.item(0).getAttribute("length"));
          offset = Number(map.item(0).getAttribute("offset"));
      }
      else {
          length = 250;
          offset = 0;
      }
      iterations = Number(doc.getElementsByTagName("max_iterations").item(0).getAttribute("value"));
      xmin = new BigDecimal(xmin);
      xmax = new BigDecimal(xmax);
      ymin = new BigDecimal(ymin);
      ymax = new BigDecimal(ymax);
      if (isNaN(length) || isNaN(offset) || isNaN(iterations)) {
          throw "Bad number.";
      }
      if (length == 0) {
          length = iterations;
      }
      palette = colors;
      maxIterations = Math.round(iterations);
      if ([25,50,100,250,500,1000,2500,5000,10000,25000,50000].indexOf(maxIterations) < 0) {
          document.getElementById("custommaxiter").style.display = "inline";
          document.getElementById("maxIterSelect").value = "Custom";
          document.getElementById("maxiterinput").value = "" + iterations;
      }
      else {
          document.getElementById("custommaxiter").style.display = "none";
          document.getElementById("maxIterSelect").value = "" + maxIterations;
      }
      length = Math.round(length);
      if (length == 0) {
         stretchPalette = true;
         document.getElementById("paletteLengthSelect").value = "Match MaxIter";
         document.getElementById("custompallen").style.display = "none";
      }
      else  {
          stretchPalette = false;
          fixedPaletteLength = length;
          if ([50,100,250,500,1000,2500,5000].indexOf(length) < 0) {
             document.getElementById("custompallen").style.display = "inline";
             document.getElementById("paletteLengthSelect").value = "Custom";
             document.getElementById("palleninput").value = "" + length;
          }
          else {
             document.getElementById("custompallen").style.display = "none";
             document.getElementById("paletteLengthSelect").value = "" + length;
          }
      }
      paletteOffsetFraction = offset/length;
      paletteOffsetFraction = paletteOffsetFraction - Math.floor(paletteOffsetFraction);
      paletteOffsetFraction = Math.round(10000*paletteOffsetFraction)/10000;
      if (offset == 0) {
           document.getElementById("custoffset").style.display = "none";
           document.getElementById("paletteOffsetSelect").value = "0";
      }
      else {
           document.getElementById("custoffset").style.display = "inline";
           document.getElementById("paletteOffsetSelect").value = "Custom";
           var current = 100*paletteOffsetFraction;
           document.getElementById("offsetinput").value = (current == Math.round(current))? current : current.toPrecision(3);
      }
      createPaletteColors();
      if (respectSize) {
         setImageSize(width,height);
         var val = width + " " + height;
         if (["200 150", "400 300", "640 480", "800 600", "1024 768", "1200 900", "1600 900", "425 550", "850 1100"].indexOf(val) < 0) {
             document.getElementById("imagesize").value = "Custom";
             document.getElementById("customsize").style.display = "inline";
             document.getElementById("customwidth").value = "" + width;
             document.getElementById("customheight").value = "" + height;
         }
         else {
             document.getElementById("imagesize").value = val;
             document.getElementById("customsize").style.display = "none";
         }
      }
      setLimits(xmin,xmax,ymin,ymax,false);
      startJob();
      if (recordUndo && undoList) {
          addUndoItem("Import Example", oldXML, currentXML);
      }
      return null;
    }
    catch (e) {
        var error =  "Illegal data in XML example string: " + e;
        if ( ! dontShowError )
           document.getElementById("status").innerHTML = error;
        return error;
    }
}

function installExampleWithAjax(url) {
    document.getElementById("status").innerHTML = "Trying to Fetch example from " + url;
    var ajaxTimeout;
    var ajax = new XMLHttpRequest();
    ajax.open("GET",url);
    ajax.overrideMimeType("text/plain");
    ajax.addEventListener("error",function() {
        clearTimeout(ajaxTimeout);
        document.getElementById("status").innerHTML = "Error: Example could not be loaded from " + url;
    });
    ajax.addEventListener("load",function() {
        clearTimeout(ajaxTimeout);
        installExampleFromXML(ajax.responseText, false, false);
    });
    ajaxTimeout = setTimeout(function() {
        ajax.abort();
        document.getElementById("status").innerHTML = "Error: Request timed out while trying to load from " + url;
    }, 10000);
    try {
       ajax.send();
    } catch(e) {
        clearTimeout(ajaxTimeout);
        document.getElementById("status").innerHTML = "Error while trying to send request for example: " + url;
    }
}

function importXML() {
    document.getElementById("XMLtextinput").value = "";
    document.getElementById("xmlimportbg").style.display = "block";
    document.getElementById("xmlimport").style.display = "block";
    document.addEventListener("keydown", doKey, false);
    document.getElementById("cancelXMLimport").onclick = dismiss;
    document.getElementById("applyXMLimport").onclick = apply;
    document.getElementById("grabcurrent").onclick = grabCurrent;
    function apply() {
        var text = document.getElementById("XMLtextinput").value.trim();
        if (text == "") {
            dismiss();
        }
        else {
            var errorMsg = installExampleFromXML(text,true,false);
            if (errorMsg == null)
               dismiss();
            else
               alert("Error in input: " + errorMsg);
        }
    }
    function dismiss() {
        document.getElementById("xmlimportbg").style.display = "none";
        document.getElementById("xmlimport").style.display = "none";
        document.removeEventListener("keydown", doKey, false);
    }
    function grabCurrent() {
        document.getElementById("XMLtextinput").value = currentXML;
    }
    function doKey(evt) {
        var code = evt.keyCode;
        if (code == 27) {
            dismiss();
        }
    }
}

function checkForExample() {
    var ex = window.location.search.match("^\\?ex=([a-zA-Z0-9/.%_+-]+)");
    if (ex) {
       stopJob();
       installExampleWithAjax(decodeURIComponent(ex[1]), false);
    }
}

function initGpuWorker(msg) { // responds to first message from WebGPU worker, with response "ok" or "error"; added May 2023
   var data = msg.data;
   if (data[0] === "ok") {
      gpu_ok = true;
      document.getElementById("gpuholder").style.display = "block";
      document.getElementById("gpuselect").checked = true;
      let msg = "WebGPU has been initialized and is available for use (in high precision computation only).";
      if (data[1] === true)  // data[1] is adapter.isFallbackAdapter
         msg += "<br>WARNING: Your browser is doing WebGPU with software emulation, which might have poor performance.";
      document.getElementById("gpumessage").innerHTML = msg;   
      gpuWorker.onmessage = jobFinished;
      if (running && highPrecision && jobs.length > 0) {
          gpuWorker.postMessage(["setup",jobNum, maxIterations,highPrecision,-1]);  // add gpuWorker to current job
          document.getElementById("gpuinfo").innerHTML = "Using the WebGPU worker.";
          runningWithGPU = true;
      }
   }
   else { //  (data[0] must be "error")
      document.getElementById("gpumessage").innerHTML = "WebGPU can't be used:  " + data[1];
      gpuWorker.terminate();
      gpuWorker = null;
   }
}

function init() {
    try {
        canvas = document.getElementById("canvas");
        graphics = canvas.getContext("2d");
        OSC = document.createElement("canvas");
        OSC.width = canvas.width;
        OSC.height = canvas.height;
        OSG = OSC.getContext("2d");
    }
    catch (e) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires canvas support, which is not available in your browser.";
         return;
    }
    if (! window.Worker ) {
         document.getElementById("message").innerHTML =
             "Sorry, this page requires WebWorker support, which is not available in your browser.";
         return;
    }
    palette = new Palette();
    document.getElementById("restoreButton").onclick = setDefaults;
    document.getElementById("stop").onclick = stopJob;
    document.getElementById("interlaced").onchange = changeInterlaced;
    document.getElementById("interlaced").checked = interlaced;
    document.getElementById("imagesize").onchange = changeImageSize;
    document.getElementById("applysize").onclick = doCustomSize;
    try {
      var ct = Number(localStorage.getItem("mandelbrotWorkerCount"));
      if (!isNaN(ct) && ct > 0 && ct <= 16) {
          workerCount = ct;
      }
    }
    catch(e) {
    }
    document.getElementById("threadCountSelect").value = "" + workerCount;
    document.getElementById("threadCountSelect").onchange = changeWorkerCount;
    document.getElementById("maxIterSelect").onchange = changeMaxIterations;
    document.getElementById("maxiterapply").onclick = doCustomMaxIterations;
    document.getElementById("paletteLengthSelect").onchange = changePaletteLength;
    document.getElementById("pallenapply").onclick = doCustomPaletteLength;
    document.getElementById("paletteOffsetSelect").onchange = changePaletteOffset;
    document.getElementById("offsetapply").onclick = doApplyCustomPaletteOffset;
    document.getElementById("standardPaletteButton").onclick = doApplyStandardPalette;
    document.getElementById("standardPaletteSelect").value = "EarthAndSky";
    document.getElementById("showpaletteedit").onclick=showPaletteEditor;
    document.getElementById("secondpass").checked = true;
    document.getElementById("secondpass").onchange = changeSecondPass;
    document.getElementById("zoomInAmount").value = "0.1";
    document.getElementById("zoomOutAmount").value = "10";
    document.getElementById("zoomin").onclick = doZoomIn;
    document.getElementById("zoomout").onclick = doZoomOut;
    document.getElementById("importXML").onclick = importXML;
    document.getElementById("undo").onclick = doUndo;
    document.getElementById("undo").disabled = true;
    document.getElementById("redo").onclick = doRedo;
    document.getElementById("redo").disabled = true;
    setUpDragging();
    changeWorkerCount(); // has to be done before setDefaults
    setDefaults();
    checkForExample();
    undoList = [];
    undoCount = 0;
    gpuWorker = new Worker("mandelbrot-worker-gpu.js"); // WebGPU support added May 2023
    gpuWorker.onmessage = initGpuWorker;
    gpuWorker.postMessage("init");
}
</script>
</head>
<body onload="init()">

<noscript><b>Sorry, this page requires JavaScript.</b></noscript>

<h2 style="margin-top:0">Explore the Mandelbrot Set<br>Experimental Version with WebGPU Support</h2>
<p><b>Drag on the image to draw a box, and the program will zoom in on that box.<br>
(<a href="MB-info.html" style="font-size:120%">Click here</a> for more info, instructions, and examples.)</b></p>
<p id="gpumessage" style="font-weight:bold; color:#990000">This is an experimental version with WebGPU support, if it is available in your browser.</p>
<p id="message"></p>

<table border=0 cellpadding=0 cellspacing=0>
<tr valign="top"><td>
<div id="controls">
   <div class="group">
      <p><button id="restoreButton" title="Restore default limits, image size, palette, max iterations.">Restore Defaults</button><button id="stop" style="margin-left:20px" title="Abort the current computation, if any, leaving an incomplete image.">Stop</button></p>
   </div>
   <div class="group">
      <p><label title="If checked, lines in image are computed out of order.  This can give a general idea of the image more quickly."><input type="checkbox" id="interlaced">Interlaced Drawing</label></p>
      <p><label title="If checked, extra computations are done that can often give the completed image a smoother look, by computing two samples per pixel and averaging the resulting colors."><input type="checkbox" id="secondpass">Do a Second Pass</label></p>
      <p><label title="Increasing this might speed up computation by using more of your computer's processing time.  (Values above the number of CPU threads that your computer supports will not add additional speed.)">CPU Workers: <select id="threadCountSelect">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="10">10</option>
          <option value="12">12</option>
          <option value="16">16</option>
      </select></label></p>
      <p id="gpuholder" style="display:none"><label title="If checked, WebGPU will be used for high precision computation, along with the CPU workers.  High precision is only used when you have zoomed in so far that ordinary numbers don't have enough precision for the calsulation."><input id="gpuselect" type=checkbox>Use WebGPU for HP</label></p>
   </div>
   <div class="group">
      <p><button id="undo">Undo</button></p>
      <p><button id="redo">Redo</button></p>
   </div>
   <div class="group">
      <p><label title="Width and height of the Mandelbrot picture, in pixels.">Image Size: <select id="imagesize">
          <option value="200 150">200x150</option>
          <option value="400 300">400x300</option>
          <option value="640 480">640x480</option>
          <option value="800 600">800x600</option>
          <option value="1024 768">1024x768</option>
          <option value="1200 900">1200x900</option>
          <option value="1600 900">1600x900</option>
          <option value="425 550">425x550</option>
          <option value="850 1100">850x1100</option>
          <option value="Custom">Custom</option>
      </select></label><span id="customsize" style="display:none"><br><input type="text" maxlength="5" size="4" id="customwidth">x<input type="text" maxlength="5" size="4" id="customheight"> <button id="applysize">Apply</button></label></span></p>
   </div>
   <div class="group">
      <p><label title="How many steps in the Mandelbrot iteration before giving up and coloring the pixel black.  Increasing this can fill black areas that aren't really part of the Mandelbrot set with color.">MaxIterations: <select id="maxIterSelect">
         <option value="25">25</option>
         <option value="50">50</option>
         <option value="100">100</option>
         <option value="250">250</option>
         <option value="500">500</option>
         <option value="1000">1000</option>
         <option value="2500">2500</option>
         <option value="5000">5000</option>
         <option value="10000">10000</option>
         <option value="25000">25000</option>
         <option value="50000">50000</option>
         <option value="Custom">Custom</option>
      </select></label><span id="custommaxiter" style="display:none"><br><input type="text" maxlength="6" size="5" id="maxiterinput"> <button id="maxiterapply">Apply</button></span></p>
   </div>
   <div class="group">
      <p><button id="showpaletteedit" title="Show a popup dialog box that gives greater control over the palette.">Show Palette Editor</button>
            &nbsp;(<a href="palette-editor-info.png" target="_blank" title="Opens a guide to the Palette Editor in a separate tab or window.">info</a>)</p>
      <p><label title="Size of the color palette for pixels outside the Mandebrot set.">PaletteLength: <select id="paletteLengthSelect">
            <option value="Match">= MaxIter</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="250">250</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
            <option value="2500">2500</option>
            <option value="5000">5000</option>
            <option value="Custom">Custom</option>
      </select></label><span id="custompallen" style="display:none"><br><input type="text" maxlength="5" size="4" id="palleninput"><button id="pallenapply">Apply</button></span>
      <p><label title="Offsets the colors within the palette to get a different mapping.">PaletteOffset: <select id="paletteOffsetSelect">
            <option value="0">None</option>
            <option value="0.1">10%</option>
            <option value="0.2">20%</option>
            <option value="0.3">30%</option>
            <option value="0.4">40%</option>
            <option value="0.5">50%</option>
            <option value="0.6">60%</option>
            <option value="0.7">70%</option>
            <option value="0.8">80%</option>
            <option value="0.9">90%</option>
            <option value="Custom">Custom</option>
      </select></label><span id="custoffset" style="display:none"><br><input type="text" id="offsetinput" maxlength="6" size="5"><b>%</b> &nbsp;<button id="offsetapply">Apply</button></span></p>
      <p style="margin-bottom:4px"><button id="standardPaletteButton" title="Click here to apply the palette of colors selected in the popup menu below.">Apply Standard Palette:</button></p>
      <p style="margin-top:0"><select id="standardPaletteSelect" style="margin-left:70px" title="Some palettes of colors to be applied to the Mandelbrot image.  Click the above button to apply the selected palette.">
            <option value="Spectrum">Spectrum</option>
            <option value="EarthAndSky">EarthAndSky</option>
            <option value="Cyclic Fire">Fire</option>
            <option value="Seashore">Seashore</option>
            <option value="TreeColors">Forest</option>
            <option value="Pastels">Pastel Colors</option>
            <option value="Dark">Dark Colors</option>
            <option value="HotAndCold">HotAndCold</option>
            <option value="CyclicGrayscale">Grayscale</option>
            <option value="Random">Random</option>
            <!--<option value="Red/Cyan">Red/Cyan</option>
                <option value="Blue/Gold">Blue/Gold</option>
                <option value="Grayscale">Grayscale</option> -->
      </select></p>
   </div>
   <div class="group">
      <p><button id="zoomin">Zoom in by: </button> <select id="zoomInAmount">
           <option value="0.5">2 X</option>
           <option value="0.2">5 X</option>
           <option value="0.1">10 X</option>
           <option value="0.05">20 X</option>
           <option value="0.02">50 X</option>
           <option value="0.01">100 X</option>
           <option value="0.001">1,000 X</option>
           <option value="0.00001">10,000 X</option>
           <option value="0.000001">100,000 X</option>
      </select></p>
      <p><button id="zoomout">Zoom out by: </button> <select id="zoomOutAmount">
           <option value="2">2 X</option>
           <option value="5">5 X</option>
           <option value="10">10 X</option>
           <option value="20">20 X</option>
           <option value="50">50 X</option>
           <option value="100">100 X</option>
           <option value="1000">1,000 X</option>
           <option value="10000">10,000 X</option>
           <option value="100000">100,000 X</option>
      </select></p>
   </div>
   <div class="group">
      <p><button id="importXML" title="Put up an input box into which you can copy-and-paste the XML code for an example, or get the XML for the current example.">Show XML Import/Export</button></p>
   </div>
</div>
<td>
  <div id="imagediv">
  <p id="status">Image size 800x600.  Idle.</p>
  <p><div id="canvas-holder">
     <canvas id="canvas" width="800" height="600"></canvas>
  </div></p>
  <p id="gpuinfo">&nbsp;</p>
  </div>
</td>
</tr>
</table>

<div id="xmlimportbg">
</div>
<div id="xmlimport">
<p>Mandelbrot examples can be coded as "XML documents."<br>
You can copy-and-paste the XML code for an example<br>
into this text input box.  Click "Apply" to import the<br>
example.  Click "Cancel" or press ESC to cancel. The <br>
"Grab Current Example" button loads the XML for the<br>
example that is currently shown in the program; this<br>
allows you to save the example (or even edit it by hand).</p>
<p><button style="margin-left:50px" id="applyXMLimport">Apply</button>
<button style="margin-left:20px" id="cancelXMLimport">Cancel</button>
<button style="margin-left:20px" id="grabcurrent">Grab Current Example</button></p>
<p><textarea rows="21" cols="55" id="XMLtextinput" placeholder="XML code goes here"></textarea>
</div>


<div id="paletteEditor">
<table bgcolor="#E8E8E8" cellpadding=3 cellspacing=0 border=2>
<tr>
   <td colspan=2>
      <table width=620 border=0>
      <tr><td align=left><button id="paletteEditStandardInstall"  
             title="Click this button to replace the palette below with the standard palette that is selected on the right.">Install:</button>
          <select id="paletteEditStandardSelect" title="Click the button on the left to apply this palette in the palette editor.">
            <option value="Spectrum">Spectrum</option>
            <option value="EarthAndSky">EarthAndSky</option>
            <option value="Cyclic Fire">Fire</option>
            <option value="Seashore">Seashore</option>
            <option value="TreeColors">Forest</option>
            <option value="Pastels">Pastel Colors</option>
            <option value="Dark">Dark Colors</option>
            <option value="HotAndCold">HotAndCold</option>
            <option value="CyclicGrayscale">Grayscale</option>
            <option value="Random">Random</option>
          </select></td>
          <td align=right><button id="addcolorstop"
                title="Click to add a color stop to the palette below. The stop will be added next to the currently selected stop, if possible.  You can also add a stop by double-clicking the palette.">Add Color Stop</button>
                <button id="deletecolorstop" title="Click to delete the selected color stop. The first and last stops cannot be deleted.">Delete</button>
                <label style="margin-left:20pt" title="Check this box to lock the colors of the first and last color stops so that the two colors are forced to be the same.">Lock<input type="checkbox" id="lockcolors"></label>
          </td>
      </tr>
      </table>
      <p style="margin: 5px 0 0 0"><canvas id="coloredit" width=630 height=80
           title="Click a color stop to select it.  Drag selected color stop (except for the two at the ends) to move it.  Double-click in a free area to add a color stop."></canvas></p>
      <table border=0 cellpadding=0 style="margin:0 0 0 20px">
       <tr><td><canvas id="colorslider0" width=401 height=40
           title="Drag the slider to set the first color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput0" size=5 title="You can type a value for the first color component here, 0.0 to 1.0 for Red, anything greater than or equal to zero for Hue.">
           <span id="colorlabel0">Hue</span></td>
       </tr>
       <tr><td><canvas id="colorslider1" width=401 height=40
           title="Drag the slider to set the second color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput1" size=5 title="You can type a value for the second color component here, in the range 0.0 to 1.0.">
           <span id="colorlabel1">Saturation</span></td>
       </tr>
       <tr><td><canvas id="colorslider2" width=401 height=40
           title="Drag the slider to set the third color component of the selected color stop to a value in the range 0.0 to 1.0."></canvas></td>
           <td><input type=text id="colorinput2" size=5 title="You can type a value for the third color component here, in the range 0.0 to 1.0.">
           <span id="colorlabel2">Brightness</span></td>
       </tr>
      </table>
   </td>
</tr>
<tr>
   <td valign=top>
      <canvas id="histogram" width=420 height=100
          title="Shows the distribution of iteration counts in the image, from 1 up to MaxIterations.  This can help with selecting a good palette length."></canvas>
      <p style="margin: 3px 0 0 9px"><canvas id="histogrampalette" width=408 height=22 style="display:inline"
          title="Shows how colors from palette will actually be applied to each iteration count, based on palette length and palette offset."></canvas></p>
      <table border=0 cellpadding=0 style="margin:3px 0 0 0">
       <tr><td colspan=2><canvas id="lengthslider" width=420 height=40
           title="Drag the slider to set the palette length.  Slider shows values between 1 and MaxIterations.  You can set an even larger value in the input box below."></canvas></td>
       </tr>
       <tr><td align=right colspan=2>
              <input type=text id="editorlengthinput" size=5 
                  title="You can type a value for the palette length here.  It must be 1 or more.">Palette Length</td>
       </tr>
       <tr><td align=right><canvas id="offsetslider" width=250 height=40
           title="Drag the slider to set the palette offset as a percentage in the range 0 to 100."></canvas></td>
           <td align=left><input type=text id="editoroffsetinput" size=5 title="You can type a value for the palette offset percentage, in the range 0.0 to 100.0.">%&nbsp;&nbsp;Offset</td>
       </tr>
      </table>
   </td>
   <td valign=top width=200>
       <table border=0 cellpadding=0>
         <tr><td><canvas id="preview" width=200 height=200 
               title="A rough copy of the current image, with edited colors applied, giving a preview of the image with the edited palette."></td></tr>
         <tr><td><label title="If this box is unchecked, changes are only applied to the above preview when a drag action end.  Uncheck the box if your computer is having trouble keeping up as you drag a slider or color stop.">
               <input type=checkbox id="updateWhileDraggingCheck" checked>UpdateDuringDrag</label></td></tr>
       </table>
   </td>
</tr>
<tr>
   <td align=center  colspan=2>
   <button id="dismissPaletteEdit" title="Cancel palette editing, leaving colors in the image unchanged.">Cancel</button>
   <button id="revertPaletteEdit" title="Restore the palette to the its state when the palette editor was opened.">Revert Palette</button>
   <button id="applyPaletteEdit"  title="Dismiss the palette editor and apply the palette from the editor to the main image.">Apply and Close</button>
   </td>
</tr>
</table>
</div>

</body>
</html>
